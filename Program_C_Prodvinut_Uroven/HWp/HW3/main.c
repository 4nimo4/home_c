/*
//------------------------------------------------------
//       Игра змейка продолжение
//------------------------------------------------------
1. Доработайте функционал игры зиейка. Реализуйте в игре 
ситуацию, когда змея врезается сама в себя, при этом следует 
выход из игры и выводом сообщения "THE END!" с небольшой задержкой.
При этом обычный выход из игры по нажатию F10 также с задержкой выводит
сообщение "STOP GAME!" 
2. Реализовать выход за границы экрана во все стороны, 
(при уходе за границы экрана, змейка появляется с противоположной
стороны). Согласовать скорости движения змейки в вертикальной и 
горизонтальной плоскости. (Сейчас в горизонтальной плоскости движение 
змейки медленне, чем в верикальной)
3. Запрещается разворот змейки, сразу в противоположную сторону от
текущего направления движения (она не должна есть свой хвост),
так же змейка не должна съедать сообщение о завершении игры, находящееся
в верхней части экрана (Use arrows for control. Press 'F10' for EXIT")
4. Переписать timeout через clock
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <ncurses.h>   // библиотека для работы с «графикой» в терминале
#include <inttypes.h>
#include <string.h>
#include <unistd.h>

//------------------------------------------------------
// Константы и перечисления
//------------------------------------------------------

// Минимальная координата Y, с которой может двигаться змейка.
// Строки 0 и 1 заняты служебной информацией/сообщениями.
#define MIN_Y 2

// Направления движения змейки и код остановки игры.
// STOP_GAME соответствует нажатию F10 (макрос KEY_F(10) из ncurses).
enum {LEFT=1, UP, RIGHT, DOWN, STOP_GAME=KEY_F(10)};

// Разные игровые размеры и задел «на будущее».
enum {
    MAX_TAIL_SIZE       = 100,  // максимальная длина хвоста (размер выделяемого массива)
    START_TAIL_SIZE     = 3,    // начальная длина хвоста (кол-во сегментов)
    MAX_FOOD            = 20,   // не используется, задел для еды
    FOOD_EXPIRE_SECONDS = 10    // не используется, задел для времени «жизни» еды
};

//------------------------------------------------------
// Структуры
//------------------------------------------------------

// Структура, описывающая коды клавиш управления змейкой.
struct control_buttons {
    int down;
    int up;
    int left;
    int right;
} control_buttons;

// Набор кнопок по умолчанию — стрелки клавиатуры.
struct control_buttons default_controls = {
    KEY_DOWN,
    KEY_UP,
    KEY_LEFT,
    KEY_RIGHT
};

// Один сегмент хвоста: просто координаты на экране.
typedef struct tail_t {
    int x;
    int y;
} tail_t;

// Структура, описывающая состояние змейки.
typedef struct snake_t {
    int x;                     // x-координата головы
    int y;                     // y-координата головы
    int direction;             // текущее направление движения (LEFT/RIGHT/UP/DOWN)
    size_t tsize;              // текущая длина хвоста (кол-во сегментов, которые рисуем)
    tail_t *tail;              // динамический массив сегментов хвоста
    struct control_buttons controls; // назначенные клавиши управления
} snake_t;

//------------------------------------------------------
// Инициализация
//------------------------------------------------------

// Инициализация массива хвоста начальными координатами (0,0).
// Это «пустое» состояние, хвост ещё нигде не нарисован.
void initTail(tail_t t[], size_t size)
{
    tail_t init_t = {0, 0};
    for (size_t i = 0; i < size; i++)
        t[i] = init_t;
}

// Инициализация головы змейки: начальные координаты и направление.
void initHead(snake_t *head, int x, int y)
{
    head->x = x;
    head->y = y;
    head->direction = RIGHT;   // по умолчанию змейка двигается вправо
}

// Полная инициализация змейки:
// - выделение памяти под хвост,
// - обнуление хвоста,
// - установка головы,
// - назначение управления.
void initSnake(snake_t *head, size_t size, int x, int y)
{
    // Выделяем память под максимально возможный хвост.
    tail_t* tail = (tail_t*) malloc(MAX_TAIL_SIZE * sizeof(tail_t));
    initTail(tail, MAX_TAIL_SIZE);

    // Устанавливаем начальные координаты и направление головы.
    initHead(head, x, y);

    // Привязываем хвост к змейке и запоминаем начальную длину хвоста.
    head->tail = tail;
    head->tsize = size;          // длина хвоста = START_TAIL_SIZE
    head->controls = default_controls;
}

//------------------------------------------------------
// Проверка на столкновение с собой
//------------------------------------------------------

// Проходим по всем сегментам хвоста и смотрим,
// совпадает ли какая-то позиция с координатами головы.
// Если да — значит, голова врезалась в хвост.
int isSelfCollision(const snake_t *s)
{
    for (size_t i = 0; i < s->tsize; ++i)
    {
        if (s->tail[i].x == s->x && s->tail[i].y == s->y)
            return 1;
    }
    return 0;
}

//------------------------------------------------------
// Движение головы
//------------------------------------------------------

// Смещает голову змейки на одну клетку в текущем направлении.
// При выходе за границы окна — «зацикливает» координату
// (выход с одной стороны — появление с противоположной).
void go(snake_t *head)
{
    char ch = '@';      // символ, которым рисуем голову
    int max_x = 0, max_y = 0;

    // Получаем размеры окна (количество строк и столбцов).
    getmaxyx(stdscr, max_y, max_x);
    max_x -= 1;         // последние валидные индексы по X и Y
    max_y -= 1;

    // Изменяем координаты головы в зависимости от направления.
    switch (head->direction)
    {
        case LEFT:
            if (head->x <= 0)
                head->x = max_x;   // выход за левую границу -> справа
            else
                head->x--;
            break;
        case RIGHT:
            if (head->x >= max_x)
                head->x = 0;       // выход за правую границу -> слева
            else
                head->x++;
            break;
        case UP:
            if (head->y <= MIN_Y)
                head->y = max_y;   // выход за верхнюю (игровую) границу -> снизу
            else
                head->y--;
            break;
        case DOWN:
            if (head->y >= max_y)
                head->y = MIN_Y;   // выход за нижнюю границу -> сверху (но не на строку с текстом)
            else
                head->y++;
            break;
        default:
            break;
    }

    // Рисуем голову в новой позиции.
    mvprintw(head->y, head->x, "%c", ch);
}

//------------------------------------------------------
// Движение хвоста
//------------------------------------------------------
/*
 head_prev_x, head_prev_y — координаты головы ДО движения.
 Первый сегмент хвоста должен занять именно эти координаты,
 чтобы хвост «тянулся» следом за головой без отставания.
*/
void goTail(snake_t *head, int head_prev_x, int head_prev_y)
{
    char ch = '*';

    // Стираем (очищаем) последний видимый сегмент хвоста.
    mvprintw(head->tail[head->tsize - 1].y,
             head->tail[head->tsize - 1].x, " ");

    // Сдвигаем хвост: каждый сегмент копирует координаты предыдущего.
    for (size_t i = head->tsize - 1; i > 0; i--)
    {
        head->tail[i] = head->tail[i - 1];
    }

    // Первый сегмент хвоста встаёт на позицию, где была голова до шага.
    head->tail[0].x = head_prev_x;
    head->tail[0].y = head_prev_y;

    // Перерисовываем все сегменты хвоста.
    for (size_t i = 0; i < head->tsize; ++i)
    {
        // Проверка на (0,0) нужна, чтобы не рисовать «пустые» сегменты
        // в начале игры, пока хвост ещё не растянут.
        if (head->tail[i].x || head->tail[i].y)
            mvprintw(head->tail[i].y, head->tail[i].x, "%c", ch);
    }
}

//------------------------------------------------------
// Изменение направления (с запретом разворота на 180°)
//------------------------------------------------------

// Обновляет направление движения змейки на основе нажатой клавиши,
// но не даёт развернуться сразу на 180° (в противоположную сторону),
// чтобы змейка не могла «въехать» в свой хвост.
void changeDirection(snake_t* snake, const int32_t key)
{
    int new_dir = snake->direction;

    // Определяем новое предполагаемое направление по нажатой клавише.
    if (key == snake->controls.down)
        new_dir = DOWN;
    else if (key == snake->controls.up)
        new_dir = UP;
    else if (key == snake->controls.right)
        new_dir = RIGHT;
    else if (key == snake->controls.left)
        new_dir = LEFT;
    else
        return; // если нажата другая клавиша — ничего не меняем

    // Проверка на разворот на 180 градусов.
    if ((snake->direction == LEFT  && new_dir == RIGHT) ||
        (snake->direction == RIGHT && new_dir == LEFT ) ||
        (snake->direction == UP    && new_dir == DOWN ) ||
        (snake->direction == DOWN  && new_dir == UP   ))
    {
        // Игнорируем такой поворот.
        return;
    }

    snake->direction = new_dir;
}

//------------------------------------------------------
// main
//------------------------------------------------------
int main()
{
    // Выделяем память под структуру змейки.
    snake_t* snake = (snake_t*) malloc(sizeof(snake_t));

    // Инициализируем змейку: хвост, начальные координаты, управление.
    // Голова стартует на высоте MIN_Y + 1, чтобы не пересекаться с текстом сверху.
    initSnake(snake, START_TAIL_SIZE, 10, MIN_Y + 1);

    // Инициализируем библиотеку ncurses (переключаем терминал в «режим игры»).
    initscr();
    keypad(stdscr, TRUE);   // включаем поддержку функциональных клавиш и стрелок
    raw();                  // отключаем буферизацию ввода (символ сразу попадает в программу)
    noecho();               // не отображаем введённые символы
    curs_set(FALSE);        // скрываем курсор

    // Строка-подсказка в верхней части экрана.
    mvprintw(0, 0, "Use arrows for control. Press 'F10' for EXIT");

    // Делаем getch() неблокирующим: если нет нажатой клавиши — он вернёт ERR сразу.
    timeout(0);

    int key_pressed = 0;    // код последней нажатой клавиши
    int game_over = 0;      // флаг окончания игры (столкновение с собой)

    const int TICK_MS = 150;       // «период» одного шага змейки в миллисекундах
    clock_t last_tick = clock();   // время последнего шага

    // Нарисуем голову один раз в начальной позиции.
    mvprintw(snake->y, snake->x, "@");
    refresh();

    // Основной игровой цикл: пока не нажата F10 и змейка не врезалась в себя.
    while (!game_over && key_pressed != STOP_GAME)
    {
        // Считываем нажатую клавишу (если нет — вернётся ERR).
        key_pressed = getch();

        // При необходимости изменяем направление движения.
        changeDirection(snake, key_pressed);

        // Текущее время.
        clock_t now = clock();
        // Прошедшее время в миллисекундах с последнего шага.
        double elapsed_ms = (double)(now - last_tick) * 1000.0 / CLOCKS_PER_SEC;

        // Проверяем, пришло ли время сделать следующий шаг.
        if (elapsed_ms >= TICK_MS)
        {
            last_tick = now;

            // Сохраняем координаты головы до её движения.
            int old_x = snake->x;
            int old_y = snake->y;

            // Сначала двигаем хвост в старую позицию головы.
            goTail(snake, old_x, old_y);

            // Затем двигаем голову в новое положение.
            go(snake);

            // Проверяем, не врезалась ли голова в хвост.
            if (isSelfCollision(snake))
                game_over = 1;

            // Обновляем экран после всех изменений.
            refresh();
        }
    }

    // Если игра завершена из-за столкновения — выводим "END!" с задержкой.
    if (game_over)
    {
        int max_x, max_y;
        getmaxyx(stdscr, max_y, max_x);

        const char *msg = "THE END!";
        // Выводим сообщение по центру экрана.
        mvprintw(max_y / 2, (max_x - (int)strlen(msg)) / 2, "%s", msg);
        refresh();

        // Задержка примерно 2 секунды через clock (без sleep()).
        clock_t start = clock();
        while ((double)(clock() - start) / CLOCKS_PER_SEC < 2)
        {
            // Пустой цикл ожидания.
        }
    }

    // Если игра завершена из-за столкновения — выводим "END!" с задержкой.
    if (key_pressed == STOP_GAME)
    {
        int max_x, max_y;
        getmaxyx(stdscr, max_y, max_x);

        const char *msg = "STOP_GAME!";
        // Выводим сообщение по центру экрана.
        mvprintw(max_y / 2, (max_x - (int)strlen(msg)) / 2, "%s", msg);
        refresh();

        // Задержка примерно 2 секунды через clock (без sleep()).
        clock_t start = clock();
        while ((double)(clock() - start) / CLOCKS_PER_SEC < 2)
        {
            // Пустой цикл ожидания.
        }
    }

    // Освобождаем память и возвращаем терминал в обычный режим.
    free(snake->tail);
    free(snake);
    endwin();

    return 0;
}