#include <stdio.h>   // подключаем стандартную библиотеку ввода-вывода (printf, scanf, getchar, putchar)

/*
 * Программа шифрует латинский текст шифром Цезаря.
 * На вход:
 *   - сначала целое неотрицательное число N (сдвиг),
 *   - затем последовательность символов (латинские буквы и пробелы),
 *     оканчивающаяся точкой '.'
 * Требуется:
 *   - пробелы вывести без изменений;
 *   - буквы 'a'..'z' сдвигать только внутри диапазона 'a'..'z';
 *   - буквы 'A'..'Z' сдвигать только внутри диапазона 'A'..'Z';
 *   - точку просто вывести и закончить.
 * Массивы использовать запрещено, поэтому обрабатываем текст посимвольно.
 */

int main(void) {
    int N;  // сдвиг шифра Цезаря (количество позиций, на которое сдвигаем буквы)

    // 1. Считываем сдвиг N
    //
    // scanf("%d", &N) пытается прочитать целое число из потока ввода.
    //  - "%d" означает "целое в десятичной форме"
    //  - &N — адрес переменной, куда поместить прочитанное значение
    //
    // Если scanf НЕ прочитал ровно одно значение (вернул не 1)
    // или если N < 0 (хотя по условию N неотрицательное, на всякий случай проверим),
    // то считаем, что ввод некорректен, и завершаем программу.
    if (scanf("%d", &N) != 1 || N < 0) {
        return 0;  // ошибка ввода — ничего не делаем, просто выходим
    }

    // 2. Нормализуем сдвиг N
    //
    // В алфавите 26 букв. Сдвиг на 26, 52, 78 и т.п. приводит к тому же результату,
    // что и сдвиг на 0.
    // Поэтому можно "уменьшить" N до диапазона 0..25 с помощью операции взятия остатка:
    //   N = N % 26;
    //
    // Это облегчает вычисления: (n + N) mod 26 будет корректным для любого исходного N.
    N = N % 26;

    int c;  // переменная для хранения очередного считываемого символа (как int, чтобы различать EOF)

    // 3. После чтения числа N во входном потоке обычно остаётся один символ-разделитель:
    //    либо пробел, либо перевод строки, либо табуляция.
    //
    //    Пример ввода:
    //      3 Hello world.
    //    После чтения "3" scanf оставляет в потоке символ ' ' (пробел).
    //
    //    Нам нужно перейти к следующему символу текста, поэтому мы один раз читаем getchar().
    //
    //    getchar() считывает один байт из stdin и возвращает его как int
    //    (или EOF, если конец файла).
    c = getchar();

    // Проверяем, что это за символ:
    if (c == '\n' || c == ' ' || c == '\t' || c == '\r') {
        // Если это пробел, перевод строки, табуляция или возврат каретки —
        // это нормальный разделитель, можно просто игнорировать и идти дальше.
        //
        // Ничего делать не нужно, следующий getchar в цикле уже прочитает
        // первый символ полезного текста.
    } else if (c != EOF) {
        // Если прочитали какой-то другой символ, отличный от EOF,
        // это означает, что формат ввода не совсем как мы ожидали
        // (например, "3Hello", без пробела).
        //
        // В такой ситуации можно было бы вернуть символ обратно во входной поток:
        //   ungetc(c, stdin);
        // чтобы он считался снова в основном цикле.
        //
        // Но в большинстве учебных задач формат строго определён,
        // поэтому обычно либо:
        //  - вход всё равно корректен и этот символ — начало текста,
        //    тогда мы просто продолжим чтение со следующего getchar();
        //  - либо это некорректный формат, про который условие задачи не говорит.
        //
        // Здесь мы ничего не делаем (просто оставляем как есть).
        ;
    }

    // 4. Основной цикл: читаем и шифруем текст посимвольно до точки.
    //
    // Цикл:
    //   while ((c = getchar()) != EOF) { ... }
    //
    // делает следующее:
    //   - читает следующий символ из stdin в переменную c;
    //   - если это EOF (конец файла/ввода), выходим из цикла;
    //   - иначе обрабатываем c внутри тела цикла.
    while ((c = getchar()) != EOF) {
        // 4.1. Если встретили точку '.', то:
        //   - выводим её как есть;
        //   - и завершаем цикл, т.к. по условию точка — конец сообщения.
        if (c == '.') {
            putchar('.');  // печатаем точку в выходной поток
            break;         // выходим из цикла (шифрование закончено)
        }
        // 4.2. Если символ — пробел, его не шифруем, а выводим как есть.
        else if (c == ' ') {
            putchar(' ');
        }
        // 4.3. Если символ — строчная латинская буква 'a'..'z'
        else if (c >= 'a' && c <= 'z') {
            // Преобразуем символ в номер в алфавите:
            //   'a' имеет код, например, 97
            //   'b' — 98
            //   ...
            //   'z' — 122
            //
            // Чтобы получить номер в диапазоне 0..25:
            //   n = c - 'a';
            // Пример: для 'a' => 97 - 97 = 0; для 'z' => 122 - 97 = 25.
            int n = c - 'a';      // номер буквы 0..25

            // Применяем шифр Цезаря:
            //   p = (n + N) mod 26
            // где:
            //   n — исходный номер буквы (0..25),
            //   N — сдвиг,
            //   26 — количество букв.
            int p = (n + N) % 26; // новый номер буквы после сдвига 0..25

            // Преобразуем номер обратно в символ:
            //   'a' + p
            // Пример: p = 0 => 'a' + 0 = 'a'
            //          p = 1 => 'a' + 1 = 'b'
            //          ...
            putchar('a' + p);
        }
        // 4.4. Если символ — заглавная латинская буква 'A'..'Z'
        else if (c >= 'A' && c <= 'Z') {
            // Аналогично для заглавных:
            // 'A'..'Z' также 26 букв, но в другом диапазоне кодов.
            int n = c - 'A';      // номер буквы 0..25
            int p = (n + N) % 26; // сдвигаем в пределах 0..25
            putchar('A' + p);     // превращаем номер в символ 'A'..'Z'
        }
        // 4.5. По условию задачи других символов быть не должно
        //      (разрешены только буквы и пробел, плюс завершающая точка).
        //      Но на всякий случай обработаем "прочие" символы.
        else {
            // Можно:
            //  - игнорировать такие символы;
            //  - или вывести как есть.
            //
            // Выводим как есть — так поведение будет более «гуманным».
            putchar(c);
        }
    }

    // 5. Завершаем программу
    return 0;
}
