/*
//------------------------------------------------------
//   Z-функция
//------------------------------------------------------ 
Поиск подстроки и смежные вопросы
Пусть дана строка s длины n.
Тогда Z-функция от этой строки — это массив длины n, i-ый элемент которого
равен наибольшему числу символов, начиная с позиции i, совпадающих с
первыми символами строки s.
Другими словами, z[i] — это наибольший общий префикс строки s и её i-го
суффикса.
Примечание: первый элемент массива z[0] обычно считают неопредёленным.
Будем считать его равным нулю, это никак не влияет на работу алгоритма.

Пример
1. s[] = “aaaaaˮ
i       0       1       2       3       4
s[i]    a       a       a       a       a
z[i]    0       4       3       2       1

2. s[] = “aaabaabˮ
i       0       1       2       3       4       5       6
s[i]    a       a       a       b       a       a       b
z[i]    0       2       1       0       2       1       0

3. s[] = “abacabaˮ
i       0       1       2       3       4       5       6
s[i]    a       b       a       c       a       b       a
z[i]    0       0       1       0       3       0       1

4. s[] = “aaaabaaˮ
i       0       1       2       3       4       5       6
s[i]    a       a       a       a       b       a       a
z[i]    0       3       2       1       0       2       1

Тривиальная реализация со сложностью O(n 2) будет выглядеть так:
*/
/*
Input text: AAAAB
Input word: AAAB
s = AAAB#AAAAB
find word in position 1
Input text: abcdbbbca
Input word: bc
s = bc#abcdbbbca
find word in position 2
find word in position 7
*/
#include <stdio.h>
#include <string.h>

#define SIZE 1000

/* Классическая реализация Z-функции (O(n)).
   Для строки s[0..n-1] массив z[i] показывает,
   сколько символов подряд совпадает с префиксом строки,
   начиная с позиции i:
     z[i] = длина наибольшего общего префикса s[0..] и s[i..].
*/
void zFunction(const char *s, int z[])
{
    int n = (int)strlen(s);
    z[0] = 0;          // по определению: для позиции 0 обычно ставят 0
    int l = 0, r = 0;  // [l, r] — текущий отрезок, где s[l..r] совпадает с префиксом

    for (int i = 1; i < n; ++i) {
        if (i <= r)
            // i попадает внутрь уже известного отрезка [l, r]:
            // берём минимум между:
            // - длиной остатка до r: (r - i + 1)
            // - уже посчитанным значением z[i - l]
            z[i] = (r - i + 1 < z[i - l]) ? (r - i + 1) : z[i - l];
        else
            // вне отрезка [l, r] — начинаем с нуля
            z[i] = 0;

        // Дорастим z[i], пока символы совпадают
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];

        // При необходимости расширяем отрезок [l, r]
        if (i + z[i] - 1 > r) {
            l = i;
            r = i + z[i] - 1;
        }
    }
}

int main(void)
{
    char t[SIZE] = {0};          // текст, в котором ищем
    char p[SIZE] = {0};          // шаблон (слово, которое ищем)
    char s[SIZE + SIZE] = {0};   // вспомогательная строка вида "p#t"
    int z[SIZE + SIZE] = {0};    // массив Z-значений для s

    printf("Input text: ");
    if (scanf("%999s", t) != 1)  // читаем текст, до 999 символов + '\0'
        return 0;

    printf("Input word: ");
    if (scanf("%999s", p) != 1)  // читаем шаблон
        return 0;

    int plen = (int)strlen(p);   // длина шаблона

    /* Формируем строку p#t.
       Символ '#' выбран как разделитель, предполагается,
       что он не встречается ни в p, ни в t. */
    sprintf(s, "%s#%s", p, t);
    printf("s = %s\n", s);

    /* Вычисляем Z-функцию для всей строки s */
    zFunction(s, z);

    /* Временный вывод всего Z-массива — удобно для отладки:
       можно видеть, где именно возникают совпадения с префиксом. */
    int n = (int)strlen(s);
    printf("Z: ");
    for (int i = 0; i < n; ++i)
        printf("%d ", z[i]);
    printf("\n");

    /* Поиск вхождений шаблона в текст.
       Структура строки s:
         s[0 .. plen-1] = p      (шаблон)
         s[plen]        = '#'    (разделитель)
         s[plen+1 .. ]  = t      (текст)

       Если z[i] == plen, значит, начиная с позиции i в s
       стоит подстрока, полностью совпадающая с p.
       Её позиция в тексте t:
         text_pos = i - (plen + 1)
       (plen + 1 — сдвиг от начала s до начала текста).
    */
    for (int i = plen + 1; i < n; ++i) {
        if (z[i] == plen) {
            int text_pos = i - (plen + 1);  // позиция в t, с нуля
            // Выводим с +1, то есть позиции считаются с 1
            printf("find word in position %d\n", text_pos + 1);
        }
    }

    printf("\n");
    return 0;
}
