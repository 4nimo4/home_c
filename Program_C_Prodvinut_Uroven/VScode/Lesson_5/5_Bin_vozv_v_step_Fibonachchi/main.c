/*
//------------------------------------------------------
//    Бинарное возведение в степень и Фибоначчи
//------------------------------------------------------ 
Идея: числа Фибоначчи можно получать через возведение матрицы
M = |0 1|
    |1 1|
в степень n:

M^n = |F(n-1)  F(n)  |
      |F(n)    F(n+1)|

Поэтому, чтобы получить F(n), достаточно быстро вычислить M^n
(бинарным возведением в степень) и посмотреть соответствующий элемент.
*/
#include <stdio.h>

enum { SIZE = 2 }; // работаем с 2x2 матрицами

// Функция умножает матрицу a на матрицу b и записывает результат в a.
// Параметры: a и b — квадратные матрицы размера SIZE x SIZE.
// Здесь реализовано стандартное O(SIZE^3) умножение матриц.
void mulMatr(int a[][SIZE], int b[][SIZE])
{
    // Временная матрица для накопления результата.
    // Инициализируем нулями.
    int res[SIZE][SIZE] = {{0}};

    // Тройной вложенный цикл — классическое умножение матриц:
    // res[i][j] = sum_k a[i][k] * b[k][j]
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            for (int k = 0; k < SIZE; k++)
            {
                res[i][j] += a[i][k] * b[k][j];
            }

    // Копируем результат обратно в a (тем самым a := a * b).
    for (int i = 0; i < SIZE; i++)
        for (int j = 0; j < SIZE; j++)
            a[i][j] = res[i][j];
}

/*
 * Быстрое (бинарное) возведение матрицы p в степень pow.
 * Метод: если степень нечетная, умножаем аккумулятор t на p,
 * затем квадратим p (p *= p) и делим степень на 2.
 *
 * Мы используем:
 *   t — аккумулятор результата, инициализирован единичной матрицей (I)
 *   p — базовая матрица, которую возводим в степень (в нашем случае — матрица Фибоначчи)
 *
 * После завершения t == p_original^pow.
 * Возвращаем t[1][0] == F(pow) (в силу свойства матрицы Фибоначчи).
 */
int fibMatr(int pow)
{
    // t = I (единичная матрица)
    int t[2][2] = { {1, 0}, {0, 1} };
    // p = M (матрица, дающая шаг Фибоначчи)
    int p[2][2] = { {0, 1}, {1, 1} };

    // спецслучай: если pow == 0, M^0 = I, и F(0) = 0, t[1][0] = 0
    // цикл выполняется, пока есть биты в степени pow
    while (pow > 0)
    {
        // если текущий младший бит степени == 1, умножаем аккумулятор на p
        if (pow % 2 == 1)
            mulMatr(t, p);

        // p = p * p  (переход к следующему биту степени)
        mulMatr(p, p);

        // делим степень пополам (сдвиг вправо)
        pow /= 2;
    }

    // В результате t = M^pow, и t[1][0] содержит F(pow)
    return t[1][0];
}

// Вспомогательная функция для печати матрицы (отладочная)
void printMatr(int a[][SIZE])
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
            printf("%4d", a[i][j]);
        printf("\n");
    }
}

int main(void)
{
    // Пример: F(10) == 55
    printf("%d\n", fibMatr(10));
    return 0;
}
/*
Краткие замечания и рекомендации:
Корректность:
Для pow = 0 функция возвращает t[1][0] == 0, что соответствует F(0) = 0.
Для pow > 0 возвращается F(pow).
Производительность:
Бинарное возведение требует O(log n) умножений матриц.
Умножение 2x2 матриц — константная (маленькая) стоимость, поэтому этот метод быстро 
вычисляет большие Fibonacci‑индексы.
Переполнение:
Используем тип int — достаточно лишь для небольших n. Fibonacci растёт экспоненциально, 
поэтому при сравнительно небольших n произойдёт переполнение int.
Для больших n используйте типы большего размера (long long, __int128) или библиотеку 
для больших целых (BigInt).
Оптимизация:
Для 2x2 матриц можно оптимизировать умножение вручную, развернув формулы, чтобы избежать 
лишних циклов и ускорить работу.
Также возможна реализация умножения и накопления с проверками переполнения.
Альтернатива:
Можно вычислять F(n) через быстрый дублирующий рекурсивный алгоритм 
(на основе формул Фаст-Дубль) или использовать формулу Бине (с вещественной арифметикой) 
— но матричный метод даёт целочисленную точность при адекватном типе.
*/