/*
//------------------------------------------------------
//    Биномиальные коэффициенты (Cn^k = "n choose k")
//------------------------------------------------------ 
Описание:
Cn^k (комбинации без учёта порядка) — это число способов выбрать k
элементов из n различных элементов без учёта порядка. Формула:
    C(n,k) = n! / (k! * (n-k)!)

В программе представлены три подхода:
1) cnk  — целочисленная реализация с сокращением факториалов (быстрая, но
            рискует переполнением промежуточных значений);
2) cnk2 — вычисление с помощью double (уменьшает риск переполнения, но неточно
            для очень больших n из‑за ограничений плавающей точки);
3) cnk3 — построение треугольника Паскаля (динамическая таблица, точна до
            переполнения типа и удобна, если нужен весь треугольник).
*/
#include <stdio.h>

/*
 * 1) Целочисленная реализация с сокращением факториалов.
 *
 * Идея:
 *   C(n,k) = (n-k+1) * (n-k+2) * ... * n   /   k!
 * Реализуем это: сначала перемножаем числитель, затем делим на 2..k.
 *
 * Преимущества:
 * - Простая реализация, относительно мало операций.
 *
 * Недостатки:
 * - Появляется риск переполнения переменной res при промежуточных умножениях,
 *   даже если конечный результат ещё помещается в тип int.
 * - Не обрабатывает случаи, когда k > n (надо проверять отдельно).
 */
int cnk(int n, int k)
{
    int res = 1;

    // Умножаем числа от (n-k+1) до n — это числитель дроби.
    for (int i = n - k + 1; i <= n; ++i)
        res *= i;

    // Делим на факториал k: 2 * 3 * ... * k
    for (int i = 2; i <= k; ++i)
        res /= i;

    return res;
}

/*
 * 2) Реализация через double.
 *
 * Идея:
 *   res = Π_{i=1..k} (n-k+i) / i
 * Это позволяет держать промежуточные значения в пределах плавающей точки,
 * избегая огромных целочисленных факториалов, которые быстро переполняют int.
 *
 * Преимущества:
 * - Меньше вероятность переполнения промежуточных величин по сравнению с cnk.
 *
 * Недостатки:
 * - Погрешности округления плавающей точки. Для очень больших n/k возможны
 *   ошибки округления. Приведение к int выполняется с небольшой коррекцией.
 */
int cnk2(int n, int k)
{
    double res = 1.0;
    for (int i = 1; i <= k; ++i)
        res = res * (n - k + i) / i;
    return (int)(res + 0.01); // небольшая поправка для защиты от ошибок округления
}

/*
 * 3) Треугольник Паскаля (динамическая таблица).
 * 
 * Например, C2^0=1, C6^2=15, C5^2=10.
 * 
 * 0                            1
 * 1                        1       1
 * 2'                  '1'      2       1
 * 3                1       3       3       1
 * 4            1       4       6       4       1
 * 5'       1       5      '10'     10      5       1
 * 6'   1       6      '15'     20      15      6       1
 * 
 * 
 * Связь:
 *   C(n,k) = C(n-1,k-1) + C(n-1,k)
 *   с граничными условиями C(n,0)=C(n,n)=1.

 *
 * Идея:
 * - Построить таблицу C[0..n][0..n] по рядам (Pascal triangle), используя
 *   рекуррентное соотношение. В таблице промежуточные значения никогда не
 *   превышают конечный ответ для данного n,k, поэтому это безопасно по логике
 *   операций (но может переполнить тип, если ответы очень большие).
 *
 * Преимущества:
 * - Простое и точное (в целых) вычисление всех сочетаний до n.
 * - Удобно, если нужно сразу много коэффициентов (весь треугольник).
 *
 * Недостатки:
 * - Память O(n^2) и время O(n^2), поэтому плохо для очень больших n.
 * - Возвращаемый тип int может переполниться для больших n.
 */
int cnk3(int n, int k)
{
    const int maxn = n;
    int C[maxn+1][maxn+1];

    // Построение треугольника Паскаля
    for (int i = 0; i <= maxn; ++i)
    {
        C[i][0] = 1;      // крайняя левая колонка — всегда 1
        C[i][i] = 1;      // диагональ — всегда 1
        for (int j = 1; j < i; ++j)
            C[i][j] = C[i-1][j-1] + C[i-1][j]; // рекуррентная формула
    }
    return C[n][k];
}

int main(void)
{
    int n, k;

    // Чтение входных значений.
    // В реальном коде стоит проверить, что ввод успешен и что 0 <= k <= n.
    if (scanf("%d%d", &n, &k) != 2) {
        fprintf(stderr, "Input error\n");
        return 1;
    }

    // Рекомендуется сначала нормализовать k: C(n,k) == C(n,n-k).
    // Это уменьшит количество операций и снизит риск переполнения.
    if (k < 0 || k > n) {
        printf("Invalid input: require 0 <= k <= n\n");
        return 1;
    }
    if (k > n - k) k = n - k; // симметрия

    printf("Введены числа n=%d k=%d\n", n, k);

    // Первая реализация (целочисленная)
    printf("Первая реализация (int) C(%d,%d) = %d\n", n, k, cnk(n, k));

    // Вторая реализация (double->int)
    printf("Вторая реализация (double) C(%d,%d) = %d\n", n, k, cnk2(n, k));

    // Третья реализация (треугольник Паскаля)
    printf("Третья реализация (Pascal) C(%d,%d) = %d\n", n, k, cnk3(n, k));

    return 0;
}

/*
 Рекомендации и замечания:
 - Валидация: обязательно проверяйте 0 <= k <= n перед вызовом функций.
 - Симметрия: используйте k = min(k, n-k), чтобы уменьшить число операций.
 - Типы: int может быть недостаточен для больших n; используйте long long,
   __int128 или библиотеки big integer (GMP) при необходимости.
 - Для больших n и одного значения C(n,k) эффективнее использовать итеративное
   умное деление на каждом шаге (делить на gcd числителя и знаменателя),
   чтобы предотвращать переполнение.
 - Для получения всех C(i,j) для i<=n используйте cnk3 (Pascal), но помните
   про O(n^2) по памяти и времени.
*/