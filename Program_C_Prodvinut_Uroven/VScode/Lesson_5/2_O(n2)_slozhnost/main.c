/*
//------------------------------------------------------
//    O(n2) сложность
//------------------------------------------------------ 
O(n2) сложность
В таких алгоритмах обычно два вложенных цикла, каждый из которых выполняет n
раз. Пример такого алгоритма — более медленные сортировка пузырьком
или сортировка вставками.
Еще один простой пример — поиск совпадающих элементов в массиве.

int arr[n] = {10,20,30,40,50,60,70,80,99,99};
_Bool hasduplicate = false;
for(size_t i=0; i<n ; i++)
    for(size_t j=0; j<n ; j++)
        if(i!=j && arr[i]==arr[j]) 
        {
            hasduplicate = true;
        }

O(2n) сложность
Такую сложность имеет рекурсивная реализация для вычисления чисел
Фибоначчи. Производительность функции удваивается для каждого элемента. Для
каждого числа происходит два вызова себя, пока число не станет равно единице.

int fibonacci(int number) 
{
    if (number <= 1) 
    {
        return number;
    } 
    else 
    {
        return fibonacci(number - 1) + fibonacci(number - 2);
    }
}

*/
//O(log2 n) сложность
#include <stdio.h>
#include <stdbool.h>  // определяет bool, true, false
#include <stddef.h>   // для size_t (обычно включается косвенно, но для явности)

int main(void)
{
    // Отсортированный массив с дубликатами (99 повторяется дважды)
    int arr[] = {10,20,30,40,50,60,70,80,99,99};

    // Количество элементов массива.
    // sizeof(arr) — общий размер в байтах, sizeof(arr[0]) — размер одного элемента.
    size_t n = sizeof(arr) / sizeof(arr[0]);

    // Булева переменная для флага наличия дубликатов.
    // bool/true/false доступны благодаря <stdbool.h>
    bool hasduplicate = false;

    // Счётчик сравнений (для оценки затрат)
    int counter = 0;

    // Наивный (O(n^2)) поиск дубликатов: сравниваем каждую пару элементов.
    // Используем два вложенных цикла по индексам i и j.
    for (size_t i = 0; i < n; i++)
    {
        for (size_t j = 0; j < n; j++)
        {
            // Пропускаем сравнение элемента с самим собой
            if (i != j && arr[i] == arr[j])
            {
                hasduplicate = true; // нашли хотя бы один дубликат
            }
            counter++;
        }
    }

    // Выводим результаты:
    // - n: количество элементов (size_t -> %zu)
    // - counter: количество произведённых сравнений
    // - hasduplicate: преобразуется к целому для вывода (%d)
    printf("n=%zu, counter=%d, hasduplicate=%d\n", n, counter, hasduplicate ? 1 : 0);

    return 0;
}