/*
//------------------------------------------------------
//   Хеш функция
//------------------------------------------------------ 
Хеш-функции – это функции, предназначенные для «сжатия» произвольного
сообщения в некоторую комбинацию фиксированной длины, называемую сверткой.
Рассмотрим пример «хорошей» и «плохой» хеш функции. Необходимо сделать хеш
функцию для телефонного номера.

«Плохой» вариант - Использовать первые три цифры.
«Хороший» вариант(возможно не самый) - Использовать последние три цифры.

Внимание! При неудачном алгоритме хэши разных данных могут совпадать
//------------------------------------------------------
//  Хеш функции строк
//------------------------------------------------------ 
Один из способов определить хэш-функцию от строки S:

h(S) = S[0] + S[1] * P^1 + S[2] * P^2 + S[3] * P^3 + ... + S[N] * P^N

P — некоторое простое число, которое примерно равно количеству
символов во входном алфавите.
Для маленьких букв латинского алфавита возьмем ближайшее простое
число P = 31

*/
#include <stdio.h>
#include <inttypes.h>

uint64_t getHash(char const *s) 
{
    const int p = 31;
    uint64_t hash = 0, p_pow = 1;
    while(*s) 
    { //отнимаем 'a' от кода буквы, единицу прибавляем, чтобы у строки вида 'aaaaa' 
      //хэш был ненулевой
        hash += (*s++ - 'a' + 1) * p_pow;
        p_pow *= p;
    }
    return hash;
}

int main(void)
{
    char s[100] = {0};
    //Hello.
    //18446744072292316236
    scanf("%s",s);
    printf("hash = %lu\n", getHash(s));

    return 0;
}

/*
вариант с коментариями

#include <stdio.h>
#include <inttypes.h>   // типы с фиксированной разрядностью (uint64_t) и макросы формата

// Простой полиномиальный хеш (rolling / polynomial hash).
//   Для строки s вычисляем:
//       hash = Σ_{i=0..len-1} (val(s[i]) * p^i)
//   где val(c) = c - 'a' + 1 (буквы 'a'..'z' дают 1..26),
//   p — простое основание (здесь 31).
//   Возвращаемое значение — 64-битное беззнаковое целое.
//   Такой хеш широко используется в алгоритмах поиска подстроки (Rabin-Karp),
//   а также для хеш-таблиц и быстрой индексации строк.

uint64_t getHash(char const *s)
{
    const int p = 31;         // основание (часто 31 или 53 для букв латиницы)
    uint64_t hash = 0;        // накопитель хеша
    uint64_t p_pow = 1;       // текущее значение p^i

    // Проходим по всем символам строки до '\0'
    while (*s)
    {
        // Вариант val: ('a' -> 1, 'b' -> 2, ...).
        // Отнимаем 'a' и добавляем 1, чтобы символ 'a' не давал нулевой вклад.
        // Если вход может содержать большие буквы или другие символы — нужно адаптировать val.
        hash += (uint64_t)(*s++ - 'a' + 1) * p_pow;

        // Обновляем p^i: p_pow *= p;
        p_pow *= p;

        // Замечание: оба накопления — hash и p_pow — происходят в uint64_t.
        // При длинных строк или большом p возможен wrap-around (переполнение по модулю 2^64).
        // Для многих практических задач это приемлемо (хеш по модулю 2^64), но нужно помнить
        // о коллизиях и о том, что арифметика выполняется по модулю 2^64.
    }
    return hash;
}

int main(void)
{
    char s[100] = {0};    // входная строка (макс 99 символов + '\0')

    // Примечание: scanf("%s", s) читает слово до пробельного символа.
    // Для безопасности лучше ограничить длину: scanf("%99s", s)
    // или использовать fgets для ввода целой строки.
    if (scanf("%99s", s) != 1) {
        fprintf(stderr, "Input error\n");
        return 1;
    }

    // Выводим хеш. Для uint64_t корректно использовать PRIu64 или %llu в зависимости от платформы.
    // Здесь используем %lu — это работает на многих платформах, но более портативно:
    // printf("hash = %" PRIu64 "\n", getHash(s));
    printf("hash = %" PRIu64 "\n", (uint64_t)getHash(s));

    return 0;
}
*/