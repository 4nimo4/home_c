/*
//------------------------------------------------------
//    Инфиксная нотация
//------------------------------------------------------ 
Алгоритм перевода из инфиксной записи в обратную польскую
(«сортировочная станция») был изобретён Э. Дейкстра.
Он использует свойство, по которому в обратной польской записи
меняется только порядок и место операций в выражении, и
отсортировывает операции в порядке выполнения действий.
Для реализации алгоритма нужны данные по приоритетам
операций.

Как вычислять автоматически:
(a + b)/(c + d -1)
Инфиксная запись, обход ЛКП (знак операции между операндами)
a + b / c + d - 1 (необходимы скобки!)
Префиксная запись, КПП (знак операции до операндов)
 / + a b - + c d 1 (Польская нотация Jan Lukasiewicz 1920) (скобки не нужны,
можно однозначно вычислить!)
Постфиксная запись, ЛПК (знак операции после операндов)
a b + c d + 1 - / (обратная польская нотация F.L.Bauer and E.W.Dijkstra)

//------------------------------------------------------
//    Алгоритм «сортировочная станция»
//------------------------------------------------------ 
В данном алгоритме под токеном подразумевается число, скобка или одна из
операций (+ - * /).
Вычислить выражение (3+5)*12-17*3

Шаг                 Цепочка             Стек           Вывод     
1                   (3+5)*12-17*3       (         
2                   3+5)*12-17*3        (               3
3                   +5)*12-17*3         ( +             3
4                   5)*12-17*3          ( +             3 5     
5                   )*12-17*3                           3 5 +
6                   *12-17*3            *               3 5 +
7                   12-17*3             *               3 5 + 12 *
8                   -17*3               -               3 5 + 12 *
9                   17*3                -               3 5 + 12 *17
10                  *3                  * -             3 5 + 12 *17
11                  3                   * -             3 5 + 12 *17 3
12                                                      3 5 + 12 *17 3 * -
//------------------------------------------------------
//    Обработка токенов
//------------------------------------------------------ 
Пока не все токены обработаны:
1. Прочитать токен
2. Если токен — число, то добавить его в очередь вывода
3. Если токен — оператор op1, то:
    a. Пока присутствует на вершине стека токен оператор op2, чей приоритет
        выше или равен приоритету op1
        i. Переложить op2 из стека в выходную очередь
    b. Положить op1 в стек
4. Если токен — открывающая скобка, то положить его в стек
5. Если токен — закрывающая скобка:
    a. Пока токен на вершине стека не открывающая скобка
    i. Переложить оператор из стека в выходную очередь.
    ii. Внимание! Если стек закончился до того, как был встречен токен-
        открывающая скобка, то в выражении пропущена скобка
    b. Выкинуть открывающую скобку из стека, но не добавлять в очередь
        вывода
6. Если больше не осталось токенов на входе:
    a. Пока есть токены операторы в стеке:
    i. Если токен оператор на вершине стека — открывающая скобка, то в
        выражении пропущена скобка
    ii. Переложить оператор из стека в выходную очередь
7. Конец
*/
#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE 255
#define STACK_SIZE 255

/*------------------------------------------------------------
  Преобразование инфиксного выражения в обратную польскую нотацию
  (Shunting-yard / алгоритм Дейкстры).
  Вход: строка в инфиксной форме (числа, + - * / и скобки).
  Выход: строка в постфиксной форме (операнды перед операторами), 
  разделённая пробелами, например:
    Infix:  (3 + 5) * 10 - 2 * 7
    Postfix: 3 5 + 10 * 2 7 * -
  Алгоритм использует стек операторов и очередь вывода (в нашем случае
  выход формируется в строке answer).
------------------------------------------------------------*/

/* Стек для операторов (символы: + - * / ( ) ) */
char oper[STACK_SIZE] = {0};
int oend = 0; // количество элементов в стеке (индекс вершины)

/* Отладочная функция: печать содержимого стека */
void printStack(void)
{
    for (int i = 0; i < oend; i++)
        printf("Stack: %c ", oper[i]);
    printf("\n");
}

/* Поместить символ в стек (push) */
void push(char v)
{
    if (oend >= STACK_SIZE) {             // защита от переполнения
        fprintf(stderr, "Stack overflow on push\n");
        exit(1);
    }
    oper[oend++] = v;
}

/* Снять символ со стека (pop) и вернуть его */
char pop(void)
{
    if (oend <= 0) {
        fprintf(stderr, "Stack underflow on pop\n");
        exit(1);
    }
    return oper[--oend];
}

/* Проверить пуст ли стек */
_Bool emptyStack(void)
{
    return oend == 0;
}

/* Является ли символ оператором (+ - * /) */
_Bool isOperator(char c)
{
    return c == '+' || c == '-' || c == '*' || c == '/';
}

/* Приоритет оператора: * и / выше (+ и -) */
int priority(char c)
{
    if (c == '+' || c == '-') return 1;
    if (c == '*' || c == '/') return 2;
    return 0; // для скобок или прочих символов
}

int main(void)
{
    char c;
    int pos = 0;                       // позиция вставки в строку ответа

    char answer[BUFFER_SIZE] = {0};    // выходная строка (postfix)
    /* Инициализация answer нулями (не строго нужна, но удобно) */
    for (int i = 0; i < BUFFER_SIZE; i++)
        answer[i] = 0;

    printf("Input infix string: ");     // пример ввода: ( 3 + 5 ) * 10 - 2 * 7
    char str[1000];
    int len = 0;

    /* Считываем всю строку до '\n' */
    while ((c = getchar()) != '\n' && c != EOF)
        str[len++] = c;
    str[len] = '\0';

    /* Проходим по входной строке посимвольно */
    for (int i = 0; i < len; i++)
    {
        // Если токен — цифра, читаем полное число (возможно многозначное)
        if (str[i] >= '0' && str[i] <= '9') 
        {
            int number = 0;
            int size = 0; // число цифр в числе
            // Собираем число (пропустит многозначные числа)
            for (; i < len && str[i] >= '0' && str[i] <= '9'; i++, size++) {
                number = number * 10 + (str[i] - '0');
            }
            // Записываем число в выходную очередь с пробелом
            pos += sprintf(answer + pos, "%d ", number);
            // цикл for сверху сделает i++ ещё раз, поэтому уменьшаем i, чтобы
            // корректно продолжить с следующего символа после числа.
            i--;
        }
        else
        {
            // Пропускаем пробелы и табуляции
            if (str[i] == ' ' || str[i] == '\t')
                continue;

            c = str[i];

            // Если токен — оператор op1
            if (isOperator(c))
            {
                // Пока в стеке есть оператор op2 с приоритетом >= приоритет оп1
                // (и op2 не является '('), переложить op2 в выходную очередь.
                while (!emptyStack()) {
                    char top = pop();
                    if (top == '(') {
                        // если встретили '(', вернуть его обратно и выйти
                        push(top);
                        break;
                    }
                    if (priority(top) >= priority(c)) {
                        pos += sprintf(answer + pos, "%c ", top);
                    } else {
                        // Если приоритет вершины стека меньше, вернуть её назад
                        push(top);
                        break;
                    }
                }
                // Затем положить текущий оператор op1 в стек
                push(c);
            }
            // Если токен — открывающая скобка
            else if (c == '(')
            {
                push(c);
            }
            // Если токен — закрывающая скобка, выписываем операторы до ближайшей '('
            else if (c == ')')
            {
                while (!emptyStack()) {
                    char top = pop();
                    if (top == '(') {
                        // нашли соответствующую '(', выходим из цикла
                        break;
                    }
                    // иначе — переносим оператор в очередь вывода
                    pos += sprintf(answer + pos, "%c ", top);
                }
            }
            else {
                // Неизвестный символ — можно сигнализировать или игнорировать
                fprintf(stderr, "Warning: unknown token '%c' ignored\n", c);
            }
        }
    }

    /* После обработки всех входных токенов: вытащить всё, что осталось в стеке */
    while (!emptyStack()) {
        char top = pop();
        if (top == '(' || top == ')') {
            fprintf(stderr, "Warning: mismatched parentheses\n");
            continue;
        }
        pos += sprintf(answer + pos, "%c ", top);
    }

    /* Вывести результат */
    printf("Answer: %s\n", answer);

    return 0;
}
/*
Дополнительные замечания и возможные улучшения:
Обработка пробелов: сейчас программа умеет читать числа и пропускать пробелы. 
Если вход может содержать негативные числа (с ведущим '-') или числа с плавающей запятой, 
парсинг нужно расширить.
Скобки: при несбалансированных скобках программа выдаст предупреждение. Можно добавить 
жёсткую валидацию.
Ограничения по размеру: буферы str[1000] и answer[BUFFER_SIZE]
имеют фиксированный размер. Для длинных выражений учтите переполнение строки answer
(проверять pos + n < BUFFER_SIZE).
Приоритеты: текущая реализация поддерживает только бинарные операторы + - * /
и стандартные приоритеты. Для дополнительных операторов (например ^, унарный -, функции) 
потребуются изменения.
Обработка ошибок: сейчас при переполнении или underflow стек вызывает exit. 
Можно возвращать ошибки вместо завершения.
Формат вывода: результат содержит пробел после последнего токена — это нормально, 
но можно убрать лишний пробел по желанию.
Производительность: алгоритм работает за O(n) по длине входа (каждый токен обрабатывается 
константное число раз).
*/