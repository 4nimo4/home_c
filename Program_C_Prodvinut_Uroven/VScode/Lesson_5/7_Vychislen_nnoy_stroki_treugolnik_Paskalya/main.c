/*
//------------------------------------------------------
//    Биномиальные коэффициенты - Вычисление n-ой строки треугольника Паскаля
//------------------------------------------------------ 
Задача: построить n-ю строку треугольника Паскаля (с индексами от 0 до n),
т.е. получить значения C(n,0), C(n,1), ..., C(n,n).

Идея:
- Треугольник Паскаля задаётся рекуррентно:
    C(i,0) = C(i,i) = 1
    C(i,j) = C(i-1,j-1) + C(i-1,j)  для 0 < j < i
- Чтобы сэкономить память, можно вычислять строки последовательно и хранить
  только текущую строку. При этом нужно обновлять элементы справа налево, чтобы
  не перезаписать значения, необходимые для вычисления следующего элемента.
Треугольник Паскаля (динамическая таблица).
 * 
 * Например, C2^0=1, C6^2=15, C5^2=10.
 * 
 * 0                            1
 * 1                        1       1
 * 2'                  '1'      2       1
 * 3                1       3       3       1
 * 4            1       4       6       4       1
 * 5'       1       5      '10'     10      5       1
 * 6'   1       6      '15'     20      15      6       1
*/
#include <stdio.h>

#define N 1000   // максимальная допустимая строка (максимальная длина массива c: N+1)

/*
  Алгоритм (вкратце):
  - Инициализируем массив c: c[0] = 1, остальные нули.
  - Для j = 1..n выполняем «построение» j-й строки по предыдущей:
      для i = j..1 (вниз) выполняем c[i] = c[i] + c[i-1]
    важный момент: обход справа налево (i = j..1). Это гарантирует, что
    при вычислении c[i] мы используем старое (не перезаписанное) значение c[i-1]
    из предыдущей итерации j-1.
  - После завершения циклов в массиве c будут лежать коэффициенты C(n,0)..C(n,n).
*/

int main(void)
{
    int c[N] = {0};   // массив для хранения коэффициентов текущей строки (достаточно размера n+1)
                      // инициализируется нулями; будем хранить в c[0..n]
    int n, i, j;

    // Считываем номер строки n (предполагается 0 <= n <= N)
    if (scanf("%d", &n) != 1) {
        fprintf(stderr, "Input error\n");
        return 1;
    }

    if (n < 0 || n > N) {
        fprintf(stderr, "n out of range (0..%d)\n", N);
        return 1;
    }

    c[0] = 1;  // 0-я строка: [1]. Приступаем к итерациям для получения следующих строк.

    // Для каждого j от 1 до n строим j-ю строку по предыдущей.
    // Обновляем элементы справа налево:
    // c[i] (новое) = c[i] (старое) + c[i-1] (старое)
    for (j = 1; j <= n; j++) {
        // i идёт от j до 1 — справа налево
        // пример: для j=3 обновим c[3], c[2], c[1]
        for (i = j; i >= 1; i--)
            c[i] = c[i] + c[i - 1];
        // после цикла c[0..j] представляет j-ю строку треугольника Паскаля
    }

    // Выводим полученную n-ю строку: c[0] .. c[n]
    for (i = 0; i <= n; i++)
        printf("%d ", c[i]);
    printf("\n");

    return 0;
}
/*
Дополнительные замечания:
Память: алгоритм использует O(n) памяти (массив c длины n+1), 
в отличие от O(n^2) при хранении всего треугольника.
Сложность: время O(n^2) — в сумме выполняется ~n(n+1)/2 операций сложения.
Переполнение: тип int ограничен. Для больших n значения C(n,k) очень быстро растут 
и могут вызвать переполнение int. Для больших n используйте типы большей разрядности 
(long long, __int128) или библиотеки для длинной арифметики.
Валидация ввода: добавил проверку диапазона n (0..N). Также можно обработать случаи 
негативных входных данных.
Порядок обновления справа налево обязателен: если обновлять слева направо, 
вы перезапишете c[i-1] и получите неверные значения.
*/