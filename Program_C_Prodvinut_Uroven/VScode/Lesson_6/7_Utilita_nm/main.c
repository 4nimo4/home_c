/*
//------------------------------------------------------
//  Исследуем исполняемый файл - prog Утилита nm и  Утилита ldd
//------------------------------------------------------ 
//      Утилита nm 
//------------------------------------------------------ 
Исполняемый файл содержит таблицу символов (её можно удалить с
помощью команды strip). В этой таблице хранится расположение функций
и переменных по имени, и её можно отобразить с помощью команды nm:

$ nm a.out
0000000000200db8 d _DYNAMIC
0000000000200fa8 d _GLOBAL_OFFSET_TABLE_
...
0000000000000768 T main
00000000000006f5 T print
U printf@@GLIBC_2.2.5
0000000000000670 t register_tm_clones

«T» во втором столбце указывает на функцию, определенную в объектном файле

Среди содержимого таблицы символов видно, что начало основной
функции имеет шестнадцатеричное смещение 0000000000000768.
Большинство символов предназначены для внутреннего
использования компилятором и операционной системой. «T» во
втором столбце указывает на функцию, определённую в объектном
файле, а «U» — на функцию, которая не определена (и должна быть
разрешена путём связывания с другим объектным файлом).
Чаще всего команда nm используется для проверки наличия в
библиотеке определения конкретной функции путём поиска записи «T»
во втором столбце напротив имени функции.

Исследуем исполняемый файл prog состоящий из двух объектных файлов
main.o и func.o.

$ nm -A *.o
function.o:0000000000000000 T fact
function.o:0000000000000004 C my_var
function.o:0000000000000000 D my_var2
main.o: U _GLOBAL_OFFSET_TABLE_
main.o: U __isoc99_scanf
main.o: U __stack_chk_fail
main.o: U fact
main.o:0000000000000000 T main
main.o: U printf

Обратите внимание на функцию fact, она была ее адрес был неизвестен до
этапа линковки.

$ nm -A prog
prog:0000000000200db8 d _DYNAMIC
prog:0000000000200fa8 d _GLOBAL_OFFSET_TABLE_
…
prog:000000000000075c T fact
prog:00000000000006f0 t frame_dummy
prog:00000000000006f5 T main
prog:
 U printf@@GLIBC_2.2.5
prog:0000000000000670 t register_tm_clones
//------------------------------------------------------ 
//      Утилита ldd
//------------------------------------------------------ 
Когда программа скомпилирована с использованием разделяемых библиотек, ей
необходимо динамически загружать эти библиотеки во время выполнения, чтобы вызывать
внешние функции. Команда ldd проверяет исполняемый файл и отображает список
необходимых ему разделяемых библиотек. Эти библиотеки называются зависимостями
разделяемых библиотек исполняемого файла.
Например, следующие команды демонстрируют, как найти зависимости разделяемых
библиотек программы Hello World:

$ gcc helloworld.c
$ ldd a.out
linux-vdso.so.1 (0x00007fff287ae000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6
(0x00007fa617432000)
/lib64/ld-linux-x86-64.so.2 (0x00007fa617a25000)

Программа Hello World зависит от библиотеки libc и библиотеки динамического загрузчика
ld-linux.
*/
#include <stdio.h>   

extern unsigned int fact(unsigned int);

int main(void)
{
    unsigned int n;
    scanf("%u",&n);
    printf("fact = %u\n",fact(n));

    return 0;
}