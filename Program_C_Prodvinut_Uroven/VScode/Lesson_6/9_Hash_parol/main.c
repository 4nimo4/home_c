/*
//------------------------------------------------------
//  Реверс-инжиниринг кода
//------------------------------------------------------ 
//     Более удачный пример
//------------------------------------------------------ 
Рассмотрим более удачный пример, в котором пароль не хранится в явном
виде, а хранится только его hash. В этом случае утилита strings не сработает,
т. к в исполняемом файле пароль не хранится в виде строки.

$ gcc -o prog main.c
$./prog
Input your password: secret
Access granted
$./prog
Input your password: test
Access denied
$ strings prog
Input your password:
Access granted
Access denied
//------------------------------------------------------ 
//    Утилита objdump с ключом -d
//------------------------------------------------------ 
Воспользуемся другой полезной утилитой objdump с ключом -d, которая
отобразит дизассемблированный код нашего файла. Нас интересует только
функция проверки пароля. Посмотрев на ассемблерный код, можно понять, в
каком месте происходит проверка, и внести изменения в бинарный файл.
Изменения должны быть минимальны, иначе придётся вручную рассчитывать
все сдвиги адресов, а это очень трудно. Поэтому мы изменим только одну
инструкцию JNE (jump if not equal ее код - 0F 85) — просто заменим её на
похожую: инструкцию JE(jump if equal ее код 0F 84). Логика проверки пароля
кардинально изменится, и можно будет ввести любой пароль, кроме
корректного.

В данном выводе нас интересует адрес смещения в файле, по которому надо
произвести замену: 00003e61. Для редактирования файла воспользуемся
консольным редактором vim с ключом -b, который откроет файл в бинарном
формате. Внутри редактора vim используем команду xxd для преобразования
файла в шестнадцатеричное представление.

$ vim -b prog
:%!xxd -g1
:/3E00
00003e00: 48 89 c1 48 81 c1 01 00 00 00 48 89 4d f8 0f be
 H..H......H.M...
00003e10: 10 83 ea 61 83 c2 01 48 63 c2 48 0f af 45 e0 48
 ...a...Hc.H..E.H
00003e20: 03 45 e8 48 89 45 e8 48 69 45 e0 1f 00 00 00 48
 .E.H.E.HiE.....H
00003e30: 89 45 e0 e9 b7 ff ff ff 48 8b 45 e8 5d c3 66 90
 .E......H.E.].f.
00003e40: 55 48 89 e5 48 83 ec 20 48 89 7d f0 48 c7 45 e8
 UH..H.. H.}.H.E.
00003e50: 90 9c 6f 22 48 8b 7d f0 e8 73 ff ff ff 48 3b 45
 ..o"H.}..s...H;E
00003e60: e8 0f 85 09 00 00 00 c6 45 ff 01 e9 04 00 00 00
 ........E.......
00003e70: c6 45 ff 00 8a 45 ff 24 01 0f b6 c0 48 83 c4 20
 .E...E.$....H..

 Отредактируем найденную строку заменив инструкцию 0f 85 (JNE - Jump if
Not Equal) на инструкцию 0f 84(JE - Jump if Equal) и сохраним файл. После
внесения изменений (в шестнадцатеричной части) вы можете вернуться к
тексту с помощью команды -r на xxd.

:%!xxd -r
:wq
Проверим, что всё верно сделали с помощью objdump:


$ objdump -d prog //с помощью этой команды получили ассемблерный код
                  //в нем находим функцию <checkPass>:

0000000000001210 <checkPass>:
    1210:       f3 0f 1e fa             endbr64
    1214:       55                      push   %rbp
    1215:       48 89 e5                mov    %rsp,%rbp
    1218:       48 83 ec 08             sub    $0x8,%rsp
    121c:       48 89 7d f8             mov    %rdi,-0x8(%rbp)
    1220:       48 8b 45 f8             mov    -0x8(%rbp),%rax
    1224:       48 89 c7                mov    %rax,%rdi
    1227:       e8 7d ff ff ff          call   11a9 <getHash>
    122c:       48 3d 90 9c 6f 22       cmp    $0x226f9c90,%rax

    1232:       75 07                   jne    123b <checkPass+0x2b>    //интересует эта строка

    1234:       b8 01 00 00 00          mov    $0x1,%eax
    1239:       eb 05                   jmp    1240 <checkPass+0x30>
    123b:       b8 00 00 00 00          mov    $0x0,%eax
    1240:       c9                      leave
    1241:       c3                      ret

далее открываем исполняемый файл в программе которая отображает бинарный код - у меня GHex
копируем 75 07 в поиск GHex 
находим эту строчку и меняем 75 на 74 ,сохраняем и повторно запускаем наш файл,
теперь в поле запроса пароля, водим что хотим, любой пароль становится валидным


*/
#include <stdio.h> 
#include<string.h>
#include<inttypes.h>

uint64_t getHash(char const *s) 
{
    const int p = 31;
    uint64_t hash = 0, p_pow = 1;
    while(*s) 
    {
        hash += (*s++ - 'a' + 1) * p_pow;
        p_pow *= p;
    }   
    return hash;
}

_Bool checkPass(char *p) 
{
    if(getHash(p) == 577739920)//это hesh пароля - secret
        return 1;
    return 0;
}

int main(void)
{
    char password[100];
    printf("Input your password: ");
    scanf("%s",password);
    if(checkPass(password))
        printf("Access granted\n");//пароль совпал
    else
        printf("Access denied\n");//пароль не совпал

    return 0;
}