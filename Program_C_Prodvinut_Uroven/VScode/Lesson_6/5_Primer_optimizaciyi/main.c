/*
//------------------------------------------------------
//  Пример оптимизации
//------------------------------------------------------ 
Рассмотрим пример, в котором реализована рекурсивная функция вычисления
факториала. Вынесем реализацию функции в отдельный файл и будем собирать
программу по частям.
//------------------------------------------------------
//  Соберём программу без ключей оптимизации
//------------------------------------------------------ 
$ gcc -c -o main.o main.c
$ gcc -c -o function.o function.c
$ gcc -o prog function.o main.o

//------------------------------------------------------
//  Утилита objdump
//------------------------------------------------------ 
используем вместо $ gcc -o prog function.o main.o,
утилиту objdump
Утилита objdump позволит отобразить файл function.o,
скомпилированный из файла function.c, в виде ассемблерных команд.

$ gcc -c -o main.o main.c
$ gcc -c -o function.o function.c
$ objdump -D function.o

function.o:     формат файла elf64-x86-64


Дизассемблирование раздела .text:

0000000000000000 <fact>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   89 7d fc                mov    %edi,-0x4(%rbp)
   f:   83 7d fc 00             cmpl   $0x0,-0x4(%rbp)
  13:   75 07                   jne    1c <fact+0x1c>
  15:   b8 01 00 00 00          mov    $0x1,%eax
  1a:   eb 11                   jmp    2d <fact+0x2d>
  1c:   8b 45 fc                mov    -0x4(%rbp),%eax
  1f:   83 e8 01                sub    $0x1,%eax
  22:   89 c7                   mov    %eax,%edi
  24:   e8 00 00 00 00          call   29 <fact+0x29>
  29:   0f af 45 fc             imul   -0x4(%rbp),%eax
  2d:   c9                      leave
  2e:   c3                      ret
//------------------------------------------------------
//  Используем ключ -О2
//------------------------------------------------------ 
Из кода видно, что в теле функции fact происходит рекурсивный вызов
самой себя (строка 2f). Компилятор построил данный код самым
примитивным образом — без оптимизации.
Соберём файл function.o, используя ключ -O2, который также
подразумевает замену хвостовой рекурсии на цикл.

$ gcc -c -o main.o main.c
$ gcc -c -o function.o function.c -O2
$ objdump -D function.o

Результат
Как видно из листинга, количество строк машинного кода сократилось до
18. Также отсутствует инструкция call.

function.o:     формат файла elf64-x86-64


Дизассемблирование раздела .text:

0000000000000000 <fact>:
   0:   f3 0f 1e fa             endbr64
   4:   b8 01 00 00 00          mov    $0x1,%eax
   9:   85 ff                   test   %edi,%edi
   b:   74 0b                   je     18 <fact+0x18>
   d:   0f 1f 00                nopl   (%rax)
  10:   0f af c7                imul   %edi,%eax
  13:   83 ef 01                sub    $0x1,%edi
  16:   75 f8                   jne    10 <fact+0x10>
  18:   c3                      ret

//------------------------------------------------------
//  Используем ключ -Оs
//------------------------------------------------------ 
Как видно из листинга, в файле function.o отсутствует инструкция call,
подразумевающая вызов функции. Однако стоит заметить, что сам
машинный код стал занимать гораздо больше места (69 строк против 391).
Пересоберём файл function.o с ключом -Os, который попросит
компилятор уменьшить размер исполняемого файла.

$ gcc -c -o main.o main.c
$ gcc -c -o function.o function.c -Os
$ objdump -d -M intel function.o

Результат
function.o:     формат файла elf64-x86-64


Дизассемблирование раздела .text:

0000000000000000 <fact>:
   0:   f3 0f 1e fa             endbr64
   4:   b8 01 00 00 00          mov    eax,0x1
   9:   85 ff                   test   edi,edi
   b:   74 07                   je     14 <fact+0x14>
   d:   0f af c7                imul   eax,edi
  10:   ff cf                   dec    edi
  12:   eb f5                   jmp    9 <fact+0x9>
  14:   c3                      ret
Как видно из листинга, количество строк машинного кода сократилось до
10. Также отсутствует инструкция call.

 можешь сделать так:

Собрать без оптимизации и с -Os в разные файлы:
gcc -c -o function_O0.o function.c          # без оптимизаций
gcc -c -o function_Os.o function.c -Os      # оптимизация по размеру
Посмотреть ассемблер:
objdump -d -M intel function_O0.o > asm_O0.txt
objdump -d -M intel function_Os.o > asm_Os.txt
Сравнить:
diff -u asm_O0.txt asm_Os.txt


*/
#include <stdio.h>   

extern unsigned int fact(unsigned int);

int main (void) 
{
    unsigned int n;
    scanf("%u",&n);
    printf ("fact = %d\n", fact (n ));
    
    return 0;
}