#include <stdio.h>
#include <stdint.h>
//#include <inttypes.h>



int main(void) 
{
    uint32_t a = 60;    /* 60 = 0011 1100 */
    uint32_t b = 13;/* 13 = 0000 1101 */
    int32_t c = 0;
    c = a & b;/* 12 = 0000 1100 */
    // Побитовый AND: сохраняются только биты, которые установлены в обоих операндах
    // 60 (0011 1100) AND 13 (0000 1101) = 0000 1100 -> 12
    printf("Line 1 c = %d\n", c );
    c = a | b;/* 61 = 0011 1101 */
    // Побитовый OR: устанавливаются биты, которые есть хотя бы в одном операнде
    // 60 (0011 1100) OR 13 (0000 1101) = 0011 1101 -> 61
    printf("Line 2 c = %d\n", c );
    c = a ^ b;/* 49 = 0011 0001 */
    // Побитовый XOR: устанавливаются биты, которые отличаются между операндами
    // 60 (0011 1100) XOR 13 (0000 1101) = 0011 0001 -> 49
    printf("Line 3 c = %d\n", c );
    c = ~a;/*-61 = 1100 0011 */
    // Побитово NOT (инверсия): меняются все биты, для 32-битного типа результат будет
    // представлять собой отрицательное число в доп. коде.
    // ~60 (0x0000003C) -> 0xFFFFFFC3 что в знаковом представлении int32_t равно -61
    printf("Line 4 c = %d\n", c );
    c = a << 2;/* 240 = 1111 0000 */
    //Это эквивалентно умножению на 4
    // Левый сдвиг: сдвиг всех битов влево на 2 позиции, вправо уходят старшие биты
    // 60 (0011 1100) << 2 = 1111 0000 -> 240
    printf("Line 5 c = %d\n", c );
    c = a >> 2;/* 15 = 0000 1111 */
    //Это эквивалентно делению на 4
    // Правый сдвиг: сдвиг вправо на 2 позиции
    // 60 (0011 1100) >> 2 = 0000 1111 -> 15
    printf("Line 6 c = %d\n", c );
    /*
    Комментарии о формате вывода: используется %d, потому что переменная 
    c объявлена как int32_t, и вывод в программе корректен; если планируете 
    печатать без переполнения на других платформах, можно оставить как есть 
    или использовать PRId32 из inttypes.h и форматную строку "%" PRId32.
    */

    return 0;
}