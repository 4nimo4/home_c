/*-------------------------------------------------------------------
 * A2.c
 * ------------------------------------------------------------------
 * Циклический сдвиг
 * ------------------------------------------------------------------
 * На вход программе подается беззнаковое 32-битное целое число N и 
 * натуральное число K (1 ≤ K ≤ 31). Требуется циклически сдвинуть биты 
 * числа N вправо на K битов и вывести полученное таким образом число.
 *
 * Циклический сдвиг вправо для 32-битного числа:
 * - обычный сдвиг вправо (N >> K) "выбрасывает" K младших битов,
 *   а слева дописывает нули;
 * - циклический сдвиг возвращает эти "выброшенные" биты в старшие разряды
 *   (влево в начало числа), сохраняя общее количество битов 32.
 *
 * Пример для 8-битного числа (для наглядности):
 *   N = abcdefgh (a — старший бит, h — младший бит)
 *   циклический сдвиг вправо на 2 бита:
 *   - обычный сдвиг:     N >> 2  = 00abcdef
 *   - потерянные биты gh переносим влево: gh000000
 *   - объединяем:        ghabcdef
 * ------------------------------------------------------------------
 * Формат входных данных
 * На стандартном потоке ввода:
 *   N K
 * где
 *   N — беззнаковое 32-битное целое (0 ≤ N ≤ 2^32 - 1),
 *   K — целое (1 ≤ K ≤ 31).
 * Числа могут разделяться пробелом, переводом строки и т.п.
 * ------------------------------------------------------------------	
 * Формат результата
 * На стандартный поток вывода:
 *   одно беззнаковое целое число — результат циклического сдвига N
 *   вправо на K битов.
 * ------------------------------------------------------------------
 */

#include <stdio.h>      // для scanf, printf
#include <inttypes.h>   // для uint32_t и макросов формата SCNu32

/*
 * Функция выполняет циклический (кольцевой) сдвиг ВПРАВО 32‑битного
 * беззнакового числа n на rotate битов.
 *
 * Параметры:
 *   n      — исходное 32-битное беззнаковое число;
 *   rotate — количество битов для сдвига вправо.
 *
 * Возвращает:
 *   число, полученное из n циклическим сдвигом вправо на rotate бит.
 */
uint32_t rightRotate(uint32_t n, int rotate)
{
    // Нормализуем количество сдвигов по модулю 32.
    // Любой сдвиг на 32, 64, 96, ... бит даёт исходное значение,
    // поэтому достаточно взять rotate по модулю 32.
    //
    // Операция:
    //   rotate &= 31u;
    // эквивалентна:
    //   rotate = rotate % 32;
    // но обычно быстрее, т.к. 31 (0b11111) — маска для младших 5 бит.
    rotate &= 31u;

    // Если нормализованный сдвиг равен нулю,
    // то результат — исходное число, сдвигать ничего не надо.
    if (rotate == 0)
        return n;

    // Циклический сдвиг вправо на rotate бит:
    //
    // (n >> rotate)       — обычный сдвиг вправо:
    //                       младшие rotate битов "выпадают",
    //                       слева дописываются нули.
    //
    // (n << (32 - rotate)) — переносим выпавшие младшие биты
    //                        в старшие разряды:
    //                        они "заходят" слева.
    //
    // Побитовое ИЛИ (|) объединяет обе части в одно 32-битное число.
    return (n >> rotate) | (n << (32u - rotate));
}

int main(void)
{
    uint32_t N; // число, которое будем циклически сдвигать
    uint32_t K; // величина сдвига вправо (по условию: 1 ≤ K ≤ 31)

    // Считываем N:
    //   %" SCNu32 — формат для беззнакового 32-битного целого (uint32_t),
    //   &N        — адрес переменной, куда записывается результат.
    //
    // Если прочитать число не удалось (scanf вернул не 1),
    // выводим сообщение об ошибке и завершаем программу с кодом 1.
    if (scanf("%" SCNu32, &N) != 1) 
    {
        printf("Input error\n");
        return 1;
    }

    // Считываем K таким же образом.
    if (scanf("%" SCNu32, &K) != 1) 
    {
        printf("Input error\n");
        return 1;
    }

    // Вызываем функцию циклического сдвига.
    // Здесь K может быть больше 31, но внутри rightRotate
    // оно нормализуется по модулю 32.
    uint32_t res = rightRotate(N, (int)K);

    // Выводим результат как беззнаковое целое число.
    // %u подходит для вывода uint32_t в большинстве реализаций.
    printf("%u\n", res);

    return 0;
}