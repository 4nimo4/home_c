//--------------------------------------------------------
//          Структуры с битовыми полями
//--------------------------------------------------------
/*              Проблематика
//--------------------------------------------------------
Предположим есть некоторое количество переменных, упакованных в
структуру для хранения значений True/False.
Такая структура будет занимать в памяти 8 байт, хотя на самом деле
использоваться будет только два бита для хранения 0 и 1.
//--------------------------------------------------------
// Определение структуры 
//--------------------------------------------------------
struct 
{
    uint32_t width;
    uint32_t height;
} st1;
//--------------------------------------------------------
//пример описания структуры с элементами разных типов
//--------------------------------------------------------
struct myStruct
{
    int mem1;
    unsigned long mem2;
    long *pmem3;

    void(*someFunc)();
} st1;
//--------------------------------------------------------
        Битовые поля
//--------------------------------------------------------
При использовании полей внутри структуры, можно задать их размер. Такая
структура будет занимать в памяти только 4 байта, но только 2 бита будет
фактически использовано. Можно разместить в ней до 32-ух однобитовых
полей, и это никак не скажется на размере выделенной для неё памяти.
//--------------------------------------------------------
// Определение структуры с битовыми полями
//--------------------------------------------------------
struct 
{
    uint32_t width : 1; 
    uint32_t height: 1;
} st2;
//--------------------------------------------------------
//1. Структура с битовыми полями
//--------------------------------------------------------
Пример:

struct Bits {
    unsigned a0 : 1;
    unsigned a1 : 1;
    unsigned a2 : 1;
    unsigned a3 : 1;
};

Использование:

struct Bits b;
b.a0 = 1;
b.a1 = 0;

if (b.a3) 
{
    ...
}

Плюсы:
Читаемость и удобство:
Обращение к отдельному биту как к полю:
    b.a3
Не нужно явно писать маски типа 0x08 и вспоминать, какой это бит.
Меньше ручной работы, не нужно самим делать >>, &, |
Компилятор сам формирует нужный код для установки/чтения битов.

Минусы:
Непереносимое расположение битов
Стандарт C не гарантирует, в каком порядке биты будут располагаться в памяти:
будет ли a0 младшим битом, а a3 старшим;
зависит от компилятора, архитектуры, настроек выравнивания.
То есть бинарный формат (как именно это лежит в памяти) 
может отличаться на разных платформах.
Зависимость от реализации

Вставка паддинга между полями, расположение в байтах/словах — на усмотрение компилятора.
Не годится для чётко определённых протоколов/регистров «байт-в-байт», если нужна 
абсолютная предсказуемость.
Ограниченный контроль
Сложнее делать «нестандартные» операции, например, сразу работать с несколькими 
битами как с группой (хотя можно использовать поля шириной 3–5 бит, но размещение 
опять же зависит от реализации).

//--------------------------------------------------------
//2. Маски и сдвиги (ручная работа с битами)
//--------------------------------------------------------
Пример: есть один байт:
uint8_t x = 0xAA; // 1010 1010₂
Чтение бита
Бит №1 (считая от 0 — младший):
uint8_t bit1 = (x >> 1) & 0x01; // 1
Установка бита
Включить бит №3:
x |= (1 << 3);
Сброс бита
Выключить бит №2:
x &= ~(1 << 2);

Плюсы
Полный контроль над положением битов

Вы сами определяете, что такое «бит 0», «бит 7» и как их трактовать.
Формат байта/слова однозначен и переносим между компиляторами/архитектурами 
(если оговорён порядок байтов).
Подходит для низкоуровневого программирования

Работа с регистрами микроконтроллеров.
Реализация сетевых протоколов, бинарных форматов.
Там, где «каждый бит на счету» и положение битов строго задано документацией.
Предсказуемый бинарный формат
Если в документации написано: «бит 0 — флаг A, бит 1 — флаг B» — вы точно 
сможете это реализовать.

Минусы
Менее читабельно
Код с масками сложнее понимать:
if (x & 0x08) ...
нужно помнить, что 0x08 — это бит 3.
Ручные ошибки
Легко перепутать маску, сдвиг, знак числа и т.п.

//--------------------------------------------------------
//3. Когда что лучше использовать?
//--------------------------------------------------------
//Использовать struct с битовыми полями, когда:
//--------------------------------------------------------
Важнее удобство и читабельность, чем точный бинарный формат.
Структура не используется для обмена данными «по проводу» или для точного 
соответствия аппаратному регистру.
Вы работаете в пределах одной платформы/компилятора, где поведение вам 
известно и устраивает.
Пример: внутреннее представление флагов в программе:
struct Flags {
    unsigned ready   : 1;
    unsigned error   : 1;
    unsigned busy    : 1;
    unsigned reserved: 5;
};
//--------------------------------------------------------
//Использовать маски и сдвиги, когда:
//--------------------------------------------------------
Нужно точное соответствие документации/железа:
регистры микроконтроллера,
сетевые пакеты,
файлы бинарных форматов.
Важно, чтобы код работал одинаково на любой платформе и компиляторе.
Нужно делать сложные битовые операции, объединять поля, применять маски 
к нескольким битам одновременно.
Пример — регистр устройства:
// бит 0 — ENABLE, бит 1 — RESET, бит 2 — MODE, биты 3–7 — DATA
#define REG_ENABLE (1 << 0)
#define REG_RESET  (1 << 1)
#define REG_MODE   (1 << 2)

uint8_t reg;

// включить устройство
reg |= REG_ENABLE;

// сбросить устройство
reg |= REG_RESET;

// прочитать MODE
uint8_t mode = (reg & REG_MODE) >> 2;

*/

#include <stdio.h>
#include <stdint.h>

int main(void) 
{
    // Объявляем объединение (union) Register.
    // Внутри него есть:
    // 1) структура с битовыми полями (по 1 биту на каждое поле a0..a7)
    // 2) целочисленное поле abyte шириной 8 бит.
    //
    // Важно: все поля union занимают одну и ту же область памяти.
    // То есть мы можем записать значение в abyte
    // и затем прочитать те же самые биты через поля структуры abit.

    //Вы используете объединение для удобного «двухвидового» доступа:
    union Register 
    {
        struct
        {
            // Битовые поля: каждое поле занимает ровно 1 бит в памяти.
            //Это удобно для обучения и отладки, но:
            //порядок соответствия a0 ↔ младший/старший бит abyte
            //формально не гарантирован стандартом;
            //на другой архитектуре может отличаться.!!!!!!!!!!!!!!!!!!!!!!!
            int a0   :1;  //— смотреть каждый бит по отдельности.
            int a1   :1;
            int a2   :1;
            int a3   :1;
            int a4   :1;
            int a5   :1;
            int a6   :1;
            int a7   :1;  // старший бит байта (как правило)
        } abit;           // имя структурного поля внутри union

        int abyte   :8;   //— смотреть/задавать все 8 бит сразу (как число).
    };

    // Объявляем переменную x типа union Register.
    union Register x;

    // Записываем в поле abyte шестнадцатеричное значение 0xAA.
    //
    // 0xAA в двоичной системе:
    // 0xA  = 1010₂
    // 0xAA = 1010 1010₂
    //
    // В битах (считая от младшего к старшему):
    // a0 = 0
    // a1 = 1
    // a2 = 0
    // a3 = 1
    // a4 = 0
    // a5 = 1
    // a6 = 0
    // a7 = 1
    x.abyte = 0xAA;

    // Печатаем значение целиком как шестнадцатеричное число.
    // Формат %x — вывод беззнакового целого в шестнадцатеричном виде.
    printf("\n %x ", x.abyte);  // Ожидаемый вывод: " aa " (может быть в нижнем регистре)

    // Далее мы поочерёдно проверяем каждый бит через битовые поля структуры abit.
    // Оператор ? : — тернарный оператор:
    // если условие истинно (не 0), печатаем "true", иначе "false".
    //
    // Для 0xAA (1010 1010₂) будет:
    // a0 = 0 → false
    // a1 = 1 → true
    // a2 = 0 → false
    // a3 = 1 → true
    // a4 = 0 → false
    // a5 = 1 → true
    // a6 = 0 → false
    // a7 = 1 → true

    printf(x.abit.a0 ? "\n true" :  "\n false");
    printf(x.abit.a1 ? "\n true" :  "\n false");
    printf(x.abit.a2 ? "\n true" :  "\n false");
    printf(x.abit.a3 ? "\n true" :  "\n false");
    printf(x.abit.a4 ? "\n true" :  "\n false");
    printf(x.abit.a5 ? "\n true" :  "\n false");
    printf(x.abit.a6 ? "\n true" :  "\n false");
    printf(x.abit.a7 ? "\n true" :  "\n false");

    // Программа завершилась успешно
    return 0;
}
//эквивалент вашего примера , только через маски и сдвиги. 
/*
#include <stdio.h>
#include <stdint.h>

int main(void)
{
    // Берём один байт, как раньше
    uint8_t abyte = 0xAA;   // 0xAA = 1010 1010₂

    // Печатаем всё число целиком
    printf("\n %x ", abyte);

    // Теперь вместо x.abit.a0..a7 будем читать биты через маски и сдвиги.
    //
    // Бит №0 (младший): (abyte >> 0) & 1
    // Бит №1:            (abyte >> 1) & 1
    // ...
    // Бит №7 (старший): (abyte >> 7) & 1

    printf( ( (abyte >> 0) & 1 ) ? "\n true" : "\n false" ); // a0
    printf( ( (abyte >> 1) & 1 ) ? "\n true" : "\n false" ); // a1
    printf( ( (abyte >> 2) & 1 ) ? "\n true" : "\n false" ); // a2
    printf( ( (abyte >> 3) & 1 ) ? "\n true" : "\n false" ); // a3
    printf( ( (abyte >> 4) & 1 ) ? "\n true" : "\n false" ); // a4
    printf( ( (abyte >> 5) & 1 ) ? "\n true" : "\n false" ); // a5
    printf( ( (abyte >> 6) & 1 ) ? "\n true" : "\n false" ); // a6
    printf( ( (abyte >> 7) & 1 ) ? "\n true" : "\n false" ); // a7

    return 0;
}
*/
//Вот тот же пример, но с использованием именованных масок для битов:
/*
#include <stdio.h>
#include <stdint.h>

// Определяем маски для каждого бита байта
#define BIT0 (1u << 0)  // 0000 0001 — маска с установленным только n-м битом.
//1 - тип int , 1u - unsigned int
//В выражении #define BIT0 (1u << 0) мы делаем сдвиг беззнакового значения. 
//Это даёт два эффекта-Избегаем проблем со знаковыми типами
//Если бы мы использовали знаковый int и большие сдвиги, могли бы попасть 
//на неопределённое поведение при сдвиге в область знакового бита и дальше.
//Логически правильно: маска — всегда беззнаковая
Битовые маски обычно трактуются как набор битов, а не как 
//положительное/отрицательное число, поэтому использовать unsigned — хорошая практика.
#define BIT1 (1u << 1)  // 0000 0010
#define BIT2 (1u << 2)  // 0000 0100
#define BIT3 (1u << 3)  // 0000 1000
#define BIT4 (1u << 4)  // 0001 0000
#define BIT5 (1u << 5)  // 0010 0000
#define BIT6 (1u << 6)  // 0100 0000
#define BIT7 (1u << 7)  // 1000 0000

int main(void)
{
    uint8_t abyte = 0xAA;   // 0xAA = 1010 1010₂

    printf("\n %x ", abyte);

    // Проверяем каждый бит с помощью масок.
    // (abyte & BITn) даёт ненулевое значение, если соответствующий бит = 1.

    printf( (abyte & BIT0) ? "\n true" : "\n false" ); // бит 0 - проверяет, установлен ли этот бит.
    printf( (abyte & BIT1) ? "\n true" : "\n false" ); // бит 1
    printf( (abyte & BIT2) ? "\n true" : "\n false" ); // бит 2
    printf( (abyte & BIT3) ? "\n true" : "\n false" ); // бит 3
    printf( (abyte & BIT4) ? "\n true" : "\n false" ); // бит 4
    printf( (abyte & BIT5) ? "\n true" : "\n false" ); // бит 5
    printf( (abyte & BIT6) ? "\n true" : "\n false" ); // бит 6
    printf( (abyte & BIT7) ? "\n true" : "\n false" ); // бит 7

    return 0;
}
*/