//--------------------------------------------------------
//   Поменять знак переменной x типа int на положительный
//   с помощью побитовых операций (получить |x|)
//--------------------------------------------------------

#include <stdio.h>
#include <inttypes.h>

int main()
{
    int32_t a, sign;

    // Считываем целое число (может быть положительным или отрицательным)
    scanf("%d", &a);

    // Сдвиг вправо на 31 бит для 32-битного int:
    // - если a >= 0, старший бит = 0 → sign = 0x00000000
    // - если a < 0,  старший бит = 1 → sign = 0xFFFFFFFF (при арифметическом сдвиге)
    //
    // То есть sign становится либо 0 (для неотрицательных чисел),
    // либо -1 (в двоичном виде все биты = 1) для отрицательных.
    sign = a >> 31; // записываем "маску знака"

    // Печатаем исходное число в шестнадцатеричном виде для наглядности
    printf("%x\n", a);

    // Побитовое XOR с маской sign:
    //
    // 1) Если a >= 0, sign = 0:
    //    a ^ 0 = a (число не меняется)
    //
    // 2) Если a < 0, sign = 0xFFFFFFFF:
    //    a ^ 0xFFFFFFFF = ~a (побитовое НЕ, инверсия всех битов)
    //
    // Для отрицательного a это первый шаг получения модуля:
    // |a| = (~a) + 1  (двухкомплементарный код).
    a = a ^ sign;
    printf("%x\n", a);

    // Завершающий шаг:
    //
    // sign & 0x1:
    //  - если a было >= 0, sign = 0 → (sign & 0x1) = 0
    //  - если a было < 0,  sign = 0xFFFFFFFF → (sign & 0x1) = 1
    //
    // Поэтому:
    //  - для исходно положительных/нулевых чисел к a добавляем 0
    //  - для исходно отрицательных — добавляем 1 и получаем |a|
    //
    // В сумме две операции:
    //   a = (a ^ sign) + (sign & 1)
    // дают абсолютное значение числа (модуль) без использования if.
    a = a + (sign & 0x1);

    // Печатаем результат как десятичное число
    printf("%d\n", a);

    return 0;
}
