#include <stdio.h>
#include <stdint.h>

// --------------------------------------------------------
//  Вывод 8‑битного ЗНАКОВОГО числа (int8_t) в двоичном виде
// --------------------------------------------------------
// Функция печатает РОВНО 8 бит представления числа x в two's complement.
// То есть мы видим реальные биты, как они лежат в памяти:
//   - для положительных чисел: обычный двоичный вид
//   - для отрицательных: дополнительный код (инверсия + 1)
void print_binary_int8(int8_t x)
{
    // ВАЖНО:
    // int8_t — знаковый тип. Если сдвигать его или маскировать напрямую,
    // можно попасть на особенности арифметического сдвига.
    //
    // Приведение к uint8_t НЕ меняет биты, а только тип:
    //   тот же набор бит теперь интерпретируется как беззнаковый.
    // Это удобно и безопасно для побитовых операций.
    uint8_t ux = (uint8_t)x;

    // Идём по битам от 7 до 0 (старший → младший)
    for (int i = 7; i >= 0; --i) {

        // (1u << i) — маска с единицей в позиции i:
        //   i = 7 → 1000 0000₂
        //   i = 6 → 0100 0000₂
        //   ...
        //   i = 0 → 0000 0001₂
        //
        // ux & (1u << i) проверяет, установлен ли i‑й бит:
        //   != 0 → бит = 1
        //   == 0 → бит = 0
        putchar( (ux & (1u << i)) ? '1' : '0' );

        // После битов 7..4 (когда i == 4) ставим пробел для наглядности:
        //   1111 1011
        if (i == 4)
            putchar(' ');
    }
}

int main(void)
{
    int8_t a = -5;  // в two's complement: 1111 1011
    int8_t b = 5;   //                    0000 0101

    printf("a = %d\n", a);
    printf("a (bin) = ");
    print_binary_int8(a);
    putchar('\n');

    printf("b = %d\n", b);
    printf("b (bin) = ");
    print_binary_int8(b);
    putchar('\n');

    return 0;
}