#include <stdio.h>
#include <stdint.h>

// --------------------------------------------------------
//  Вывод 16‑битного ЗНАКОВОГО числа (int16_t) в двоичном виде
// --------------------------------------------------------
// Функция печатает РОВНО 16 бит представления числа x в two's complement.
// Это те самые биты, которые реально хранятся в памяти:
//  - для положительных чисел — обычный двоичный код,
//  - для отрицательных — дополнительный код (инверсия + 1).
void print_binary_int16(int16_t x)
{
    // int16_t — ЗНАКОВЫЙ тип.
    // Чтобы безопасно работать с побитовыми операциями (&, <<),
    // приводим его к uint16_t.
    //
    // Приведение НЕ меняет биты, только трактовку:
    //   те же 16 бит теперь считаются беззнаковым числом.
    uint16_t ux = (uint16_t)x;

    // Идём по битам от 15 до 0 (для 16‑битного числа)
    // 15 — старший бит (бит знака), 0 — младший.
    for (int i = 15; i >= 0; --i) {

        // (1u << i) — маска с 1 в позиции i:
        //  i = 15 → 1000 0000 0000 0000₂
        //  i = 14 → 0100 0000 0000 0000₂
        //  ...
        //  i =  0 → 0000 0000 0000 0001₂
        //
        // ux & (1u << i) проверяет, установлен ли i‑й бит:
        //   != 0 → бит = 1
        //   == 0 → бит = 0
        putchar( (ux & (1u << i)) ? '1' : '0' );

        // Для удобства чтения вставляем пробел каждые 4 бита:
        // получаем вид: 1111 1111 1111 1011
        if (i % 4 == 0)
            putchar(' ');
    }
}

int main(void)
{
    int16_t a = -5;   // two's complement: 1111 1111 1111 1011
    int16_t b = 1234; // для примера положительное число

    printf("a = %d\n", a);
    printf("a (bin) = ");
    print_binary_int16(a);
    putchar('\n');

    printf("b = %d\n", b);
    printf("b (bin) = ");
    print_binary_int16(b);
    putchar('\n');

    return 0;
}