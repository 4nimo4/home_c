#include <stdio.h>
#include <stdint.h>

//--------------------------------------------------------
//  Вывод 32‑битного ЗНАКОВОГО числа (int32_t) в двоичном виде
//--------------------------------------------------------
// Функция печатает БИТОВОЕ представление int32_t (all 32 bits)
// в формате two's complement. Это полезно, чтобы увидеть, как
// выглядят в памяти и положительные, и отрицательные числа.
void print_binary_int32(int32_t x)
{
    // Важный момент:
    // int32_t — знаковый тип. Если прямо сдвигать его и маскировать,
    // можно попасть на особенности арифметического сдвига.
    //
    // Приведение к uint32_t:
    //   - НЕ меняет биты, только интерпретацию (знаковый → беззнаковый),
    //   - даёт нам безопасную работу с & и <<.
    uint32_t ux = (uint32_t)x;

    // Идём от старшего бита (31) к младшему (0)
    for (int i = 31; i >= 0; --i) {
        // 1u << i — маска с 1 в позиции i и нулями в остальных
        // ux & (1u << i) — проверка, установлен ли i‑й бит
        //
        // Если результат ненулевой → бит = 1, иначе → бит = 0.
        putchar( (ux & (1u << i)) ? '1' : '0' );

        // Для удобства чтения добавляем пробел после каждых 4 бит
        // Пример формата:
        // 1111 1111 1111 1111 1111 1111 1111 1011
        if (i % 4 == 0)
            putchar(' ');
    }
}

int main(void)
{
    int32_t a = -5; // отрицательное число
    int32_t b = 5;  // положительное число

    // Печатаем значение a в десятичном виде
    printf("a = %d\n", a);
    printf("a (bin) = ");
    // Печатаем БИТОВОЕ представление a (two's complement, 32 бита)
    print_binary_int32(a);
    putchar('\n');

    // То же самое для b
    printf("b = %d\n", b);
    printf("b (bin) = ");
    print_binary_int32(b);
    putchar('\n');

    return 0;
}