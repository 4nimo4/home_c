#ifndef BITPRINT_H
#define BITPRINT_H

#include <stdio.h>
#include <stdint.h>

// --------------------------------------------------------
//  Заголовочный файл bitprint.h
//  Набор маленьких функций для вывода целых типов в двоичном виде
//  (8, 16 и 32 бита; знаковые и беззнаковые варианты).
//
//  Все функции объявлены как static inline, чтобы:
//    - их можно было подключать из нескольких .c файлов без конфликтов имён;
//    - компилятор мог заинлайнить их (без лишнего оверхеда вызова функции).
// --------------------------------------------------------

// --------------------------------------------------------
//  Вывод uint8_t в двоичном виде (8 бит)
// --------------------------------------------------------
// Печатаем 8 бит числа x: от старшего (бит 7) к младшему (бит 0).
// Для наглядности: 4 бита, пробел, ещё 4 бита — например: 0011 1111
static inline void print_binary_uint8(uint8_t x)
{
    for (int i = 7; i >= 0; --i) {
        // (1u << i) — маска с единицей в позиции i.
        // x & маска → ненулевое, если соответствующий бит = 1.
        putchar( (x & (1u << i)) ? '1' : '0' );

        // Разделяем вывод на две группы по 4 бита: b7..b4 b3..b0
        if (i == 4) putchar(' ');
    }
}

// --------------------------------------------------------
//  Вывод int8_t в двоичном виде (8 бит, two's complement)
// --------------------------------------------------------
// Печатаем 8 бит представления знакового числа x в дополнительном коде.
// Приводим к uint8_t, чтобы безопасно работать с масками и сдвигами.
static inline void print_binary_int8(int8_t x)
{
    // Приведение не меняет биты, только тип (знаковый → беззнаковый).
    uint8_t ux = (uint8_t)x;

    for (int i = 7; i >= 0; --i) {
        putchar( (ux & (1u << i)) ? '1' : '0' );
        if (i == 4) putchar(' ');
    }
}

// --------------------------------------------------------
//  Вывод uint16_t в двоичном виде (16 бит)
// --------------------------------------------------------
// Печатаем 16 бит числа x: от бита 15 (старший) до бита 0 (младший).
// Для удобства чтения — пробел каждые 4 бита: 0000 0000 0110 1100
static inline void print_binary_uint16(uint16_t x)
{
    for (int i = 15; i >= 0; --i) {
        putchar( (x & (1u << i)) ? '1' : '0' );

        // Группируем в нибблы (по 4 бита): 4, 8, 12, 16…
        if (i % 4 == 0) putchar(' ');
    }
}

// --------------------------------------------------------
//  Вывод int16_t в двоичном виде (16 бит, two's complement)
// --------------------------------------------------------
// Печатаем 16 бит представления знакового числа x.
// Для побитовых операций приводим его к uint16_t.
static inline void print_binary_int16(int16_t x)
{
    uint16_t ux = (uint16_t)x;

    for (int i = 15; i >= 0; --i) {
        putchar( (ux & (1u << i)) ? '1' : '0' );
        if (i % 4 == 0) putchar(' ');
    }
}

// --------------------------------------------------------
//  Вывод uint32_t в двоичном виде (32 бита)
// --------------------------------------------------------
// Печатаем 32 бита числа x: от бита 31 до бита 0.
// Формат: группы по 4 бита, разделённые пробелом.
static inline void print_binary_uint32(uint32_t x)
{
    for (int i = 31; i >= 0; --i) {
        putchar( (x & (1u << i)) ? '1' : '0' );
        if (i % 4 == 0) putchar(' ');
    }
}

// --------------------------------------------------------
//  Вывод int32_t в двоичном виде (32 бита, two's complement)
// --------------------------------------------------------
// Печатаем 32 бита представления знакового числа x.
// Приведение к uint32_t сохраняет биты, меняя только знак типа.
static inline void print_binary_int32(int32_t x)
{
    uint32_t ux = (uint32_t)x;

    for (int i = 31; i >= 0; --i) {
        putchar( (ux & (1u << i)) ? '1' : '0' );
        if (i % 4 == 0) putchar(' ');
    }
}

#endif // BITPRINT_H