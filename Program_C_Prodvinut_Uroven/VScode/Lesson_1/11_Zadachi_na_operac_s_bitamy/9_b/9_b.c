//--------------------------------------------------------
//  Напишите функцию, которая осуществляет побитовый циклический
//  сдвиг влево целого беззнакового 32‑разрядного числа
//--------------------------------------------------------

#include <stdio.h>
#include <inttypes.h>

// Циклический (кольцевой) сдвиг влево 32‑битного числа n на rotate бит.
//
// Обычный сдвиг (n << k) отбрасывает старшие биты и дополняет
// справа нулями. ЦИКЛИЧЕСКИЙ сдвиг переносит "выпавшие" старшие биты
// в младшие разряды.
//
// Идея:
//   n = abcdefgh (для простоты 8 бит)
//   leftRotate(n, 2):
//     (n << 2)        -> cdefgh00
//     (n >> (8 - 2))  -> 000000ab
//     ИЛИ (|)         -> cdefghab
uint32_t leftRotate(uint32_t n, uint32_t rotate)
{
    // Нормализация количества сдвигов:
    //   сдвиг на 32, 64, 96 ... бит даёт то же самое число.
    // rotate & 31u == rotate % 32, но быстрее (31 = 0b11111).
    rotate &= 31u;

    // Если сдвиг на 0 бит — просто возвращаем исходное число.
    if (rotate == 0)
        return n;

    // (n << rotate)  — сдвигаем биты влево, выпавшие старшие биты теряются.
    // (n >> (32 - rotate)) — берём эти "выпавшие" старшие биты,
    //                        но уже сдвинутые вправо в младшие разряды.
    //
    // Побитовое ИЛИ (|) объединяет обе части в одно 32‑битное число.
    return (n << rotate) | (n >> (32u - rotate));
}

int main(void)
{
    uint32_t n; // число, которое будем сдвигать
    uint32_t r; // величина сдвига

    printf("Enter 32-bit unsigned integer (n): ");
    if (scanf("%" SCNu32, &n) != 1) { // SCNu32 — формат для uint32_t
        printf("Input error\n");
        return 1;
    }

    printf("Enter rotate count (0..31): ");
    if (scanf("%" SCNu32, &r) != 1) {
        printf("Input error\n");
        return 1;
    }

    uint32_t res = leftRotate(n, r);

    // Печатаем исходное число и результат в шестнадцатеричном виде
    // с ведущими нулями: 8 цифр (32 бита).
    printf("n       = 0x%08" PRIx32 "\n", n);
    printf("rotated = 0x%08" PRIx32 " (left rotate by %" PRIu32 ")\n", res, r);

    return 0;
}