//--------------------------------------------------------
//  Напишите функцию, которая осуществляет побитовый циклический
//  сдвиг вправо целого беззнакового 32‑разрядного числа
//--------------------------------------------------------

#include <stdio.h>
#include <inttypes.h>

// Циклический (кольцевой) сдвиг ВПРАВО 32‑битного числа n на rotate бит.
//
// Обычный сдвиг вправо (n >> k) отбрасывает младшие биты и дополняет
// слева нулями. ЦИКЛИЧЕСКИЙ сдвиг переносит "выпавшие" младшие биты
// в старшие разряды.
//
// Пример (для 8 бит):
//   n = abcdefgh
//   rightRotate(n, 2):
//     (n >> 2)       -> 00abcdef
//     (n << (8 - 2)) -> gh000000
//     ИЛИ (|)        -> ghabcdef
uint32_t rightRotate(uint32_t n, uint32_t rotate)
{
    // Нормализуем количество сдвигов по модулю 32:
    //  rotate & 31u == rotate % 32, но быстрее (31 = 0b11111).
    rotate &= 31u;

    if (rotate == 0)
        return n;   // сдвиг на 0 бит — число без изменений

    // (n >> rotate)        — обычный сдвиг вправо,
    //                         выпавшие младшие биты теряются.
    // (n << (32 - rotate)) — переносим эти выпавшие биты в старшие разряды.
    // Побитовое ИЛИ (|) объединяет обе части.
    return (n >> rotate) | (n << (32u - rotate));
}

int main(void)
{
    uint32_t n; // число, которое будем сдвигать
    uint32_t r; // величина сдвига

    printf("Enter 32-bit unsigned integer (n): ");
    if (scanf("%" SCNu32, &n) != 1) {
        printf("Input error\n");
        return 1;
    }

    printf("Enter rotate count (0..31): ");
    if (scanf("%" SCNu32, &r) != 1) {
        printf("Input error\n");
        return 1;
    }

    uint32_t res = rightRotate(n, r);

    // Печатаем исходное число и результат в шестнадцатеричном виде
    // с ведущими нулями (8 цифр = 32 бита).
    printf("n       = 0x%08" PRIx32 "\n", n);
    printf("rotated = 0x%08" PRIx32 " (right rotate by %" PRIu32 ")\n", res, r);

    return 0;
}