//--------------------------------------------------------
//         Обращения к указателю на структуру
//--------------------------------------------------------
/*
Для доступа к полям структуры по указателю 
используется оператор ->

Пример:
    struct Point A = {3,4};
    struct Point *ptrA = &A;
    ptrA->x = 5;  // то же, что и (*ptrA).x
    ptrA->y = 6;  // то же, что и (*ptrA).y

-----------------------------------------------------------
оператор стрелка ->
Пример:
    student1.group = 101;
    pst = &student1;
    printf("%d\n", pst->group);

----------------------------------------------------
оператор разыменования "*"
Пример:
    student1.group = 101;
    pst = &student1;
    printf("%d\n", (*pst).group);

//--------------------------------------------------------
//         Свойства структур
//--------------------------------------------------------
● При обращении к полю структуры по указателю на структуру можно
    использовать оператор ->
● ps->i эквивалентен (*ps).i;
● Структуры можно передавать в функции и возвращать из функций как
    по значению, так и по ссылке (по указателю).
● При передаче по значению происходит копирование всей структуры
    на стек.
  В случае, если структура занимает много места в памяти, то
  оптимально передавать в функцию её адрес (указатель), чтобы избежать
  лишнего расхода памяти.

//--------------------------------------------------------
// Особенности выделения памяти под структуру
//--------------------------------------------------------
Внимание! При описании структурного типа память не выделяется.
Выделение памяти происходит только после объявления переменных.

// Описание нового типа. Память не выделяется.
struct student
{
    int id;
    char name[20];
    int group;
};
// Описание переменной. Выделяется память под неё.
struct student st;

//-------------------------------------------------------------
// Пример описания структурного типа
//--------------------------------------------------------
Внимание! При описании структурного типа делать инициализацию нельзя!

// ТАК НЕЛЬЗЯ:

struct student
{
    char name[20] = "Ivan";
    int group = 104;
};

// Так можно:

struct student
{
    char name[20];
    int group;
};
struct student st = {"Ivan", 104};
*/

#include <stdio.h>
#include <inttypes.h>

// При объявлении структуры можно сделать так:
//
// Вариант 1
// Не указываем имя переменной структуры,
// при этом под описание структуры память НЕ выделяется:
//
//   struct student
//   {
//       int id;
//       char name[20];
//       int group;
//   };
//
// Вариант 2
// Вводим имя переменной и можем сразу присвоить ей значение,
// а можем сделать это позже в программе.
// При этом под переменную структуры память УЖЕ выделяется!

struct student
{
    int id;
    char name[20];
    int group;
} INT_STUDENT = {1, "Vasiliy", 102};  // глобальная переменная структуры

// Передача структуры по значению:
// В функцию передаётся КОПИЯ структуры record.
void func(struct student record)
{
    printf("func (by value):\n");
    printf(" Id is: %d \n", record.id);
    printf(" Name is: %s \n", record.name);
    printf(" Group is: %d \n\n", record.group);
}

// Передача структуры по указателю (по адресу):
// В функцию передаётся указатель, сама структура НЕ копируется.
void pfunc(struct student *record)
{
    printf("pfunc (by pointer):\n");
    // Доступ к полям структуры через указатель — через оператор ->
    printf(" Id is: %d \n", record->id);
    printf(" Name is: %s \n", record->name);
    printf(" Group is: %d \n\n", record->group);
}

int main(void)
{
    // Для Варианта 1 (когда struct student описана без переменной)
    // можно было бы написать:
    //   struct student record = {1, "Vasiliy", 102};
    //
    // Здесь (Вариант 2) мы используем уже инициализированную
    // глобальную переменную INT_STUDENT и копируем её в локальную:
    struct student record = INT_STUDENT;

    // Вызов с передачей по значению: record копируется
    func(record);

    // Вызов с передачей по указателю: передаём адрес record
    pfunc(&record);

    return 0;
}