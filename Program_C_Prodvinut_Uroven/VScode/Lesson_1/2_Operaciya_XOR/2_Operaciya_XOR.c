/*
//------------------------------------------------------
        Операция XOR - исключающее ИЛИ
//------------------------------------------------------
Операция “исключающее ИЛИ” - XOR
Операция исключающего ИЛИ — логическая операция при которой
результат равен 1, когда только один аргумент равен 1

● x ^ 1=~x (отрицание) - можно поморгать портом имкроконтроллера
● x ^ x= 0 (самообратимость)-если число xor-ить само с собой, то получим 0
● (x^y)^y=x (реверсивность)

        x       y       x ^ y
        0       0       0
        0       1       1
        1       0       1
        1       1       0

Побитовый оператор XOR — весьма полезный оператор, он используется во
многих задачах. Простым примером может быть следующая задача: дан
массив чисел, где все элементы встречаются четное количество раз, кроме
одного числа, найдите нечётное встречающееся число. Эту проблему
можно эффективно решить, просто выполнив операцию XOR для всех чисел.
//------------------------------------------------------
        Шифрование XOR

Шифровка:
        выполнить для каждого байта текста операцию XOR с
        байтом-шифромю
Расшифровка:
        сделать тоже самое с тем же шрифтом

        (X xor Y) xor Y = X
//------------------------------------------------------

//----------------------------------------------------------------------

//----------------------------------------------------------------------
*/
//Работает только когда в массиве есть только одно нечетное число!
/*
В программе используется XOR-операция (исключающее ИЛИ).
Свойство: A XOR A = 0 и A XOR 0 = A. Также операция ассоциативна и commutative.
Если в массиве встречаются числа по парам одинаковых значений, их XOR суммарно дают 0.
Осталось нечетное число, которое не имеет пары, и оно будет результатом XOR всех элементов.
*/
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

int find_odd_element(int32_t arr[], size_t n) 
{
        int32_t res = 0;
        for (size_t i = 0; i < n; i++)
        {
                res ^= arr[i]; // XOR очередного элемента с текущим результатом
        /*      
        Так как элементы парно встречаются, все пары "сократятся" до 0, и останется 
        единственный элемент-нечётное число, если в массиве ровно одно такое число. 
        Иначе результат будет непредсказуемым (не обязательно нечетное число).
        */
                printf("i = %ld res = %d\n", i, res);
        }
        
        return res;// res содержит единственный элемент, 
                   //который не имеет пары (если условие выполнено)
}

int main(void) 
{
        int32_t arr[] = { 17, 17, 24, 97, 24, 24, 24 }; //Инициализируем массив 
        size_t n = sizeof(arr) / sizeof(arr[0]); //Длинна массива это -
        //- количество элементов массива * на длиину одно элемента массива
        printf("The element is %" PRId32, find_odd_element(arr, n));
        return 0;
/*
        Вот как выглядит вывод этой программы!
i = 0 res = 17
i = 1 res = 0
i = 2 res = 24
i = 3 res = 121
i = 4 res = 97
i = 5 res = 121
i = 6 res = 97
The element is 97
*/
}