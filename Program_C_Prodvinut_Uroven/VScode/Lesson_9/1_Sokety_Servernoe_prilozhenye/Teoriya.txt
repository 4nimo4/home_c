1. Цель и постановка задачи
Цель работы — изучить основы сетевого взаимодействия по протоколу TCP 
в операционной системе Linux с использованием сокетов на языке C.

Разработано простое клиент–серверное приложение:

сервер:
создаёт TCP‑сокет;
привязывает его к локальному порту;
ожидает подключения клиента;
ведёт диалог с клиентом до получения команды завершения;

клиент:
создаёт TCP‑сокет;
подключается к серверу по адресу
127.0.0.1:1500;
обменивается с ним текстовыми сообщениями.
Обмен реализован в виде текстового диалога: стороны по очереди отправляют строки. 
Завершение соединения осуществляется по специальному символу # в начале строки.

2. Теоретические сведения о сокетах и TCP
Сокет — программный интерфейс для обмена данными между процессами, который абстрагирует сетевое соединение. 
В Unix‑подобных системах сокет представлен файловым дескриптором, поэтому с ним можно работать 
с помощью стандартных системных вызовов ввода‑вывода:
read / write или более специализированных send / recv.

В работе используются следующие параметры сокета:

домен (семейство адресов) — AF_INET (IPv4);
тип сокета — SOCK_STREAM (потоковый сокет, протокол TCP);
протокол — по умолчанию (TCP для SOCK_STREAM).
Общая схема установления TCP‑соединения:

Сервер:
создаёт сокет (socket);
привязывает сокет к IP‑адресу и порту (bind);
переводит сокет в режим прослушивания (listen);
ожидает входящих подключений (accept).

Клиент:
создаёт сокет (socket);
заполняет структуру с адресом сервера (sockaddr_in);
инициирует соединение с сервером (connect).
После успешных вызовов accept (на сервере) и connect (на клиенте) 
создаётся логический двусторонний канал. 
Оба конца соединения могут как отправлять, так и принимать данные.

3. Структура и логика работы сервера
Серверное приложение выполняет следующие шаги.

3.1. Создание серверного сокета
Используется системный вызов:

int server_fd = socket(AF_INET, SOCK_STREAM, 0);
AF_INET — IPv4;
SOCK_STREAM — потоковый сокет (TCP);
0 — протокол по умолчанию.
При ошибке socket возвращает отрицательное значение, 
в этом случае сервер завершает свою работу.

3.2. Настройка параметров сокета
Чтобы при частом перезапуске сервера избегать ошибки
Address already in use, используется опция SO_REUSEADDR:

int opt = 1;
setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
Это разрешает быстрое повторное использование порта после закрытия сокета.

3.3. Настройка адреса сервера
Сервер заполняет структуру sockaddr_in:

struct sockaddr_in server_addr;
memset(&server_addr, 0, sizeof(server_addr));
server_addr.sin_family      = AF_INET;
server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // слушать на всех интерфейсах
server_addr.sin_port        = htons(PORT);       // заданный порт (например, 1500)

Функции htons и htonl переводят числа из порядка байт машины в сетевой порядок байт 
(big-endian), как того требует сетевой протокол.

3.4. Привязка сокета к адресу и порту Вызов:

bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));
«привязывает» сокет к конкретной комбинации IP‑адреса и порта. 
После этого ядро направляет входящие соединения, адресованные этому порту, к данному сокету.

3.5. Перевод сокета в режим прослушивания
listen(server_fd, 1);
Сокет становится «слушающим» (passive socket) и готов принимать входящие подключения. 
Второй аргумент (backlog) задаёт максимальную длину очереди входящих соединений.

3.6. Ожидание подключения клиента
Сервер ожидает подключения:

int client_fd = accept(server_fd, (struct sockaddr *)&server_addr, &addrlen);

accept блокируется до тех пор, пока клиент не попытается подключиться к данному порту.
При успехе возвращает новый дескриптор client_fd , который используется для обмена данными с конкретным клиентом.
Старый дескриптор server_fd продолжает использоваться только для ожидания других подключений 
(в данной работе — одного клиента).

3.7. Основной цикл обмена данными
После успешного accept сервер входит в цикл:

сначала читает одну строку от клиента;
затем формирует и отправляет ответ.
Чтение сообщения от клиента выполняется вызовом:

ssize_t nbytes = recv(client_fd, buffer, BUF_SIZE - 1, 0);

если nbytes > 0 — прочитано nbytes байт данных;
если nbytes == 0 — клиент корректно закрыл соединение;
если nbytes < 0 — произошла ошибка.
Полученные данные завершаются нулевым байтом (buffer[nbytes]) = '\0';
, чтобы с ними можно было работать как со строкой C, после чего строка выводится на экран.

Для завершения диалога введён простой признак: 
если первым символом полученной строки является символ '#'
, сервер считает это командой завершения, выходит из цикла и закрывает соединение.

Формирование ответа сервера:

Строка считывается с клавиатуры через fgets.
Символ перевода строки '\n' в конце удаляется.
Ответ отправляется клиенту:
send(client_fd, buffer, strlen(buffer), 0);
Если ответ сервера начинается с '#' , сервер также завершает цикл и закрывает соединение.

3.8. Завершение работы сервера
По окончании цикла сервер закрывает оба сокета:

close(client_fd);
close(server_fd);
и завершает работу программы.

4. Структура и логика работы клиента
Клиентское приложение выполняет следующие шаги.

4.1. Создание клиентского сокета
Аналогично серверу:

int client_fd = socket(AF_INET, SOCK_STREAM, 0);
При ошибке клиент выводит сообщение и завершается.

4.2. Формирование адреса сервера
Клиент заполняет структуру sockaddr_in адресом сервера:

struct sockaddr_in server_addr;
memset(&server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port   = htons(PORT);  // тот же порт, что и у сервера
inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);
Используется IP‑адрес 127.0.0.1
(loopback), что означает, что сервер и клиент запущены на одной машине.
Функция inet_pton
преобразует строковый IP‑адрес в двоичное представление, подходящее для sin_addr
.
4.3. Установка соединения с сервером
Подключение выполняется вызовом:

connect(client_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));
Если connect завершился успешно, клиент и сервер установили TCP‑соединение.

4.4. Основной цикл обмена данными
Клиент работает в цикле до тех пор, пока не получит 
или не отправит команду завершения (# в начале строки).

Порядок действий внутри цикла:

Отправка сообщения серверу:

строка считывается с клавиатуры (fgets);
символ '\n' на конце удаляется;
строка отправляется серверу функцией send;
если первый символ — '#' , клиент выходит из цикла.

Ожидание ответа сервера:

вызывается recv для чтения ответа:
ssize_t nbytes = recv(client_fd, buffer, BUF_SIZE - 1, 0);
если nbytes > 0, строка завершается нулём и выводится;
если первый символ полученной строки — '#' , клиент так же завершает цикл;
если nbytes <= 0 — сервер разорвал соединение или произошла ошибка, цикл прерывается.

4.5. Завершение работы клиента
После выхода из основного цикла клиент закрывает сокет:

close(client_fd);
и завершает выполнение программы.

5. Простой протокол взаимодействия
В работе реализован очень простой текстовый протокол поверх TCP:

сообщения передаются в виде текстовых строк;
диалог носит поочерёдный характер:
клиент отправляет строку → сервер отвечает строкой → клиент снова отправляет и т.д.;
специальный управляющий символ:
строка, начинающаяся с '#' , интерпретируется как команда завершения соединения.
Такой подход удобен для учебных целей: он наглядно демонстрирует принципы работы с TCP‑сокетами 
и легко расширяется. Например, можно:
заменить '#' на текстовую команду "exit";
добавить разные типы сообщений (команды и данные), отличая их по первому слову строки;
реализовать протокол запрос–ответ с кодами операций.

6. Выводы
В ходе работы были:
Изучены базовые системные вызовы для работы с сетевыми сокетами в Linux:
socket, setsockopt, bind, listen, accept, connect, send, recv, close.

Реализован простой сервер, который:

создаёт TCP‑сокет и привязывает его к порту;
ждёт подключения клиента;
организует диалог с клиентом в режиме «одна строка туда, одна строка обратно»;
корректно завершает соединение по специальной команде.

Реализован клиент, который:
подключается к серверу по адресу 127.0.0.1:1500;
отправляет текстовые сообщения и получает ответы;
завершает работу по собственной или серверной команде завершения.

Отработаны практические навыки:
компиляция и запуск сетевых программ в Linux;
использование структур sockaddr_in и функций перевода байт (htons, htonl, inet_pton, inet_ntoa);
базовое проектирование текстовых протоколов поверх TCP.
Полученный пример может служить основой для дальнейшего развития: 
добавления поддержки нескольких клиентов, неблокирующего ввода, 
работы с потоками или использования механизмов select / poll
для обслуживания нескольких подключений одновременно.

7. Использование getchar вместо scanf для ввода строк
В начальном варианте программы ввод с клавиатуры выполнялся 
с помощью функции scanf("%s", buffer). Такой способ имеет несколько важных ограничений:

scanf("%s", ...) читает только до первого пробела.
Сообщение вида hello world будет прочитано как два отдельных слова:
сначала "hello" , затем — "world" . Это неудобно для текстового чата, 
где сообщения могут содержать пробелы.

scanf оставляет в потоке ввода символ новой строки '\n'.
Это легко приводит к «съеданию» ввода или к тому, что первый getchar() / fgets() читает пустую строку.

Обработка ошибок и переполнения буфера у scanf
менее наглядна: нужно аккуратно следить за форматом и длиной вводимых данных.

Для оптимизации ввода и возможности набирать сообщения целиком (до нажатия Enter) 
в работе был использован вариант на основе посимвольного ввода:

int cntr = 0;
int ch;
while ((ch = getchar()) != '\n' && ch != EOF && cntr < BUF_SIZE - 1) {
    buffer[cntr++] = (char)ch;
}
buffer[cntr] = '\0';
Преимущества такого подхода (аналогично fgets):

Вводится целая строка до Enter, включая пробелы и другие символы.
Прямой контроль длины вводимой строки через условие cntr < BUF_SIZE - 1,
что позволяет избежать переполнения буфера.
Поведение ввода становится более предсказуемым: 
одна строка из терминала = одно сообщение, которое затем целиком 
отправляется по сети через send.

Аналогичную задачу можно решать и с помощью функции
fgets(buffer, BUF_SIZE, stdin), 
которая читает строку целиком, включая пробелы и завершающий '\n'. 
Разница в том, что в случае getchar мы сами управляем накоплением символов в буфере, 
что наглядно показывает принцип работы с вводом посимвольно.

Таким образом, замена scanf("%s", ...) на ввод через getchar (или fgets) позволила:
вводить полноценные текстовые сообщения с пробелами;
сделать код более устойчивым к переполнению буфера;
упростить логику «одна строка ввода — одно сетевое сообщение».

