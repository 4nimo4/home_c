/*
//------------------------------------------------------
//    Оптимизация циклов
//------------------------------------------------------ 
Развёртывание циклов. Unrolling
Развертывание цикла используется для уменьшения количества инструкций
перехода, которые потенциально могут ускорить цикл, но это также может
увеличить размер двоичного файла.
for (size_t i = 0; i < 100; i++)
При развертывании цикла происходит уменьшение или исключение инструкций,
управляющих циклом, таких как:
● арифметические операции с указателями и операция проверки «конца цикла»
на каждой итерации;
● уменьшаются накладные расходы при условных переходах;
● сокращаются задержки, включая задержку чтения данных из памяти.

Развёрнутый цикл больше, чем «свернутая» версия, и поэтому может не помещаться 
в кэш инструкций (на машинах, на которых они есть). Это в итоге замедлит работу 
развёрнутой версии. Кроме того, в этом примере вызов func() затмевает стоимость 
цикла, поэтому любая экономия от развёртывания цикла незначительна по сравнению 
с тем, что вы могли бы получить от inline.

обычный цикл
for (size_t i = 0; i < 100; i++)    //program: 94 bytes, Cicle counter 80
{
    func(i);
} 

развернутый цикл
for (i = 0; i < 100; )              //program: 142 bytes, Cicle counter 50
{
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
    func(i); i++;
}

//------------------------------------------------------
//    Объединение циклов
//------------------------------------------------------ 
Идея состоит в том, чтобы объединить соседние циклы, которые работают в
одном и том же диапазоне с одной и той же переменной. Предполагая, что во
втором цикле нет использование следующих элементов (например, a[i + 3]):

Два цикла:
for (size_t i = 0; i < MAX; i++)        //program: 164 bytes
{
    for (j = 0; j < MAX; j++) 
    {
        a[i][j] = 0.0;
    }
}
for (size_t i = 0; i < MAX; i++)
{
    a[i][i] = 1.0;
}

Объединённый цикл:
for (i = 0; i < MAX; i++)               //program: 98 bytes
{
    for (j = 0; j < MAX; j++)
    {
        a[i][j] = 0.0;
    }   
    a[i][i] = 1.0;
}
*/

