/*
//------------------------------------------------------
//     inline-функции — альтернатива макросу
//------------------------------------------------------ 
В языке Си есть возможность объявлять встраиваемые (inline)
функции. При компиляции вызов такой функции может (но не обязан!)
быть заменён её телом — как у макроса, но с проверкой типов,
нормальной отладкой и т.п.
*/

#include <stdio.h>

// В стандартном C (особенно при -std=c99 и жёстких предупреждениях)
// объявление inline/обычных функций без прототипа и без static
// в том же файле может приводить к проблемам компоновки (linker error).
//
// Здесь показано, что простая неstatic‑функция без прототипа
// может вызывать ошибку линковки в вашей среде (в комментарии):
//
// int foo() // если без static то ошибка сборки
//
// Добавление static делает функцию "внутренней" для этого .c-файла
// (имеет внутреннюю компоновку — internal linkage), и проблема
// с линковкой снимается.

// static — функция видна только внутри данного модуля (файла).
// В дальнейшем её можно объявить как inline static, чтобы
// подсказать компилятору встраивать её.
static int foo() // если добавили static, то функция успешно компилируется и линкуется
{
    // Простая функция, возвращает константу 2
    return 2;
}

int main(void) 
{
    int ret;
    // Вызов функции foo: при обычной компиляции это может быть
    // реальный вызов (через стек), а при inline‑оптимизации
    // компилятор может подставить тело функции прямо сюда.
    ret = foo();

    printf("Result: %d\n", ret);

    return 0; // успешное завершение программы
}
//------------------------------------------------------
//Ниже пример, где рядом показаны три варианта: обычная функция,
//inline, static inline, и пояснения, в чём разница (на уровне одного .c‑файла).
//------------------------------------------------------ 
/*
//------------------------------------------------------
//     inline, static inline и обычные функции
//------------------------------------------------------ 
- Обычная функция:
    имеет внешнюю компоновку (external linkage) по умолчанию,
    может вызываться из других файлов (если есть прототип).

- inline:
    даёт компилятору "подсказку" — функцию желательно встраивать.
    Но при этом возникают особенности компоновки (нужно,
    чтобы была одна "настоящая" версия функции с external linkage).

- static inline:
    функция видна только в этом .c-файле (internal linkage),
    компилятор может её встраивать где захочет, проблем с линковкой
    не будет, так как она не экспортируется наружу.
*/
/*
#include <stdio.h>

/// 1. Обычная функция (без inline)
int square_normal(int x)
{
    return x * x;
}

/// 2. inline-функция с внешней компоновкой
/// В одном .c-файле это обычно не создаёт проблем.
/// Но если такое определение окажется в заголовочном файле,
/// подключённом в несколько .c-файлов, можно получить
/// дублирование определений на этапе линковки.
inline int square_inline(int x)
{
    return x * x;
}

/// 3. static inline — самый безопасный вариант для "маленьких"
/// функций, определённых в заголовках или в одном модуле.
/// - static: функция видна только в этом модуле
/// - inline: компилятор может подставить её тело вместо вызова
static inline int square_static_inline(int x)
{
    return x * x;
}

int main(void)
{
    int a = 5;

    int r1 = square_normal(a);          // обычный вызов функции
    int r2 = square_inline(a);          // может быть встроен компилятором
    int r3 = square_static_inline(a);   // почти всегда будет встроен (если оптимизации включены)

    printf("square_normal(%d)       = %d\n", a, r1);
    printf("square_inline(%d)       = %d\n", a, r2);
    printf("square_static_inline(%d)= %d\n", a, r3);

    return 0;
}
    */