/*
//------------------------------------------------------ 
// Вычисление интеграла методом трапеций
//------------------------------------------------------
В отличие от метода прямоугольника, интеграл в данном методе
разбивается на трапеции. Т.к замена происходит на элементарную
линейную функцию, площадь вычисляется точнее.

Площадь трапеции вычисляется по формуле:

SQUARE = (a + b)/2 * h , где a и b — основания, а h — высота трапеции.

Составная формула для вычисления интеграла будет выглядеть:

   xr       xr
   ∫  f(x) ≈ ∑   (f(xi) + f(xi+1))/2 * (xi+1 - xi)
  xl        i=xl

Если сетка достаточно велика, то высотой можно пренебречь.
*/

#include <stdio.h>    // стандартный ввод-вывод (printf и др.)
#include <math.h>     // математические функции (здесь фактически не используются напрямую)

#define ACCURACY 1000 // Количество разбиений интервала (n) — влияет на точность интеграла

typedef float(*function)(float);
// Тип function — указатель на функцию вида float f(float)


//------------------------------------------------------ 
// Интегрируемая функция f(x)
// f(x) = 8x^4 + 32x^3 + 40x^2 + 16x + 1
// В комментариях выше упомянуты интервалы (-2, -1.5), (-1.5, -1), ...
// Здесь эта функция используется для вычисления интегралов на заданном отрезке.
//------------------------------------------------------
float f(float x) 
{
    return 8*x*x*x*x + 32*x*x*x + 40*x*x + 16*x + 1;
}

//------------------------------------------------------ 
// Тестовая функция для проверки метода интегрирования.
// testf(x) = 2 (постоянная функция).
// Интеграл от 2 по [0, 2] равен 4 — это площадь прямоугольника 2×2.
//------------------------------------------------------
float testf(float x)
{
    return 2;
}

//------------------------------------------------------ 
// Вычисление определённого интеграла методом прямоугольников
// (метод левых прямоугольников).
//
// xl, xr — левый и правый пределы интегрирования
// n      — количество разбиений (число прямоугольников)
// f      — функция, которую интегрируем
//
// Алгоритм:
// 1) Разбиваем [xl, xr] на n отрезков длиной h.
// 2) В каждой подточке берём значение f(x) в левой границе
//    и считаем площадь прямоугольника: f(x_i) * h.
// 3) Складываем все площади.
//------------------------------------------------------
float calcIntegralSquare(float xl, float xr, size_t n, function f) 
{
    float sum = 0.0f;          // сумма значений f(x) по узлам
    float h = (xr - xl) / n;   // ширина одного прямоугольника

    for (size_t i = 0; i < n; i++) 
    {
        sum += f(xl);  // высота прямоугольника в левой точке текущего подотрезка
        xl += h;       // переходим к следующему подотрезку
    }

    return sum * h;    // итоговый интеграл ≈ сумма высот * ширина
}

//------------------------------------------------------ 
// Вычисление определённого интеграла методом трапеций.
//
// xl, xr — левый и правый пределы интегрирования
// n      — количество трапеций
// f      — функция, которую интегрируем
//
// Идея: каждый маленький отрезок длиной h аппроксимируем трапецией
// с основаниями f(x) и f(x+h). Площадь трапеции: (f(x) + f(x+h)) / 2 * h.
//------------------------------------------------------
float calcIntegralTrap(float xl, float xr, size_t n, function f) 
{
    float sum = 0.0f;
    float h = (xr - xl) / n;   // длина одного шага

    // Здесь цикл идёт от xl + h до xr - h,
    // то есть рассматриваются внутренние трапеции.
    for (float x = xl + h; x < xr - h; x += h) 
    {
        sum += 0.5f * h * (f(x) + f(x + h)); // площадь одной трапеции
    }

    return sum; // суммарная площадь всех трапеций
}

int main(void) 
{
    // 1. Тест: интеграл от testf(x) = 2 на [0, 2].
    // Ожидаемый результат: 4 (площадь прямоугольника 2×2).
    printf("calcIntegralSquare integral %f\n",
           calcIntegralSquare(0, 2, ACCURACY, testf));
    // calcIntegralSquare integral 4.000000

    /*
        Тестовая функция:

        float testf(float x)
        {
            return 2;
        }

        Даёт интеграл 4 на отрезке [0, 2].
    */

    // 2. Интеграл функции f(x) на отрезке [-1.382683, -0.617316].
    // В комментарии сказано, что это площадь половины "лепестка синусоиды"
    // выше оси Ox — т.е. положительная площадь под графиком f(x).
    printf("calcIntegralSquare = %f\n",
           calcIntegralSquare(-1.382683, -0.617316, ACCURACY, f));
    // Пример: calcIntegralSquare = 0.492744

    // 3. Тот же интеграл методом трапеций.
    printf("calcIntegralTrap = %f\n",
           calcIntegralTrap(-1.382683, -0.617316, ACCURACY, f));
    // Пример: calcIntegralTrap = 0.492743 (очень близко к результату прямоугольников)

    return 0;
}