/*
//------------------------------------------------------ 
// Комбинированный метод
//------------------------------------------------------
Идея
Методы хорд и касательных дают приближения корня с разных сторон.
Комбинированный метод сочетает в себе принципы метода хорд и метода
касательных, и позволяет решать нелинейные уравнения y(x)=0 с заданной
точностью ε.
Приближение к искомому корню происходит одновременно с двух сторон
отрезка, на котором отделен корень уравнения.
В данном методе один из концов отрезка не является закрепленным.
Для построения хорды используются значения приближений, полученные с
помощью метода касательных на предыдущей итерации.

Если f(xl)*f’’(xl) < 0, то проводим хорду:

Xl = Xl - (f(Xl) * (Xl - Xr)) / (f(Xl) - f(Xr))

иначе касательную

Xl = Xl - f(Xl) / (f'(Xl)
Xr = Xr - f(Xr) / (f'(Xr)

Суть комбинированного метода заключается в разбиении отрезка [a; b] (при
условии f(a)f(b) < 0) на три отрезка с помощью хорды и касательной и выборе
нового отрезка от точки пересечения хорды с осью абсцисс до точки
пересечения касательной с осью абсцисс, на котором функция меняет знак и
содержит решение.
● Построение хорд и касательных продолжается до достижения
необходимой точности решения ε.
● Условие начальной точки для метода хорд: f(x)fʼʼ(x) < 0.
● Условие начальной точки для метода касательных: f(x)fʼʼ(x) > 0.

Сначала находим такой отрезок [a; b], что функция f(x) дважды непрерывно
дифференцируема и меняет знак на отрезке, то есть f(a)f(b) < 0.
Для реализации этого метода потребуется вычислить вторую производную
для функции. В нашем примере:
f(x) = 8x^4 + 32x^3 + 40x^2 + 16x + 1
fʼ(x) = 32x^3 + 96x^2 + 80x+16
fʼʼ(x) = 96x^2 + 192x+80

*/

#include <stdio.h>    // стандартный ввод-вывод (printf и др.)
#include <math.h>     // математические функции: fabs, и т.п.

#define ACCURACY 0.001 // Точность для большинства методов (ε по x)
#define EPS 0.0001     // Отдельная точность для комбинированного метода

typedef float(*function)(float); 
// Тип "function" — указатель на функцию вида float f(float)


//(-2, -1.5) (-1.5, -1) (-1, -0.5) (-0.5, 0)
//------------------------------------------------------
// Целевая функция f(x), корни которой ищем
//------------------------------------------------------
float f(float x) 
{
    return 8*x*x*x*x + 32*x*x*x + 40*x*x + 16*x + 1;
}

//------------------------------------------------------
// Функция знака для f(x):
//  0  — если f(x) == 0
// -1  — если f(x) < 0
// +1  — если f(x) > 0
// Используется в методах деления отрезка пополам
//------------------------------------------------------
int signF(float x, function f)
{
    return f(x) == 0 ? 0 : (f(x) < 0 ? -1 : +1);
}

//------------------------------------------------------
// Первая производная f'(x) — для метода Ньютона
// f(x)  = 8x^4 + 32x^3 + 40x^2 + 16x + 1
// f'(x) = 32x^3 + 96x^2 + 80x + 16
//------------------------------------------------------
float df(float x)
{
    return 32*x*x*x + 96*x*x + 80*x + 16;
}

//------------------------------------------------------
// Вторая производная f''(x) — для комбинированного метода
// f'(x)  = 32x^3 + 96x^2 + 80x + 16
// f''(x) = 96x^2 + 192x + 80
//------------------------------------------------------
float ddf(float x) 
{
    return 96*x*x + 192*x + 80;
}
//------------------------------------------------------ 


//------------------------------------------------------ 
// Линейный поиск (грубый перебор точек на отрезке)
//------------------------------------------------------
float rootFindLineSearch(float xl, float xr, float eps, function f) 
{
    float x;
    float minx = xl;       // текущая лучшая точка (минимальный |f|)
    float nextstep;

    // Длину интервала делим примерно на (1/eps) шагов.
    // Например, eps=0.001 → ~1000 шагов.
    nextstep = fabs(xr - xl) / (1 / eps);

    int stepcount = 0;     // счётчик шагов

    // Проходим по отрезку [xl, xr) с шагом nextstep
    for (x = xl; x < xr; x += nextstep, stepcount++) 
    {
        // Если в новой точке |f(x)| меньше, чем в лучшей найденной —
        // обновляем minx
        if (fabs(f(x)) < fabs(f(minx)))
            minx = x;
    }

    printf("\nFind root for %d steps\n", stepcount); // статистика
    return minx;  // точка, где |f(x)| минимально на интервале
}

//------------------------------------------------------ 
// Метод деления отрезка пополам (бисекция)
//------------------------------------------------------
float rootFindDiv(float xl, float xr, float eps, function f) 
{
    int stepcount = 0; // число шагов
    float xm;          // середина отрезка

    // Пока длина отрезка больше требуемой точности
    while (fabs(xr - xl) > eps) 
    { 
        stepcount++;
        xm = (xl + xr) / 2.0f; // середина интервала

        // Если знаки f(x) на xl и xm различны —
        // корень лежит в левом подотрезке [xl, xm]
        if (signF(xl, f) != signF(xm, f))
            xr = xm;
        else
            // иначе — в правом [xm, xr]
            xl = xm;
    }

    printf("Find root for %d steps\n", stepcount); // статистика
    return (xl + xr) / 2.0f;  // середина финального маленького интервала
} 

//------------------------------------------------------ 
// Модифицированная бисекция (с проверкой корня на концах отрезка)
//------------------------------------------------------
float rootFindDiv2(float xl, float xr, float eps, function f)
{
    int stepcount = 0; // число шагов
    float xm;

    while (fabs(xr - xl) > eps)
    {
        stepcount++;
        xm = (xl + xr) / 2.0f; // середина отрезка

        // Если правая граница уже является корнем
        if (f(xr) == 0)
        {
            printf("Find root for %d steps\n", stepcount);
            return xr;
        }
        // Если левая граница уже является корнем
        if (f(xl) == 0)
        {
            printf("Find root for %d steps\n", stepcount);
            return xl;
        }

        // Обычная логика деления пополам
        if (signF(xl, f) != signF(xm, f))
            xr = xm;
        else
            xl = xm;
    }

    printf("Find root for %d  steps\n", stepcount); // статистика
    return (xl + xr) / 2.0f;
}

//------------------------------------------------------ 
// Метод хорд (метод секущих, двухточечный)
//------------------------------------------------------
float rootFindChord(float xl, float xr, float eps, function f)
{
    int stepcount = 0;

    // Пока отрезок ещё достаточно "широк"
    while (fabs(xr - xl) > eps) 
    {
        // Пересекаем хорду (через точки (xl, f(xl)) и (xr, f(xr)))
        // с осью Ox и берём это пересечение как новое приближение.
        //
        // Здесь делаются два последовательных шага:
        // сначала обновляется xl:
        xl = xr - (xr - xl) * f(xr) / (f(xr) - f(xl));

        // потом обновляется xr, уже с учётом нового xl:
        xr = xl - (xl - xr) * f(xl) / (f(xl) - f(xr));

        stepcount++;
    }

    printf("Find root for %d steps\n", stepcount); // статистика
    return xr;  // возвращаем последнее приближение
}

//------------------------------------------------------ 
// Метод касательных (Ньютона)
// xn  — начальное приближение
//------------------------------------------------------
float rootFindTangent(float xn, float eps, function f, function df)
{
    float x1 = xn - f(xn)/df(xn); // первое улучшение по формуле Ньютона
    float x0 = xn;                // предыдущее значение
    int stepcount = 0;

    // Пока изменение по x больше eps — продолжаем итерации
    while (fabs(x0 - x1) > eps)
    {
        x0 = x1;
        x1 = x1 - f(x1)/df(x1);  // формула Ньютона: x_{n+1} = x_n - f(x_n)/f'(x_n)
        stepcount++;
    }

    printf("Find root for %d steps\n", stepcount); // статистика
    return x1;  // найденный корень
}

//------------------------------------------------------ 
// Комбинированный метод (хорды + Ньютона в зависимости от знака f*f'')
// Идея: на той границе, где f(x)*f''(x) < 0,
//       удобнее использовать метод хорд (обеспечивает сходимость);
// на другой — метод Ньютона, который быстрее сходится.
//------------------------------------------------------
float rootFindCombine(float xl, float xr, float eps,
                      function f, function df, function ddf) 
{
    int stepcount = 0;

    // Условие остановки: длина интервала меньше 2*eps
    while (fabs(xl - xr) > 2*eps) 
    {
        // Для левой границы:
        // если f(xl)*f''(xl) < 0 — используем шаг хорды
        // иначе — шаг Ньютона
        if (f(xl) * ddf(xl) < 0)
            xl = xl - (f(xl) * (xl - xr)) / (f(xl) - f(xr)); // шаг хорды от xl
        else
            xl = xl - f(xl)/df(xl);                          // шаг Ньютона от xl

        // Для правой границы — аналогично
        if (f(xr) * ddf(xr) < 0)
            xr = xr - (f(xr) * (xr - xl)) / (f(xr) - f(xl)); // шаг хорды от xr
        else
            xr = xr - f(xr)/df(xr);                          // шаг Ньютона от xr

        stepcount++;
    }

    printf("Find root for %d steps\n", stepcount); // статистика
    return (xl + xr) / 2.0f;  // середина финального интервала
}


int main(void) 
{
    // Точные отрезки, на которых сидят корни (уточнены относительно (-2,0))
    const float points[4][2] = {
        { -2.0f,  -1.6f   },
        { -1.5f,  -1.0f   },
        { -0.7f,  -0.5f   },
        { -0.16f, -0.001f }
    };

    const float eps = EPS;  // точность для комбинированного метода

    for (int i = 0; i < 4; i++)
    {
        printf("------------------Root%d----------------------\n", i);

        // 1. Линейный поиск
        printf("Line Search root1 = %f\n",
               rootFindLineSearch(points[i][0], points[i][1], ACCURACY, f));
        // Пример: Find root for 10011 steps  Line Search root1 ≈ -1.923878

        // 2. Бисекция
        printf("Find Div Search root1 = %f\n",
               rootFindDiv(points[i][0], points[i][1], ACCURACY, f));
        // Пример: ~13 шагов, root ≈ -1.923859

        // 3. Модифицированная бисекция
        printf("Find Div2 Search root1 = %f\n",
               rootFindDiv2(points[i][0], points[i][1], ACCURACY, f));
        // Пример: те же ~13 шагов, тот же корень

        // 4. Метод хорд
        printf("Find Chord Search root = %f\n",
               rootFindChord(points[i][0], points[i][1], ACCURACY, f));
        // Пример: около 3 шагов до нужной точности

        // 5. Метод Ньютона (касательных), стартуем с левой границы отрезка
        printf("Find Find Tangent root = %f\n",
               rootFindTangent(points[i][0], ACCURACY, f, df));
        // Пример: около 3 шагов

        // 6. Комбинированный метод (хорды + Ньютона с учётом знака f*f'')
        printf("Find Combine Search root = %f\n",
               rootFindCombine(points[i][0], points[i][1], eps, f, df, ddf));
        // Пример: несколько итераций (обычно мало), результат как у Ньютона
    }

    return 0;
}