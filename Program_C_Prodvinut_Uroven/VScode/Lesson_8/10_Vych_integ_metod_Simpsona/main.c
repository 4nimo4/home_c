/*
//------------------------------------------------------ 
// Вычисление интеграла по методу Симпсона
//------------------------------------------------------
Суть метода заключается в приближении подъинтегральной функции 
на отрезке [a,b] параболой. Аналогично двум предыдущим
методам отрезок разбивается на n равных частей, 
для каждой из частей применяется метод Симпсона.

Формулой Симпсона называется:

  xr       xr      
  ∫ f(x) ≈ ∫ p(x) ≈ ((xr - xl)/6) * (f(xl) + 4f((a + b)/2) + f(xr))
 xl       xl      

где p(x) — парабола.
*/

#include <stdio.h>    // стандартный ввод-вывод (printf и др.)
#include <math.h>     // математические функции (здесь напрямую почти не используются)

#define ACCURACY 1000 // Количество разбиений интервала (n). Чем больше n, тем точнее интеграл.

typedef float(*function)(float);
// Тип function — указатель на функцию вида float f(float)


//------------------------------------------------------ 
// Интегрируемая функция f(x)
// f(x) = 8x^4 + 32x^3 + 40x^2 + 16x + 1
// На интервале (-2, 0) она имеет несколько корней, а
// здесь используется для вычисления площади под графиком.
//------------------------------------------------------
float f(float x) 
{
    return 8*x*x*x*x + 32*x*x*x + 40*x*x + 16*x + 1;
}

//------------------------------------------------------ 
// Тестовая функция для проверки корректности методов интегрирования.
// testf(x) = 2 (постоянная функция).
// Интеграл по [0, 2] равен 2 * 2 = 4 — площадь прямоугольника 2×2.
//------------------------------------------------------
float testf(float x)
{
    return 2;
}

//------------------------------------------------------ 
// Метод прямоугольников (левых прямоугольников)
//------------------------------------------------------
// xl, xr — пределы интегрирования
// n      — количество подотрезков (прямоугольников)
// f      — функция, которую интегрируем
//
// Идея: разбить [xl, xr] на n равных частей длиной h,
// в каждом подотрезке взять значение f в левой точке и
// посчитать площадь прямоугольника: f(x_i) * h.
//------------------------------------------------------
float calcIntegralSquare(float xl, float xr, size_t n, function f) 
{
    float sum = 0.0f;
    float h = (xr - xl) / n;  // ширина одного прямоугольника

    for (size_t i = 0; i < n; i++) 
    {
        sum += f(xl); // высота прямоугольника
        xl += h;      // сдвигаемся к следующей левой точке
    }

    return sum * h;  // суммарная площадь всех прямоугольников
}

//------------------------------------------------------ 
// Метод трапеций
//------------------------------------------------------
// xl, xr — пределы интегрирования
// n      — количество трапеций
// f      — интегрируемая функция
//
// Каждый малый отрезок [x, x+h] заменяется трапецией
// с основаниями f(x) и f(x+h).
// Площадь одной трапеции: (f(x) + f(x+h)) / 2 * h.
//------------------------------------------------------
float calcIntegralTrap(float xl, float xr, size_t n, function f) 
{
    float sum = 0.0f;
    float h = (xr - xl) / n;

    // Цикл по внутренним точкам: от xl + h до xr - h.
    for (float x = xl + h; x < xr - h; x += h) 
    {
        sum += 0.5f * h * (f(x) + f(x + h)); // площадь одной трапеции
    }

    return sum; // суммарная площадь (приближённый интеграл)
}

//------------------------------------------------------ 
// Метод Симпсона (параболическая интерполяция)
//------------------------------------------------------
// xl, xr — пределы интегрирования
// n      — количество подотрезков (желательно чётное, но здесь
//          шаг просто используется в формуле цикла)
// f      — интегрируемая функция
//
// На каждом малом отрезке [x, x+h] интеграл аппроксимируется
// параболой, проходящей через точки (x, f(x)), (x+h/2, f(x+h/2)),
// (x+h, f(x+h)).
// Формула для одного шага: h/6 * [ f(x) + 4*f(середина) + f(x+h) ].
//------------------------------------------------------
float calcIntegralSimpson(float xl, float xr, size_t n, function f) 
{
    float sum = 0.0f;
    float h = (xr - xl) / n;

    for (float x = xl + h; x < xr - h; x += h) 
    {
        float mid = 0.5f * (x + x + h); // середина отрезка [x, x+h], т.е. x + h/2
        sum += h / 6.0f * (f(x) + 4.0f * f(mid) + f(x + h));
    }

    return sum;
}

int main(void) 
{
    // 1. Тест интегрирования константы 2 по [0, 2].
    // Ожидаемый интеграл: 4.0.
    printf("calcIntegralSquare integral %f\n",
           calcIntegralSquare(0, 2, ACCURACY, testf));
    // Результат в комментарии:
    // calcIntegralSquare integral 4.000000

    /*
        Тестовая функция:

        float testf(float x)
        {
            return 2;
        }

        Её интеграл по [0, 2] даёт площадь прямоугольника 2×2 = 4.
    */

    // 2. Интеграл исходной функции f(x) на отрезке [-1.382683, -0.617316].
    // В комментариях отмечено, что это площадь "половины лепестка синусоиды"
    // выше оси Ox (то есть положительная часть под графиком).
    printf("calcIntegralSquare = %f\n",
           calcIntegralSquare(-1.382683, -0.617316, ACCURACY, f));
    // calcIntegralSquare = 0.492744

    // 3. Тот же интеграл методом трапеций.
    printf("calcIntegralTrap = %f\n",
           calcIntegralTrap(-1.382683, -0.617316, ACCURACY, f));
    // calcIntegralTrap = 0.492743

    // 4. Тот же интеграл методом Симпсона.
    printf("calcIntegralSimpson = %f\n",
           calcIntegralSimpson(-1.382683, -0.617316, ACCURACY, f));
    // calcIntegralSimpson = 0.492743

    return 0;
}