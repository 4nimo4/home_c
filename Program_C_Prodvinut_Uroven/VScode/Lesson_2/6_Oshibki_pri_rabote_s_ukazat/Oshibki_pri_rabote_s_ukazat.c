/*
//------------------------------------------------------
//        Ошибки при работе с указателями
//------------------------------------------------------
//      Типичные ошибки при работе с указателями:
//  - Ошибка при множественном объявлении переменных
//  - Использование неинициализированного указателя
//  - Присвоение неверного значения в указатель
//  - Некорректный инкремент при работе с указателем
//------------------------------------------------------
//      Ошибка при множественном объявлении переменных
//------------------------------------------------------
// Знак * относится к имени переменной, а не к самому типу int.
// В строке
//      int *p1, p2;
// объявляется:
//      p1 — указатель на int,
//      p2 — обычная переменная типа int,
// хотя визуально может показаться, что оба — указатели.
// Если нужны два указателя, писать нужно:
//      int *p1, *p2;
//------------------------------------------------------
*/

#include <stdio.h>

int main(void) 
{
    // ---------------- Ошибка при множественном объявлении ----------------
    int *p1, p2;   // p1 — указатель на int, p2 — просто int

    int n = 30;
    p1 = &n;       // корректно: p1 хранит адрес переменной n
    p2 = &n;       // ОШИБКА: p2 — это int, а &n — адрес (int*).
                   // Компилятор обычно выдаст предупреждение/ошибку
                   // о несоответствии типов: присвоение указателя целому.

    // ---------------- Использование неинициализированного указателя ----------------
    int *r1;       // указатель ОБЪЯВЛЁН, но НЕ инициализирован.
                   // В нём лежит случайный мусорный адрес.

    int n2 = *r1;  // ОШИБКА: разыменование неинициализированного указателя.
                   // Программа попытается прочитать память по непредсказуемому адресу,
                   // что приводит к неопределённому поведению (часто — падение).
    printf("%d\n", n2);

    /*
    Правильный подход:

    int *p;
    int m = 10;   // инициализируем переменную
    p = &m;       // записываем в указатель адрес m
    int n = *p;   // корректное разыменование: читаем значение m
    printf("%d", n);
    */

    // ---------------- Указатель на неинициализированную переменную ----------------
    int *t1;
    int m1;       // локальная переменная НЕ инициализирована, содержит мусор

    // Правильно: int m1 = 100;
    t1 = &m1;     // t1 указывает на m1, но значение m1 неизвестно (мусор)

    int n3 = *t1; // формально это допустимо по типу, но логически — ошибка:
                  // мы читаем неинициализированную переменную.
    printf("%d\n", n3);

    // ---------------- Присвоение неверного значения в указатель ----------------
    // Встраиваемые системы (микроконтроллеры) иногда специально кладут
    // константы-адреса в указатели, но в обычной программе такое —
    // почти всегда ошибка.
    int *c1;
    int m2 = 100;

    c1 = m2;      // ОШИБКА: c1 — указатель, ему нужно присвоить адрес (&m2),
                  // а m2 — просто значение типа int (100).
                  // Компилятор, как правило, предупредит о неверном типе.
    // Правильно: c1 = &m2;

    // ---------------- Некорректный инкремент при работе с указателем ----------------
    // Операции * (разыменование) и ++ имеют одинаковый приоритет и
    // выполняются справа налево. То есть выражение *d1++ трактуется как
    //   *(d1++)
    // а НЕ как
    //   (*d1)++.
    int *d1;
    int m3 = 100;
    d1 = &m3;     // d1 указывает на m3

    *d1++;        // ОШИБКА по смыслу: инкрементируется указатель d1,
                  // а разыменование результата *(старый d1) игнорируется.
                  // В итоге d1 начнёт указывать "мимо" m3.
                  //
                  // Если хотели увеличить значение по адресу, нужно:
                  //   (*d1)++;  // увеличить значение m3 на 1

    // Правильно:
    // (*d1)++;    // увеличить значение, на которое указывает d1

    return 0;
}