/*
//------------------------------------------------------
//        Динамическая память и динамический массив
//------------------------------------------------------
//      Что такое динамическое распределение памяти?
//------------------------------------------------------
// Модель памяти

Выделяются следующие области памяти (снизу вверх):
Область программы — код и константы
Область глобальных переменных
Стек — область хранения для локальных переменных,
Общая память (традиционно называемая «кучей»
heap)
Куча существует всё время выполнения программы, но
память в ней выделяется и освобождается
динамически, по требованию программиста.
//------------------------------------------------------
//      Функции для работы с кучей
//------------------------------------------------------
Для работы с динамической памятью определены следующий
функции:
● void *malloc(size_t size); — выделяет память
указанного размера и возвращает указатель на начало
выделенного блока
● void *calloc(size_t nitems, size_t nsize); — выделяет
память под массив с последующей инициализацией
элементов нулями
● void free(void *ptr); — освобождает ранее выделенную
память
● void *realloc(void *ptr, size_t newsize); — изменяет
размер выделенного блока памяти
//------------------------------------------------------
//     Что такое динамический массив?
//------------------------------------------------------
Динамический массив — это массив, размер которого может 
изменяться во время исполнения программы.
//------------------------------------------------------
//     Пример динамического массива
//------------------------------------------------------
// На стандартном потоке ввода задаётся последовательность
// вещественных чисел (double). Ввод завершается концом файла (EOF).
//
// На стандартный поток вывода необходимо:
//   1) распечатать среднее арифметическое всех введённых чисел;
//   2) распечатать только те числа, которые НЕ ПРЕВЫШАЮТ
//      это среднее значение.
//
// Для хранения чисел используется динамический массив, который
// при необходимости расширяется с помощью realloc.
//------------------------------------------------------
*/

#include <stdio.h>
#include <stdlib.h>

int main(void) 
{
    double sum = 0, v;       // sum — сумма всех введённых чисел, v — текущее введённое значение
    int arr_size = 0;        // arr_size — текущий размер (в элементах) выделенного массива
    int arr_u = 0;           // arr_u — количество реально использованных элементов (сколько чисел введено)
    double *arr = NULL;      // arr — указатель на динамический массив double

    // 1. Инициализируем начальный размер динамического массива
    arr_size = 2; // начальный небольшой размер (2 элемента), будем увеличивать по мере необходимости

    // Выделяем память под arr_size элементов типа double.
    // sizeof(arr[0]) == sizeof(double), так код легче поддерживать.
    // malloc возвращает указатель на выделенную память или NULL при ошибке.
    if (!(arr = (double*) malloc(arr_size * sizeof(arr[0]))))
    {
        // Если память выделить не удалось — переходим к обработке ошибки
        goto out_of_mem;
    }

    // 2. Читаем данные из stdin до конца файла.
    // scanf("%lf", &v) == 1 означает, что успешно прочитан один double.
    while (scanf("%lf", &v) == 1)
    {
        // Если мы уже использовали все выделенные ячейки (массив заполнен):
        if (arr_u == arr_size)
        {
            // Увеличиваем размер массива вдвое.
            arr_size *= 2;

            // Перевыделяем память с новым размером.
            // realloc пытается расширить/переместить уже выделенную область.
            // При неудаче возвращает NULL, старый указатель при этом терять нельзя,
            // но здесь сразу проверяем результат.
            if (!(arr = (double*) realloc(arr, arr_size * sizeof(arr[0]))))
            {
                // Не смогли выделить память под увеличенный массив
                goto out_of_mem;
            }

            // Для отладки: можем увидеть, как растёт размер массива.
            printf("arr_size = %d\n", arr_size);
        }

        // Добавляем текущее значение v в сумму
        sum += v;

        // Сохраняем v в массив в позицию arr_u
        arr[arr_u] = v;

        // Увеличиваем счётчик использованных элементов
        arr_u++;
    }

    // 3. Если не было введено ни одного числа:
    if (!arr_u)
    {
        // Нечего считать и выводить — просто завершаем программу.
        // Можно вернуть 0 как "успешное завершение".
        return 0;
    }

    // 4. Вычисляем среднее арифметическое:
    double average = sum / arr_u;
    printf("%lf\n", average); // печатаем среднее значение

    // 5. Проходим по всем сохранённым значениям и печатаем только те,
    //    которые не превышают среднее.
    for (int i = 0; i < arr_u; i++) 
    {
        // Для вещественных чисел в идеале сравнивать с допуском (эпсилон),
        // но здесь по условию задачи достаточно простого <=.
        if (arr[i] <= average)
        {
            printf("%lf\n", arr[i]);
        }
    }

    // 6. Освобождаем динамически выделенную память,
    //    чтобы не было утечек памяти.
    free(arr);

    // Успешное завершение программы
    return 0;

    // 7. Обработка ошибки выделения памяти
out_of_mem:
    // Сообщаем об ошибке в поток ошибок stderr
    fprintf(stderr, "Can't allocate memory\n");

    // Возвращаем ненулевой код завершения (признак ошибки)
    return 1;
}
