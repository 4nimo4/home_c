/*
//------------------------------------------------------------------------------------
//        Обнаружение утечек памяти
//--------------------------------------------------------------------------------------
// Утечка памяти - процесс неконтролируемого уменьшения объёма 
// свободной оперативной или виртуальной памяти компьютера,
// связанный с ошибками в работающих программах, 
// вовремя не освобождающих ненужные уже участки памяти.
//--------------------------------------------------------------------------------------
// Алгоритм:
// 1) Макросы подменяют стандартные malloc/free на my_malloc/my_free.
// 2) При каждом malloc добавляем запись в однонаправленный список.
// 3) При каждом free удаляем запись из списка.
// 4) Если в конце программы список не пуст, значит есть утечки.
//----------------------------------------------------------------------------------------
структура list и сам выделенный блок памяти живут в РАЗНЫХ местах.
В памяти (упрощённо):
Блок №1 блок пользовательских данных: void *ptr = malloc(size);  // [ пользовательские данные size байт ]
Блок №2 узел списка (struct list): list *tmp = malloc(sizeof(list));  // отдельный блок для учёта
                       tmp  --->  [ struct list:
                                    address = ptr
                                    size    = size
                                    comment = "Allocated: file=..., line=..., ptr=..., size=..."
                                    next    = (старый memlist)
                                  ]
И где‑то отдельно: глобальная переменная memlist ---> tmp хранит адрес tmp (головы списка), 
tmp->address хранит адрес ptr (пользовательский блок), tmp->next указывает либо на следующий узел, 
либо на NULL.  
Важно: Пользовательский блок (по адресу ptr) и служебный узел списка (по адресу tmp)
— это ДВА РАЗНЫХ блока памяти, выделенных ДВУМЯ разными вызовами malloc.
Зачем такой разнос: 
1.Прозрачность для пользователя Для твоего кода malloc/free ведут себя как обычно
2. Гибкость: Узлы списка могут храниться где угодно, быть сколько угодно сложными (comment
, время, стек вызовов и т.п.),при этом размер пользовательского блока не «засоряется» служебными полями.
3, Не надо менять протокол malloc                            
*/

#include <stdio.h>      // printf, fprintf
#include <stdlib.h>     // malloc, free
#include <stdint.h>     // uintptr_t, uint64_t
#include <string.h>     // snprintf

//=========================================================================================
//   Описание узла списка
//==========================================================================================
typedef struct list         //struct list - старое имя типа структуры
                            //typedef struct list - Тип struct list теперь 
                            //имеет псевдоним (синоним) list в конце структуры
{
    void *address;          // address — указатель на выделенный блок памяти
    size_t size;            // size — размер выделенного блока (в байтах)
    char comment[128];      // comment — текстовое описание: файл, строка, функция, адрес
                    //char comment[128] — память, которая живёт столько, сколько живёт элемент списка;
    struct list *next;      // next — указатель на следующий элемент списка (однонаправленный список)
} list;     //— новое короткое имя ТИПА структуры struct list.
            



// Глобальный указатель на начало списка всех "живых" (неосвобождённых) блоков памяти
// Если memlist == NULL, список пуст, утечек на данный момент нет.
static list *memlist = NULL;//«пока ещё никакой узел не создан, переменная не хранит адрес узла».
                    //— это глобальная статическая переменная,указатель на первый элемент 
                    //списка (голову списка),который изначально равен NULL (список пуст).

                        //static - спецификатор, переменная глобальная по времени жизни 
                //(существует всё время работы программы), но видна только внутри этого .c‑файла.
                        //list — это ТИП (структура), объявленный через typedef
                        //list *  — это ТИП указателя на такую структуру.
                        //memlist — переменная, хранящая адрес первой структуры

//============================================================================================
//   Добавление нового элемента в список
//   (регистрируем новое выделение памяти)
//===========================================================================================
void insert(list **head, void *address, size_t size, const char *comment)
/*
По смыслу: - «Добавь в начало списка head - новый элемент, описывающий выделенный блок памяти 
    с адресом address, размером size и строковым комментарием comment».

    void — тип возвращаемого значения означает, что функция ничего не возвращает.
    То есть нельзя написать x = insert(...); — у неё нет результата.
Первый параметр: list **head
    list ** — указатель на указатель на ТИП list, head — это адрес переменной типа list * 
    head — параметр функции, то есть обобщённое «место для головы списка».
    list ** означает: «дай мне адрес переменной, которая хранит указатель на первый элемент 
    списка».
    Функция insert таким образом не привязана к конкретному memlist.Она умеет работать 
    с любым списком, голову которого ты ей передашь.
    insert принимает list **head — адрес переменной, которая хранит голову списка
    (при первом вызове это memlist) (чтобы можно было обновить её внутри функции);
Второй параметр: void *address
    void * — универсальный указатель на любую область памяти.Здесь это адрес выделенного 
    блока памяти, который ты только что получил от malloc. Ты не привязан ни к int* , 
    ни к char*, ни к какому конкретному типу — можно хранить любой указатель.
Третий параметр: size_t size
    size_t — беззнаковый целый тип, который обычно используют для размеров в байтах.
    Здесь: размер выделенного блока памяти, который ты передал в malloc например:
     int *ar = malloc(sizeof(int) * 10);     // регистрируем выделенный блок (ar) 4*10 байт
Четвёртый параметр: const char *comment
    char * — указатель на первый символ строки (C‑строка, нуль-терминированная, т.е. в конце 
    строки обязательно стоит признак конца строки '\0').
    const — значит, функция не должна менять содержимое этой строки.
    *comment - указатель на готовый текст комментария, который ты заранее сформировал 
    в my_malloc с помощью snprintf - — строка с описанием: где и как был выделен этот блок 
    (файл, строка, функция,адрес и т.п.).
*/
{
    // Выделяем память под новый элемент СПИСКА.
    /*
    typedef struct list { ... } list; — задаёт тип (чертёж).
    При каждом выполнении строки list *tmp = malloc(sizeof(list)); 
    ты создаёшь ещё один объект (экземпляр) этого типа в куче.
    Если до этого уже существовал какой‑то другой объект list (например,list node;
    или другой, ранее выделенный через malloc), то да — это будет ещё одна структура 
    с теми же полями, но своими собственными значениями и по другому адресу.
    В функции insert при каждом вызове:list *tmp = malloc(sizeof(list));ты создаёшь 
    новый узел списка у него те же поля (address,size,comment,next), как у всех, 
    но это отдельный объект со своим адресом в памяти. Цепляя их через next, ты получаешь 
    связанный список из многих таких «одинаковых по типу, разных по данным» структур.
    */
    // В этот момент ещё нет макроса malloc, поэтому используется настоящий malloc из stdlib.
    list *tmp = malloc(sizeof(list));//list *tmp — это указатель на list, В переменную tmp
                                    //записывается адрес выделенной структуры.
    if (!tmp)
    {
        // Если не удалось выделить память под элемент списка, сообщаем об ошибке.
        // Сам выделенный блок (address) при этом уже существует, но мы его не сможем отслеживать.
        fprintf(stderr, "insert: cannot allocate list node\n");
        return;
    }

    // Новый элемент будет вставлен в начало списка:
    // 1) его поле next указывает на текущую голову
    tmp->next    = *head;
    /*
      *head — текущая голова списка (например, memlist), указывает на старый первый элемент.
    Мы говорим «Сделай так, чтобы поле next нового узла указывало на предыдущую голову».
    Графически: До вставки (предположим, список не пуст):memlist = A -> B -> C -> NULL  
    После tmp->next = *head;
    tmp -> A -> B -> C -> NULL Новый узел «цепляется» перед старой головой.
    Если список был пуст (memlist == NULL):*head==NULL; tmp->next = NULL;
    — новый элемент пока ни на кого не ссылается, он будет единственным.
    */
    // 2) сохраняем адрес и размер выделенного блока в полях tmp
    tmp->address = address;
    tmp->size    = size;
    // 3) копируем комментарий с информацией об этом выделении (файл, строка, функция, адрес)
    snprintf(tmp->comment, sizeof(tmp->comment), "%s", comment);
    /*
    printf("x = %d\n", x); Печатает текст сразу на стандартный вывод 
    (обычно в консоль/терминал).
    Ничего не знает о буферах в памяти. Возвращает количество выведенных символов 
    (или отрицательное значение при ошибке). Использование: показать информацию пользователю.
    char buf[128];
    snprintf(buf, sizeof(buf), "x = %d\n", x); Печатает в строковый буфер в памяти, 
    а не на экран.
    Первый аргумент — указатель на буфер, второй — его размер.Гарантирует, что в конце строки 
    будет '\0'(если size > 0).Если результата не влезает в буфер, обрезает его, 
    но всё равно ставит '\0'. Использование: сформировать строку в памяти чтобы потом
    сохранить её в структуру, записать в лог, вывести позже одним вызовом, передать 
    в другую функцию и т.п.
    */
    // 4) теперь новый элемент становится головой списка
    *head = tmp;
}

//======================================================================================
//   Удаление элемента из списка по адресу
//   (регистрируем освобождение памяти)
//=====================================================================================
_Bool delete(list **head, void *address)
/*
_Bool Это целочисленный логический тип 0 — ложь (false), 1 — истина (true) 
(любое ненулевое преобразуется к 1).
Зачем логический тип для delete? Функция _Bool delete(list **head, void *address)
по смыслу отвечает на вопрос «Удалили ли мы элемент с таким адресом из списка?»
*/
{
    // Если список пуст — удалять нечего
    if (*head == NULL)
    {
        return 0;
    }

    list *del = NULL;//— это подготовка указателя на удаляемый узел, чтобы позже
    //сохранить туда адрес узла, который нужно удалить из списка, затем вызвать
    //free(del); и освободить память именно этого узла.
//---------------------------------------------------------------------------------------
//Если мы получили адрес и он оказался адресом головы списка:
//----------------------------------------------------------------------------------------
    if ((*head)->address == address)
    /*
    *head — это голова списка (например,memlist);
    (*head)->address — адрес блока памяти, который хранится в первом узле;
    address — тот указатель, который мы хотим удалить.
    Если они равны → «удаляемый адрес находится в первом узле».
    Но это не говорит, что этот узел «указывает сам на себя» и что он единственный.
    Когда элемент — первый, но не единственный Пример структуры
    *head (т.е.memlist) указывает на узел1.
    (*head)->address - — адрес, хранящийся в узел1. Если address совпал с этим значением 
    → удаляем узел1 (голову).Но при этом (*head)->next == адрес узла2 (НЕ NULL)
    то есть после головы есть ещё элементы.
        memlist
          | 
          v
        [узел1] -> [узел2] -> [узел3] -> NULL
    */
    {
        del = *head;           // запоминаем, кого удаляем (голову)
        *head = (*head)->next; // голова списка смещается на следующий элемент
        free(del);             // освобождаем память удалённого узла
        return 1;              // успешное удаление возвращаем логическую 1 - true
    }
//---------------------------------------------------------------------------------------
//Если мы получили адрес и он оказался адресом середины или конца списка:
//----------------------------------------------------------------------------------------
    list *tmp = *head;
    /*
    создать локальную переменную‑указатель tmp (тип list *)
    записать в неё текущее значение *head (то есть memlist). После этого 
    tmp   == memlist  // они указывают на один и тот же узел
    Важно: tmp — это ещё один указатель на тот же узел, а не «указатель на tmp
    » или «копия самой структуры». Здесь tmp играет роль текущего узла при обходе списка
    Мы начинаем с головы tmp = *head (т.е.tmp = memlist).Внутри цикла делаем
    tmp = tmp->next, переходя к следующему узлу. При этом *head (сама переменная memlist)
    остаётся неизменной — она всё время указывает на голову списка.Если бы мы обходили 
    список прямо через *head , нам пришлось бы «терять» голову
    Структура списка (пример):
            *head
              |
              v
            [узел1] -> [узел2] -> [узел3] -> [узел4] -> NULL
              ^         ^          ^          ^
              |         |          |          |
             tmp        ?          ?          ?

    Т.е. tmp — «текущий» узел, с которым мы сейчас работаем
    */
    
    while (tmp->next)          // пока есть следующий элемент (tmp->next) != NULL
    {
        if (tmp->next->address == address)
    /*
    «Проверяем: не хранится ли нужный нам address в следующем после tmp узле?».
    Почему так? Потому что, если мы хотим удалить узел в середине списка, 
    нам нужен указатель на предыдущий узел, чтобы изменить его next.
    */    
        {
            /*
            Нашли элемент, который держит этот address:
                    tmp --> [узел2] -> [узел3] -> [узел4] -> ...
                              ^
                              |
                           tmp->next
            Значит, удалять будем именно tmp->next
            */
            del = tmp->next;//указывает на «удаляемый» узел (тот, где совпал address).
            // tmp остаётся «предыдущим» узлом.
            // "Выкидываем" его из цепочки списка:   
            tmp->next = del->next;//делает вот что:
            /*
            «Теперь следующим за tmp будет тот узел, который раньше шёл после
            del». Графически до: tmp -> del -> X  после:
                                                    tmp ----> X
                                                      \
                                                      (del больше не в цепочке)
            То есть tmp->next «перепрыгивает» через del.
            После этого можно безопасно освободить память
            */
            free(del);         // освобождаем память под элемента списка
            return 1;          // успешно удалили
        //сам список остался связным tmp теперь указывает на следующий узел после del.    
        }
        //--------------------------------------------------------------------------------
        //перебирали адреса начиная со следующего после головы списка, 
        //- переходим к следующему адресу:
        //--------------------------------------------------------------------------------
        tmp = tmp->next;       // tmp->nex — следующий узел после tmp
    }

    // Если до сюда дошли, значит ни голова, ни остальные элементы не содержат этот address.
    // Это может означать:
    //  - двойной free (указатель уже освобождён ранее),
    //  - free "чужого" указателя,
    //  - или логическую ошибку в коде.
    return 0;
}

//==========================================================================================
//   Обёртка над free: удаляет запись из списка
//==========================================================================================
void my_free(void *ptr, const char *file, int line, const char *func)
/*
void *ptr — указатель на память, которую нужно освободить. Это тот же указатель, 
который ты передаёшь в free(p) в своём коде.
const char *file — имя файла (__FILE__), где был вызван free(...)
int line — номер строки (__LINE__), где был вызван free(...)
const char *func — имя функции (__func__), из которой был вызванfree(...)
Откуда берутся file,line,func? Из макроса: 
#define free(X) my_free((X), __FILE__, __LINE__, __func__)
Когда ты пишешь в main free(p);препроцессор делает из этого:
my_free(p, "Obnaruzhenie_utechek_pamyaty.c", 210, "main");
(строка и имя функции будут свои). 
*/
{
    // Сначала освобождаем реальную память через настоящий free
    free(ptr);
    /*
    Важно: здесь вызывается настоящий free из stdlib, а не наш макрос, потому что
    макрос #define free(X) my_free(...) объявлен ниже этой функции
    во время компиляции my_free ещё не действует подмена free → это чистый стандартный free
    По смыслу: «Освободи реальный блок памяти по указателю ptr».
    То есть память, выделенная ранее malloc/my_malloc , физически освобождается в куче
    дальше нам нужно только обновить наш список учёта (удалить запись об этом блоке).
    */

    // Затем пытаемся удалить запись об этом указателе из нашего списка
    if (!delete(&memlist, ptr))//&memlist — адрес головы нашего списка (типа list **)
                                //ptr — тот же указатель, что мы только что освободили.
    /*
    Функция delete(&memlist, ptr) ищет узел списка, у которого address == ptr, если находит
    вырезает этот узел из списка освобождает память под этот узел (free(del)) 
    и возвращает 1 (истина), если не находит, возвращает 0 (ложь).
    Запись if (!delete(&memlist, ptr)) значит «Если delete вернул 0 (т.е. НЕ нашёл адрес в списке) 
    — выполняем тело if».
    */                            
    {                          
        // Если delete вернул 0 — этот указатель не был найден в списке.
        // Значит, либо мы освобождаем память, которую не отслеживали,
        // либо указатель уже был удалён раньше (double free),
        // либо где-то ошибка в логике.

        // если в списке не было записи с таким адресом — предупредить!!!!!!!
        fprintf(stderr,
                "WARNING: free of unknown pointer: %p (%s:%d, %s)\n",
                ptr, file, line, func);
        /*
        То есть на экран может выйти, например:
        WARNING: free of unknown pointer: 0x12345678 (Obnaruzhenie_utechek_pamyaty.c:210, main)
        Это помогает отлаживать ошибки с неправильным использованием free.
        */
    }
}

//=============================================================================================
//   Преобразование числа в двоичную строку фиксированной длины
//   value  — значение
//   bits   — сколько бит вывести (8/16/32/64)
//   buf    — буфер для строки
//   bufsize — размер буфера (должен быть >= bits+1)
//==============================================================================================
static void to_binary(uint64_t value, int bits, char *buf, size_t bufsize)
/*
static здесь означает: эта функция видна только в этом .c‑файле (внутренняя служебная функция, как и memlist)
uint64_t value — число (64‑битное беззнаковое), которое нужно представить в двоичном виде.
int bits — сколько бит нужно вывести (8, 16, 32, 64).
char *buf — указатель на буфер, куда будет записана строка с битами. 
Ожидается, что это массив char нужного размера.
size_t bufsize — размер буфера buf (в байтах). Нужен, чтобы не выйти за границы массива.
*/
{   //Проверка размера буфера
    /*
    Здесь мы проверяем, хватит ли места, чтобы записать bits символов '0'/'1',плюс один символ \0'
    в конце (строковый терминатор).То есть нужно минимум bits + 1 байт.
    */
    if (bufsize < (size_t)(bits + 1))//Если буфер слишком мал, чтобы безопасно записать всю строку
    {
        /*
        То мы ничего не заполняем, только
        — на всякий случай делаем буфер пустой строкой (первый байт = '\0'), если буфер вообще есть
        и сразу return — выходим из функции, чтобы не писать за границы массива.
        Это защита от переполнения буфера.Поэтому ставим проверку if (bufsize > 0)
        */
        if (bufsize > 0)//если bufsize == 0 Тогда buf — это указатель на буфер нулевой длины 
        //(формально нельзя писать даже в buf[0], -это выход за границы).
        //— вообще ничего не трогаем, сразу выходим, чтобы не писать в несуществующую память.
            //Где участвует \0'? \0'ставится вне цикла, отдельной строкой: 
            buf[0] = '\0';//то записываем в 0-ю ячейку массива признак окончания строки '\0'
                          //— это строковый терминатор
        return;
    }
    /*
    Основной цикл: заполнение битами работает по битам числа, а не по индексам
    Записываем биты слева направо: старший бит → первый символ, младший бит → последний символ
    перебираем биты от старшего к младшему i = bits - 1, bits - 2, ..., 0
    Идея: 
    bits — сколько бит мы хотим вывести (например, 8, 16, 32, 64).Мы идём по битам числа value
    от старшего к младшему 

    */
    for (int i = bits - 1; i >= 0; --i)//Пример для bits = 8 биты b7 b6 b5 b4 b3 b2 b1 b0
    /*
    bits-1 — это номер самого старшего бита, с которого мы начинаем обход до нулевого бита.
    При bits = 8 индексы будут такие:
        i = 7 (b7, старший бит) → buf[8 - 1 - 7] = buf[0]
        i = 6 (b6, старший бит) → buf[8 - 1 - 6] = buf[1]
        i = 5 (b5, старший бит) → buf[8 - 1 - 5] = buf[2]
        i = 4 (b4, старший бит) → buf[8 - 1 - 4] = buf[3]
        i = 3 (b3, старший бит) → buf[8 - 1 - 3] = buf[4]
        i = 2 (b2, старший бит) → buf[8 - 1 - 2] = buf[5]
        i = 1 (b1, старший бит) → buf[8 - 1 - 1] = buf[6]
        i = 0 (b0, старший бит) → buf[8 - 1 - 0] = buf[7]
    */
    {
        buf[bits - 1 - i] = (value & ((uint64_t)1 << i)) ? '1' : '0';
        /*
        разбираем вторую часть после =., 
        если i = 0 (uint64_t)1 << 0  →  0000...0001,
        если i = 1 (uint64_t)1 << 0  →  0000...0010,
        если i = 3 (uint64_t)1 << 0  →  0000...1000,
        если i = 7 (uint64_t)1 << 0  →  0000...10000000,
        То есть (1ULL << i) — это число(маска), у которого 
        ровно один бит равен 1 на позиции i,все остальные — 0.
        Тернарный оператор читается так: условие ? значение_если_истина : значение_если_ложь
        */
    }
    buf[bits] = '\0';  //строковый терминатор — просто «знак конца строки» 
    //и вообще не является битом числа, он не «самый старший», он просто стоит после всех 8 символов.
}

//================================================================================================
//   Обёртка над malloc: добавляет запись в список
//   и формирует подробный комментарий об этом выделении
//================================================================================================
void* my_malloc(size_t size, const char *file, int line, const char *func)
/*
size_t size – сколько байт нужно выделить (как обычный malloc(size)).
const char *file – имя исходного файла (__FILE__), откуда вызван malloc.
int line – номер строки (__LINE__).
const char *func – имя функции (__func__), в которой написан malloc.
*/
{
    // Вызываем реальный malloc (ещё без макроса, поэтому это именно стандартный malloc)
    void *ptr = malloc(size);//malloc возвращает void* — адрес выделенной памяти через 
                            //переменную ptr — универсальный указатель на выделенный блок
    /*
    Почему void * (тип возвращаемого значения)?
    malloc выделяет сырую память, а не объект конкретного типа 
    она не знает, под что ты её будешь использовать: int, double, struct list, , массив и т.д.
    возвращает адрес начала блока памяти — просто «указатель на кусок байтов».
    Чтобы сделать её универсальной, в C у malloc тип результата: 
    void *    // «указатель на неизвестный тип» «Это просто адрес области памяти 
    без конкретного типа. Ты сам решишь, к какому типу его привести».
    int    *pi = malloc(sizeof(int));      // результат (void*) неявно приводится к int*
    double *pd = malloc(sizeof(double));   // → double*
    list   *pl = malloc(sizeof(list));     // → list*
    Почему «указатель», а не объект?
    malloc работает с кучей (heap), а не со стеком, объект на стеке создаётся объявлением:
    list node; // объект прямо здесь, память освобождается при выходе из функции
    объект в куче создаётся через malloc:
    list *node = malloc(sizeof(list));  // выделили память где-то в куче, вернули АДРЕС
    Куча — это просто большой участок памяти. malloc находит там свободный кусок 
    нужного размера,
    помечает его как занятый, возвращает адрес начала этого куска → указатель.
    Сам объект (данные) живут «там, по адресу», а в переменной у тебя только указатель 
    на это место.
    Почему void * НЕ «невозвращаемое значение» Важный момент void * и void — это совсем разные вещи.
    void (без *) как тип функции: void func(void); означает: функция ничего не возвращает.
    void * — это указатель на неизвестный тип:
    void *p; — «переменная p хранит какой‑то адрес, но мы не знаем, что за тип по этому адресу».
    У malloc как раз есть возвращаемое значение — указатель: void *malloc(size_t size);
    То есть «malloc возвращает void* — адрес выделенной памяти.
    Это НЕ “ничего не возвращает”, а “возвращает универсальный указатель”».
    */
    if (!ptr)//«Если malloc вернул NULL (память не выделена) — сообщить об ошибке и выйти».
    {
        // Если не удалось выделить память, пишем в stderr и возвращаем NULL
        fprintf(stderr, "my_malloc: cannot allocate %zu bytes\n", size);
        return NULL;
    }

    // Преобразуем адрес указателя в целое число, чтобы удобно работать побитово
    /*
    ptr — это void* (указатель).Чтобы работать с ним побитово, удобно привести его к целому типу
    uintptr_t — беззнаковый целый тип, который гарантированно может хранить указатель.
    Затем приводим к uint64_t (у тебя 64‑битная система).
    v — это просто числовое представление адреса ptr (в виде 64‑битного числа).
    */
    uintptr_t addr = (uintptr_t)ptr;
    uint64_t  v    = (uint64_t)addr;
    
    // Буферы для различных двоичных представлений адреса +1 для строкового терминатора '/0'
    char bin64[64 + 1] = {0};  // все 64 бита адреса,сразу заполнили все 0-ми
    char bin32[32 + 1] = {0};  // младшие 32 бита
    char bin16[16 + 1] = {0};  // младшие 16 бит
    char bin8 [ 8 + 1] = {0};  // младшие 8 бит

    // Формируем двоичные строки
    to_binary(v,               64, bin64, sizeof(bin64)); // 64-битный адрес
    to_binary(v & 0xFFFFFFFFu, 32, bin32, sizeof(bin32)); // младшие 32 бита
    to_binary(v & 0xFFFFu,     16, bin16, sizeof(bin16)); // младшие 16 бит
    to_binary(v & 0xFFu,        8, bin8,  sizeof(bin8));  // младшие 8 бит

    // Строка комментария, где содержится информация:
    // - имя файла, номер строки, имя функции
    // - адрес в шестнадцатеричном виде
    // - часть адреса в двоичном виде
    // - размер выделенного блока
    char comment[128] = {0}; //— временный рабочий буфер, живёт только внутри my_malloc
    /*
    Зачем нужен локальный char comment[128] в my_malloc:
    Функция my_malloc знает все нужные данные:file,line,func,ptr,size, бин‑строки;
    должна собрать из этого один красивый текст. Удобнее всего собрать строку в локальный буфер:
    char comment[128] = {0}; передать готовую строку в insert(&memlist, ptr, size, comment);
    внутри insert уже просто скопировать строку в поле структуры:
    snprintf(tmp->comment, sizeof(tmp->comment), "%s", comment); То есть локальный comment
    — это рабочий черновик, поле tmp->comment — это постоянное хранилище для этого текста.
    */
    snprintf(comment, sizeof(comment),
             "Allocated: file-%s, стр-%d, func-%s, ptr_HEX=%p\n"
             "ptr_bin16=%s[%zu]",
             file, line, func, ptr,
             bin16, size);
    /*
    %p — это спецификатор формата для указателя. %p → подставляется аргумент ptr
    ptr имеет тип void * По стандарту C %p — формат для указателя (void *)
    выводит адрес в реализации‑зависимом виде, обычно в шестнадцатеричном,вроде 0x7ffd1c3a5b40
    Поэтому здесь %p — именно то, что нужно: красиво напечатать адрес указателя.

    %zu — это спецификатор формата для значения типа size_t
    size_t — это стандартный тип для размеров в байтах (результат sizeof, аргументы malloc и т.п.)
    Он беззнаковый (unsigned) и его конкретный размер зависит от платформы (на 32‑битных обычно 32 бита, 
    на 64‑битных — 64). Для printf/snprintf стандарт требует для:
    int - %d
    unsigned int - %u
    long - %ld
    unsigned long - %lu
    size_t - %zu
    Если бы ты написал, например, %u или %lu, это могло бы совпасть по размеру 
    на твоей платформе (и «работать»),
    но формально это было бы неправильное соответствие типов (UB по стандарту).
    */
    
    // Регистрируем новый блок памяти в глобальном списке memlist
    
    insert(&memlist, ptr, size, comment);
    /*
    &memlist — адрес головы списка (аналогично тому, как мы делали с head в delete);
    принимаем ptr — универсальный указатель на выделенный блок, в
    insert(&memlist, ptr, size, comment);  // здесь он хранится как void* 
    size — размер блока
    comment — сформированная выше строка с описанием.
    Функция insert делает malloc(sizeof(list));— создаёт новый узел списка;
    заполняет:
    tmp->address = address;      // здесь будет ptr
    tmp->size    = size;
    snprintf(tmp->comment, sizeof(tmp->comment), "%s", comment);
    tmp->next    = *head;
    *head        = tmp;
    В итоге новый элемент становится головой списка memlist.
    Таким образом, каждое выделение памяти получает свою запись в списке
    с точной информацией, где и что было выделено.
    */

    // Возвращаем указатель ptr вызывающему коду как // тип функции: void*
    return ptr;
    /*
    А снаружи, через макрос, этот void* автоматически приводится к нужному типу:
    int *p = malloc(sizeof(int));       // p — int*, внутри my_malloc — void*
    list *n = malloc(sizeof(list));     // n — list*
    То есть my_malloc повторяет интерфейс обычного malloc, возвращает void* 
    , а вызывающий код сам выбирает тип.
    */
}   

//==============================================================================================
//   Макросы, подменяющие стандартные malloc/free
//   на наши обёртки my_malloc/my_free
//==============================================================================================
// __FILE__  — имя исходного файла
// __LINE__  — номер строки, где вызван malloc/free
// __func__  — имя функции, в которой находится вызов
#define malloc(X) my_malloc((X), __FILE__, __LINE__, __func__)
/*
Когда ты пишешь в main int *p = malloc(sizeof(int)); препроцессор подставляет:
int *p = my_malloc(sizeof(int),"Obnaruzhenie_utechek_pamyaty.c",210,"main");
Так my_malloc узнаёт, где именно в коде был вызван malloc.
*/
#define free(X)   my_free((X), __FILE__, __LINE__, __func__)

//==============================================================================================
//   Печать списка (выявление утечек)
//=============================================================================================
void printList(list *head)
/*
printList печатает все ещё не освобождённые блоки, которые остались в списке, начиная с
головы head (в твоём коде это обычно memlist).
head — указатель на первый элемент списка (голову). Вызов printList(memlist);
означает: «пройди по всему списку блоков памяти, которые мы отслеживаем».
*/ 
{
    // Если список пуст — ни одного "висящего" блока нет
    if (head == NULL)
    {
        printf("No memory leak detected\n");
        return;
    }

    // Если список не пуст — значит есть ещё неосвобождённые блоки
    printf("Memory leaks detected:\n");
    while (head)
    {
        // Выводим комментарий, сохранённый при выделении памяти
        // В нём — источник (файл, строка, функция) и информация об адресе/размере
        printf("%s\n", head->comment);
        head = head->next; // переходим к следующему элементу списка
    }
}

//===============================================================================================
//   Пример использования
//==============================================================================================
int main(void) 
{
    // При этих вызовах сработают макросы и фактически будут вызваны my_malloc(...)
    int *p  = malloc(sizeof(int));          // регистрируем первый выделенный блок (p) 4 байта
    int *ar = malloc(sizeof(int) * 10);     // регистрируем второй выделенный блок (ar) 4*10 байт

    // Проверяем состояние списка утечек сразу после двух malloc
    printList(memlist);

    *p = 5;                      // обычное использование памяти записали в выделенный блок значение 5

    //free(p);                  // освобождаем p, из списка удаляется запись с адресом p

    // После освобождения p в списке должен остаться только ar
    printList(memlist);

    // Ещё одно выделение памяти, адрес которого попадёт в список
    //p = malloc(sizeof(int));

    // Освобождаем массив ar — запись о нём удаляется из списка
    free(ar);

    // Освобождаем p — запись о нём также удаляется
    free(p);

    // На этом этапе, если всё освобождено корректно, список пуст
    printList(memlist);

    return 0;
}