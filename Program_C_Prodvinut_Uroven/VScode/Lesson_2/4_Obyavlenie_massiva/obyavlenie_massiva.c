/*
//------------------------------------------------------
//        Объявление массива
//------------------------------------------------------
// При объявлении массива a[] в памяти выделяется достаточно места
// для хранения указанного количества элементов.
// При объявлении указателя ps в памяти выделяется место только
// под сам указатель (обычно 8 байт для 64‑разрядной ОС).
//------------------------------------------------------
// Рассмотрим пример использования библиотечной функции strcpy,
// которая копирует строку из второго аргумента в первый и
// возвращает адрес (указатель) на первый аргумент (начало новой строки).
//------------------------------------------------------
*/

#include <stdio.h>
#include <string.h>

int main(void) 
{
    // Объявляем строковый литерал "test" и сразу инициализируем им массив a.
    //
    // char a[] = "test";
    //
    // Компилятор автоматически подбирает размер массива:
    //   "test" — это 4 символа + завершающий нулевой байт '\0'
    //   итого: 5 байт.
    // В памяти под a будет выделено 5 байт: {'t','e','s','t','\0'}.
    char a[] = "test";

    // Объявляем массив b размером 100 символов.
    // Здесь память выделяется сразу под 100 байт,
    // и массив пока не инициализирован (содержимое неопределённое,
    // пока мы его не заполним).
    char b[100];

    // Функция strcpy(char *dest, const char *src)
    // копирует строку из src в dest, включая завершающий нулевой символ '\0'.
    //
    // Здесь:
    //   dest = b  — куда копируем,
    //   src  = a  — откуда копируем.
    //
    // После вызова в массиве b будет лежать копия строки "test".
    strcpy(b, a);

    // Печатаем содержимое массива b как строку:
    // %s — формат для вывода C-строки (массив символов, заканчивающийся '\0').
    printf("b = %s\n", b);

    // Вторая строка демонстрирует, что strcpy возвращает указатель
    // на dest (то есть b). Поэтому выражение strcpy(b, a) можно
    // непосредственно передать в printf как строку:
    //
    //   strcpy(b, a) ещё раз скопирует "test" в b
    //   и вернёт указатель на b, который и будет напечатан по %s.
    printf("b = %s\n", strcpy(b, a));

    return 0;
}