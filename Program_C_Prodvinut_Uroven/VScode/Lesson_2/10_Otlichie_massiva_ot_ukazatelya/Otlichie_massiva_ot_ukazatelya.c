/*
//------------------------------------------------------
//        Отличие массива от указателя
//------------------------------------------------------
*/

#include <stdio.h>

//==================================================
// Отличие массива от указателя при инициализации строкой
//==================================================
// И массивы, и указатели можно инициализировать строковыми литералами,
// но поведение при этом РАЗНОЕ.

// 1) МАССИВ, инициализированный строковым литералом:
void example_array(void)
{
    // При таком объявлении:
    //   char s[] = "Hello world";
    // компилятор:
    //   - размещает строковый литерал "Hello world" (включая '\0') где‑то в памяти,
    //   - КОПИРУЕТ его содержимое в локальный массив s.
    //
    // В результате s — это ИЗМЕНЯЕМЫЙ массив, лежащий, как правило, на стеке.
    char s[] = "Hello world";

    s[0] = 'A'; // Так МОЖНО: изменяем содержимое массива s.
    printf("%s\n", s); // Выведет "Aello world"
}

// 2) УКАЗАТЕЛЬ на строковый литерал:
void example_pointer(void)
{
    // При таком объявлении:
    //   char *s = "Hello world";
    // строковый литерал размещается, как правило, в сегменте констант (read-only),
    // а в указателе s хранится ТОЛЬКО АДРЕС первого символа этого литерала.
    //
    // Содержимое по этому адресу изменять НЕЛЬЗЯ: это константные данные.
    const char *s = "Hello world";

    // s[0] = 'A'; // ОШИБКА ВО ВРЕМЯ ВЫПОЛНЕНИЯ (UB): попытка изменить read-only память.
    // Компилятор при правильном типе (const char*) такую запись даже не даст сделать.
    printf("%s\n", s); // Корректно только читать
}

//==================================================
// Основные отличия указателей от массивов
//==================================================
/*
-------------------------------------------------------------------------------
        Указатель                      |      Массив 
-------------------------------------------------------------------------------
Содержит АДРЕС, по которому можно      |  Содержит САМИ ДАННЫЕ.
найти данные.                          |  Память под все элементы выделена
                                       |  сразу при объявлении.
Пример:                                |  Пример:
    int *par = ar;                     |      int ar[] = {1,2,3,4,5};
-------------------------------------------------------------------------------
Для доступа к данным:                  |  Прямой доступ по индексу:
    *(par + 3) = 123;                  |      ar[3] = 123;
т.е. берём адрес из указателя,         |  Компилятор сам вычисляет
смещаем его и разыменовываем.          |  адрес ar + 3.
-------------------------------------------------------------------------------
Чаще используется для ДИНАМИЧЕСКИХ     |  Чаще используется, когда число
данных:                                |  элементов ЗАРАНЕЕ известно:
    int *p = malloc(n * sizeof *p);    |      int ar[5];
-------------------------------------------------------------------------------
Память обычно берётся из кучи          |  Память выделяется неявно:
(malloc/calloc/realloc) и освобож-     |  - локальные массивы — на стеке,
дается free().                         |  - глобальные/статические — в
                                       |    статической области памяти.
-------------------------------------------------------------------------------
Может ссылаться на безымянные данные,  |  Всегда имеет ИМЯ переменной —
на середину массива и т.п.            |  имя массива описывает весь блок.
-------------------------------------------------------------------------------
sizeof(указатель) всегда даёт размер   |  sizeof(массива) даёт ОБЩИЙ
самого указателя (обычно 8 байт на    |  размер всей памяти под массив,
64‑битной системе), независимо от      |  например 5 * sizeof(int).
типа, на который он указывает.         |
-------------------------------------------------------------------------------
*/

// Небольшой демонстрационный main
int main(void)
{
    example_array();
    example_pointer();
    return 0;
}