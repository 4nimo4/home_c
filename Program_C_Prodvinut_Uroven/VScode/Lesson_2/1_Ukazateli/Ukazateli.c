/*
//------------------------------------------------------
        Указатели
//------------------------------------------------------
Указатель — это переменная, значением которой является адрес
некоторого объекта.
При задании указателя необходимо определить базовый тип на
который данный указатель будет ссылаться.
Определено также специальное значение NULL 0, которое не
соответствует никакому допустимому адресу объекта.
//------------------------------------------------------
        Определение указателя
//------------------------------------------------------
● int *x; // Указатель на тип int
● char * func(int *ptr); // Функция, которая
    возвращает указатель на char и
    принимает на вход указатель на тип int.
● int *arr[10]; // Массив указателей
● void *pv; // Указатель на пустой тип
● int (*ars)[5; // Указатель на строку из 5
    элементов int.
● char (* pfunc)(int, float); // Указатель на
    функцию, которая возвращает char и
    принимает два аргумента int и float
● int **p; // Указатель на указатель на тип int.
//------------------------------------------------------
       Приведение типов указателей
//------------------------------------------------------
Внимание! Если указатель не инициализирован, то он
указывает на случайную область памяти.
Внимание! В реальной жизни не стоит злоупотреблять
явным приведением значений одних указательных типов к
другим, это может привести к появлению трудных для
обнаружения ошибок.
//------------------------------------------------------
       Условные операторы в циклах с NULL
//------------------------------------------------------
Выражения с указателями можно использовать в условных операторах
и циклах при работе со списками.

for (p = head; p != NULL - (эквивалентно p); p = p->next)
// работает, пока p не станет 0 (NULL)
/------------------------------------------------------
       Специальный тип void
//------------------------------------------------------
Существует специальный тип обобщенного указателя void *.
Такому указателю можно присваивать значения указателей любого
типа, и такой указатель можно присваивать указателю любого типа.
Обычно он используется для передачи объекта в функцию, когда тип
передаваемого объекта заранее не известен.
Внимание! Указатель void * нельзя разыменовывать, но можно
сравнивать с нулём.
/------------------------------------------------------
//------------------------------------------------------
//       Приведение типов указателей
//------------------------------------------------------
*/

#include <stdio.h>

int main(void) 
{
    float f = 2.0;   // обычная переменная типа float, в ней сейчас лежит число 2.0

    int *p;          // указатель на int

    // Приводим адрес переменной f (типа float*) к типу int*
    // Теперь p "смотрит" на те же самые 4 байта, что и f,
    // но мы будем интерпретировать их как целое (int), а не как float.
    p = (int*)&f;

    // Печатаем содержимое памяти, где хранится f, но как целое число в шестнадцатеричном виде.
    // *p — это те же 4 байта, что и f, только интерпретированные как int.
    // %x — формат вывода беззнакового целого в виде HEX.
    printf("*p = %x\n", *p);

    // Записываем в *p новое значение битов.
    // Выражение (127 + 3) << 23:
    //   - в формате IEEE 754 для float:
    //       1 бит — знак
    //       8 бит — экспонента (EXP), со смещением +127
    //       23 бита — мантисса (дробная часть)
    //
    //   - хотим получить число 2^3 = 8.0
    //   - для числа 2^e:
    //       истинная экспонента E = e
    //       хранимая экспонента EXP = E + 127 = e + 127
    //   - при e = 3: EXP = 3 + 127 = 130
    //
    //   - чтобы положить это в поле EXP, сдвигаем EXP влево на 23 бита:
    //       EXP << 23
    //     это даёт число, у которого:
    //       - в битах 30..23 — экспонента,
    //       - мантисса = 0 (соответствует 1.0 в нормализованном виде),
    //       - знак = 0 (положительное число).
    //
    // Таким образом, мы формируем битовое представление числа 8.0 (2^3)
    // и напрямую записываем его в те же 4 байта, где лежит f.
    *p = (127 + 3) << 23;  // кладём в f значение 2^3, меняем "порядок" (экспоненту)

    // Теперь переменная f увидит новое значение по тем же битам — это уже не 2.0, а 8.0
    printf("f = %f\n", f);
    
    return 0;
}