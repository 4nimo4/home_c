# Компилятор и флаги
CC      = gcc
CFLAGS  = -Wall -Wextra -Wpedantic -std=c11 -Imylib2 # -Imylib2: каталог с lib2.h
LDFLAGS = -L./mylib2            # искать библиотеки в каталоге mylib2
LIBS    = -lmy2                 # подключить libmy2.so (или libmy2.a, если бы была)

# Имя итоговой программы
TARGET = prog

# Цель по умолчанию — собрать программу
all: $(TARGET)

#-----------------------------
# 1. Сборка динамической библиотеки libmy2.so
#-----------------------------

# Библиотека зависит от объектного файла lib2.o
mylib2/libmy2.so: mylib2/lib2.o
# Создаём динамическую библиотеку (-shared)
	$(CC) -shared -o mylib2/libmy2.so mylib2/lib2.o

# Компиляция исходника библиотеки в объектный файл с -fPIC
mylib2/lib2.o: mylib2/lib2.c mylib2/lib2.h
	$(CC) $(CFLAGS) -fPIC -c mylib2/lib2.c -o mylib2/lib2.o
# -fPIC — позиционно-независимый код, Где используется: при компиляции .c->.o
# Что такое PIC (Position Independent Code) 
# Обычно при компиляции обычной программы компилятор может генерировать код,
# который предполагает, что все функции и глобальные переменные находятся по
# фиксированным адресам в памяти (или по фиксированным смещениям). В
# исполняемом файле это нормально.
# Но динамическая библиотека (.so) загружается в память отдельно от программы, и
# она может быть загружена по разным адресам при разных запусках,
# разные программы могут загружать одну и ту же .so в разные места,
# даже одна и та же программа может загрузить несколько .so 
# , которые не могут все занять одни и те же фиксированные адреса.
# Чтобы код библиотеки мог выполняться независимо от того, куда её положили в
# память, нужен именно позиционно-независимый код (PIC).
# Флаг -fPIC говорит компилятору:
# «Сгенерируй такой машинный код, который не привязан к конкретным адресам, а
# использует относительные адреса/таблицы/регистр базового адреса».
# Всякие обращения к глобальным переменным и функциям делаются через
# специальные таблицы и относительные смещения.
# Без -fPIC код в .o может работать в обычной программе, но может быть некорректен или
# некорректен или неэффективен в .so

# -shared — создать динамическую библиотеку. Где используется: при линковке .o->.so
# Обычная линковка (без -shared) Когда ты пишешь: gcc main.o -o prog линуковщик создаёт 
# исполняемый файл добавляет стартовый код (_start),настраивает таблицы нужные для запуска 
# процесса, результат — файл, который можно запускать напрямую ./prog
# Флаг -shared говорит линковщику:«Не делай обычный исполняемый файл, сделай общую 
# библиотеку (shared object,.so)».
# В результате:не добавляется обычная точка входа (main,_start)
# создаётся объект специального формата ELF.so
# такой файл нельзя запускать напрямую, его можно загрузить только либо через  
# динамический загрузчик при запуске другой программы, либо через 
# dlopen() - ручная загрузка библиотеки.  

# -rpath — где искать .so при запуске. Где используется: при линковке программы 
# (.o->→ исполняемый файл)
#-----------------------------
# 2. Сборка основной программы
#-----------------------------

# Сборка исполняемого файла из объекта main.o и библиотеки libmy2.so
$(TARGET): main.o mylib2/libmy2.so
# Важно: -L и -l для поиска libmy2.so
	$(CC) -o $(TARGET) main.o $(LDFLAGS) $(LIBS) -Wl,-rpath,'$$ORIGIN/mylib2'

# -Wl,-rpath,'$ORIGIN/mylib2' это опция для линковщика (-Wl= «передать дальше линковщику»),
# -rpath,$ORIGIN/mylib2 говорит: «при запуске искать .so в подкаталоге mylib2
# относительно .самого бинарника».$ORIGIN подставится при запуске.
# относительно места, где лежит исполняемый файл. $$ORIGIN — это подстановка для линковщика.

# Компиляция main-файла (main.c) в объектный файл
main.o: main.c mylib2/lib2.h
	$(CC) $(CFLAGS) -c main.c -o main.o

#-----------------------------
# Очистка
#-----------------------------
clean:
	rm -f *.o $(TARGET) mylib2/*.o mylib2/libmy2.so

.PHONY: all clean

#--------------------------------------------------
# Примеры из лекции (Linux) — просто как комментарий
#--------------------------------------------------
# Ручная сборка динамической библиотеки:
#   gcc -c -fPIC lib2.c
#   gcc -shared -o libmy2.so lib2.o
#
# Линковка с библиотекой:
#   gcc -o prog2 main.c -L ./ -lmy2 -Wl,-rpath,/home/user/mylib2
#
#--------------------------------------------------
# Примеры для Windows (MinGW) — КОММЕНТАРИЙ
#--------------------------------------------------
#   gcc -c -fPIC lib2.c
#   gcc -shared -o libmy2.dll lib2.o
#
#   gcc -o prog2 main.c -L ./ \
#       c:\geekbrains.ru\Projects\C\MIPI_AC_Git\MIPI_AdvancedC\Lect3\36\libmy2.so