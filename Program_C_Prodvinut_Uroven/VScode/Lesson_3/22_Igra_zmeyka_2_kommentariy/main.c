/*
//------------------------------------------------------
//       Игра змейка продолжение
//------------------------------------------------------
1. Доработайте функционал игры зиейка. Реализуйте в игре 
ситуацию, когда змея врезается сама в себя, при этом следует 
выход из игры и выводом сообщения "THE END!" с небольшой задержкой.
При этом обычный выход из игры по нажатию F10 также с задержкой выводит
сообщение "STOP GAME!" 
2. Реализовать выход за границы экрана во все стороны, 
(при уходе за границы экрана, змейка появляется с противоположной
стороны). Согласовать скорости движения змейки в вертикальной и 
горизонтальной плоскости. (Сейчас в горизонтальной плоскости движение 
змейки медленне, чем в верикальной)
3. Запрещается разворот змейки, сразу в противоположную сторону от
текущего направления движения (она не должна есть свой хвост),
так же змейка не должна съедать сообщение о завершении игры, находящееся
в верхней части экрана (Use arrows for control. Press 'F10' for EXIT")
4. Переписать timeout через clock
*/

#include <stdio.h>      // стандартный ввод-вывод (printf, etc.)
#include <stdlib.h>     // функции работы с памятью (malloc, free)
#include <time.h>       // работа со временем (clock)
#include <ncurses.h>    // библиотека для работы с «графикой» в терминале
#include <inttypes.h>   // типы с фиксированной разрядностью (int32_t)
#include <string.h>     // функции работы со строками (strlen)
#include <unistd.h>     // POSIX-функции (здесь напрямую не нужны, но можно оставить)

//------------------------------------------------------
// Константы и перечисления
//------------------------------------------------------

// Минимальная координата Y, с которой может двигаться змейка.
// Строки 0 и 1 используются под текст/подсказки.
#define MIN_Y 2

// Перечисление направлений движения змейки и кода остановки игры.
// STOP_GAME соответствует нажатию клавиши F10 (макрос KEY_F(10) из ncurses).
enum {LEFT=1, UP, RIGHT, DOWN, STOP_GAME=KEY_F(10)};

// Разные игровые параметры и «заделы на будущее».
enum {
    MAX_TAIL_SIZE       = 100,  // максимальная длина хвоста (размер массива сегментов)
    START_TAIL_SIZE     = 3,    // начальная длина хвоста (количество видимых сегментов)
    MAX_FOOD            = 20,   // не используется (заготовка под еду)
    FOOD_EXPIRE_SECONDS = 10    // не используется (время жизни еды)
};

//------------------------------------------------------
// Структуры
//------------------------------------------------------

// Структура, описывающая коды клавиш управления змейкой.
struct control_buttons {
    int down;   // код клавиши "вниз"
    int up;     // код клавиши "вверх"
    int left;   // код клавиши "влево"
    int right;  // код клавиши "вправо"
} control_buttons;     // объявление переменной (не используется, но не мешает)

// Набор кнопок по умолчанию — стрелки клавиатуры.
struct control_buttons default_controls = {
    KEY_DOWN,  // клавиша стрелка вниз
    KEY_UP,    // клавиша стрелка вверх
    KEY_LEFT,  // клавиша стрелка влево
    KEY_RIGHT  // клавиша стрелка вправо
};

// Один сегмент хвоста: хранит только координаты на экране.
typedef struct tail_t {
    int x;      // x-координата сегмента хвоста
    int y;      // y-координата сегмента хвоста
} tail_t;

// Структура, описывающая состояние змейки целиком.
typedef struct snake_t {
    int x;                     // x-координата головы змейки
    int y;                     // y-координата головы змейки
    int direction;             // текущее направление движения (LEFT/RIGHT/UP/DOWN)
    size_t tsize;              // текущая длина хвоста (количество сегментов, которые рисуем)
    tail_t *tail;              // указатель на динамический массив сегментов хвоста
    struct control_buttons controls; // назначенные клавиши управления для этой змейки
} snake_t;

//------------------------------------------------------
// Инициализация
//------------------------------------------------------

// Инициализация массива хвоста начальными координатами (0,0).
// Это «пустое» состояние — хвост визуально ещё не появился.
void initTail(tail_t t[], size_t size)
{
    tail_t init_t = {0, 0};         // создаём сегмент с координатами (0,0)
    for (size_t i = 0; i < size; i++) // проходим по всем элементам массива
        t[i] = init_t;              // инициализируем каждый сегмент значением init_t
}

// Инициализация головы змейки: начальные координаты и направление.
void initHead(snake_t *head, int x, int y)
{
    head->x = x;                    // устанавливаем начальную x-координату головы
    head->y = y;                    // устанавливаем начальную y-координату головы
    head->direction = RIGHT;        // по умолчанию змейка двигается вправо
}

// Полная инициализация змейки:
// - выделение памяти под хвост,
// - обнуление хвоста,
// - установка головы,
// - назначение управления.
void initSnake(snake_t *head, size_t size, int x, int y)
{
    tail_t* tail = (tail_t*) malloc(MAX_TAIL_SIZE * sizeof(tail_t)); // выделяем память под MAX_TAIL_SIZE сегментов
    initTail(tail, MAX_TAIL_SIZE);                                   // обнуляем весь хвост (все сегменты в (0,0))

    initHead(head, x, y);                                            // устанавливаем начальные координаты и направление головы

    head->tail = tail;                                               // присваиваем указатель на хвост змейке
    head->tsize = size;                                              // задаём текущую длину хвоста (START_TAIL_SIZE)
    head->controls = default_controls;                               // назначаем стандартные клавиши управления
}

//------------------------------------------------------
// Проверка на столкновение с собой
//------------------------------------------------------

// Проверяем, не совпадает ли позиция головы с каким-либо сегментом хвоста.
// Если да — значит, змейка врезалась сама в себя.
int isSelfCollision(const snake_t *s)
{
    for (size_t i = 0; i < s->tsize; ++i)           // проходим по всем сегментам хвоста
    {
        if (s->tail[i].x == s->x &&                // сравниваем x головы и x сегмента
            s->tail[i].y == s->y)                  // и y головы и y сегмента
            return 1;                              // если совпало — сообщаем о столкновении
    }
    return 0;                                      // столкновения нет
}

//------------------------------------------------------
// Движение головы
//------------------------------------------------------

// Смещает голову змейки на одну клетку в текущем направлении.
// При выходе за границы окна — «зацикливает» координату
// (выход с одной стороны — появление с противоположной).
void go(snake_t *head)
{
    char ch = '@';          // символ, которым рисуем голову
    int max_x = 0, max_y = 0;   // переменные для размеров окна

    getmaxyx(stdscr, max_y, max_x); // получаем текущее количество строк (max_y) и столбцов (max_x)
    max_x -= 1;                     // индекс последней колонки (нумерация от 0)
    max_y -= 1;                     // индекс последней строки (нумерация от 0)

    // Изменяем координаты головы в зависимости от направления движения.
    switch (head->direction)
    {
        case LEFT:                                      // движение влево
            if (head->x <= 0)                           // если выходим за левую границу
                head->x = max_x;                        // переносим голову к правой границе
            else
                head->x--;                              // иначе просто уменьшаем x на 1
            break;
        case RIGHT:                                     // движение вправо
            if (head->x >= max_x)                       // если выходим за правую границу
                head->x = 0;                            // переносим голову к левой границе
            else
                head->x++;                              // иначе увеличиваем x на 1
            break;
        case UP:                                        // движение вверх
            if (head->y <= MIN_Y)                       // если выходим за верхнюю игровую границу
                head->y = max_y;                        // переносим голову вниз экрана
            else
                head->y--;                              // иначе уменьшаем y на 1
            break;
        case DOWN:                                      // движение вниз
            if (head->y >= max_y)                       // если выходим за нижнюю границу
                head->y = MIN_Y;                        // переносим голову к верхней игровой границе
            else
                head->y++;                              // иначе увеличиваем y на 1
            break;
        default:                                        // на случай некорректного направления
            break;
    }

    mvprintw(head->y, head->x, "%c", ch);               // рисуем символ головы '@' в новой позиции
}

//------------------------------------------------------
// Движение хвоста
//------------------------------------------------------
/*
 head_prev_x, head_prev_y — координаты головы ДО движения.
 Первый сегмент хвоста должен занять именно эти координаты,
 чтобы хвост «шёл» сразу за головой без отставания.
*/
void goTail(snake_t *head, int head_prev_x, int head_prev_y)
{
    char ch = '*';                                       // символ хвоста

    mvprintw(head->tail[head->tsize - 1].y,              // y последнего сегмента хвоста
             head->tail[head->tsize - 1].x,              // x последнего сегмента хвоста
             " ");                                       // затираем последний сегмент пробелом

    for (size_t i = head->tsize - 1; i > 0; i--)         // сдвигаем сегменты с конца к началу
    {
        head->tail[i] = head->tail[i - 1];               // каждый сегмент принимает координаты предыдущего
    }

    head->tail[0].x = head_prev_x;                       // первый сегмент хвоста встаёт туда,
    head->tail[0].y = head_prev_y;                       // где была голова до перемещения

    for (size_t i = 0; i < head->tsize; ++i)             // перерисовываем все сегменты хвоста
    {
        if (head->tail[i].x || head->tail[i].y)          // не рисуем сегменты с координатами (0,0)
            mvprintw(head->tail[i].y,                    // y сегмента
                     head->tail[i].x,                    // x сегмента
                     "%c", ch);                          // рисуем символ хвоста '*'
    }
}

//------------------------------------------------------
// Изменение направления (с запретом разворота на 180°)
//------------------------------------------------------

// Меняет направление движения змейки в зависимости от нажатой клавиши.
// Запрещает поворачиваться сразу в противоположную сторону.
void changeDirection(snake_t* snake, const int32_t key)
{
    int new_dir = snake->direction;                      // по умолчанию — текущее направление

    if (key == snake->controls.down)                     // если нажата клавиша "вниз"
        new_dir = DOWN;                                  // новое направление — вниз
    else if (key == snake->controls.up)                  // если "вверх"
        new_dir = UP;                                    // новое направление — вверх
    else if (key == snake->controls.right)               // если "вправо"
        new_dir = RIGHT;                                 // новое направление — вправо
    else if (key == snake->controls.left)                // если "влево"
        new_dir = LEFT;                                  // новое направление — влево
    else
        return;                                          // другие клавиши игнорируем, выходим из функции

    // Проверяем, не пытается ли змейка развернуться на 180°.
    if ((snake->direction == LEFT  && new_dir == RIGHT) || // было LEFT, хотят RIGHT
        (snake->direction == RIGHT && new_dir == LEFT ) || // было RIGHT, хотят LEFT
        (snake->direction == UP    && new_dir == DOWN ) || // было UP, хотят DOWN
        (snake->direction == DOWN  && new_dir == UP   ))   // было DOWN, хотят UP
    {
        return;                                           // игнорируем такой поворот
    }

    snake->direction = new_dir;                           // сохраняем новое допустимое направление
}

//------------------------------------------------------
// main — точка входа в программу
//------------------------------------------------------
int main()
{
    snake_t* snake = (snake_t*) malloc(sizeof(snake_t));  // выделяем память под структуру змейки

    initSnake(snake, START_TAIL_SIZE, 10, MIN_Y + 1);     // инициализируем змейку: хвост, координаты головы, управление

    initscr();                                            // инициализируем ncurses (переход в специальный режим терминала)
    keypad(stdscr, TRUE);                                 // включаем обработку функциональных клавиш и стрелок
    raw();                                                // отключаем буферизацию ввода
    noecho();                                             // не выводим введённые символы на экран
    curs_set(FALSE);                                      // скрываем курсор

    mvprintw(0, 0, "Use arrows for control. Press 'F10' for EXIT"); // выводим подсказку в верхней строке

    timeout(0);                                           // делаем getch() неблокирующим (возвращает ERR, если клавиша не нажата)

    int key_pressed = 0;                                  // переменная для кода последней нажатой клавиши
    int game_over = 0;                                    // флаг: 1 — змейка врезалась в себя, 0 — пока нет

    const int TICK_MS = 150;                              // период одного шага змейки в миллисекундах
    clock_t last_tick = clock();                          // время последнего шага (берём текущее время)

    mvprintw(snake->y, snake->x, "@");                    // рисуем голову змейки в начальной позиции
    refresh();                                            // обновляем экран, чтобы всё отобразилось

    while (!game_over && key_pressed != STOP_GAME)        // основной игровой цикл: пока нет столкновения и не нажата F10
    {
        key_pressed = getch();                            // считываем нажатую клавишу (или ERR, если ничего не нажато)

        changeDirection(snake, key_pressed);              // пытаемся изменить направление движения змейки

        clock_t now = clock();                            // текущее время
        double elapsed_ms =                               // вычисляем, сколько миллисекунд прошло
            (double)(now - last_tick) * 1000.0 / CLOCKS_PER_SEC;

        if (elapsed_ms >= TICK_MS)                        // если прошло больше TICK_MS, пора двигать змейку
        {
            last_tick = now;                              // запоминаем время этого шага

            int old_x = snake->x;                         // сохраняем старую x-координату головы
            int old_y = snake->y;                         // сохраняем старую y-координату головы

            goTail(snake, old_x, old_y);                  // двигаем хвост: первый сегмент встаёт на старое место головы

            go(snake);                                    // двигаем голову в новом направлении

            if (isSelfCollision(snake))                   // проверяем, не врезалась ли голова в хвост
                game_over = 1;                            // если да — помечаем, что игра окончена из-за столкновения

            refresh();                                    // обновляем экран после изменений
        }
    }

    if (game_over)                                        // если игра окончилась из-за столкновения с хвостом
    {
        int max_x, max_y;                                 // переменные для размеров окна
        getmaxyx(stdscr, max_y, max_x);                   // получаем высоту и ширину окна

        const char *msg = "THE END!";                     // текст сообщения при столкновении
        mvprintw(max_y / 2,                               
                 (max_x - (int)strlen(msg)) / 2,          // выводим сообщение по центру по горизонтали
                 "%s", msg);                              // выводим строку msg
        refresh();                                        // отображаем надпись

        clock_t start = clock();                          // запоминаем время начала ожидания
        while ((double)(clock() - start) / CLOCKS_PER_SEC < 2) // ждём примерно 2 секунды
        {
            // Пустой цикл ожидания (busy-wait).
        }
    }
    else if (key_pressed == STOP_GAME)                    // иначе, если был нажат F10 (обычный выход)
    {
        int max_x, max_y;                                 // переменные для размеров окна
        getmaxyx(stdscr, max_y, max_x);                   // получаем размеры окна

        const char *msg = "STOP GAME!";                   // текст сообщения при штатном выходе
        mvprintw(max_y / 2,
                 (max_x - (int)strlen(msg)) / 2,          // выводим сообщение по центру по горизонтали
                 "%s", msg);                              // выводим строку msg
        refresh();                                        // отображаем надпись

        clock_t start = clock();                          // запоминаем время начала ожидания
        while ((double)(clock() - start) / CLOCKS_PER_SEC < 2) // ждём примерно 2 секунды
        {
            // Пустой цикл ожидания.
        }
    }

    free(snake->tail);                                    // освобождаем память, выделенную под массив хвоста
    free(snake);                                          // освобождаем память под структуру змейки
    endwin();                                             // завершаем работу ncurses, возвращаем терминал в нормальный режим

    return 0;                                             // успешное завершение программы
}