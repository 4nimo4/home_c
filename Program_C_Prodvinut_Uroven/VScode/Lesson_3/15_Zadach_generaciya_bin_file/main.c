/*
//------------------------------------------------------
// Генерация бинарного файла из wchar_t‑символов.
//------------------------------------------------------
Написать программу, которая обрабатывает бинарный файл, состоящий из wchar_t 
символов и копирует всё содержимое данного файла в текстовый файл формата ASCII. 
Гарантируется, что все символы помещаются в 1 байт.

Этот файл — первая часть задачи: он создаёт бинарный файл input_wchar.txt,
содержащий «сырые» wide‑символы (wchar_t) без терминатора L'\0'.

Кратко по назначению:

Программа не пишет обычный текст "Hello" как ASCII/UTF‑8, 
она пишет последовательность wchar_t — это двоичное представление wide‑строки.
В результате input_wchar.txt содержит ровно N * sizeof(wchar_t) байт, 
где N — количество символов 'H','e','l','l','o' (без завершающего wide‑нуля).
Следующая программа по условию задачи будет этот файл читать как набор
wchar_t и перекладывать каждый символ в 1‑байтовый ASCII‑выходной файл.
*/

// Пример бинарного файла
#include <stdio.h>   // FILE, fopen, fclose, fwrite
#include <stdlib.h>  // стандартные функции, здесь по сути не обязательны
#include <wchar.h>   // тип wchar_t и wide‑строки

int main(void) 
{
    FILE *fin;                 // Указатель на файловый поток (output-файл)
    
    // Широкая строка (wide‑строка). Тип wchar_t:
    // на Linux обычно 4 байта (UTF-32), на Windows — 2 байта (UTF-16).
    // Литерал L"Hello" — это массив wchar_t, содержащий символы 'H','e','l','l','o', L'\0'.
    wchar_t s[] = L"Hello";

    // Открываем файл "input_wchar.txt" для записи.
    // Используется текстовый режим "w", но мы будем писать двоичные данные 
    //с помощью fwrite.
    // На POSIX-системах (Linux) разницы между "w" и "wb" почти нет, но по смыслу
    // корректнее было бы "wb" (binary). Для учебного примера это не критично.
    fin = fopen("input_wchar.txt", "w");
    if (!fin) {
        perror("fopen");
/*
perror("fopen"); — это вызов стандартной функции из <stdio.h>
, которая выводит сообщение об ошибке, связанной с последним системным 
вызовом/функцией ввода‑вывода.

Разбор:
perror("fopen"); perror — функция void perror(const char *s);
Она печатает в stderr строку вида <s>: <текст_ошибки_по_errno>\n
где <s> — то, что ты передал (здесь "fopen"), <текст_ошибки_по_errno>
— человекочитаемое описание ошибки, соответствующей текущему значению errno.
В контексте:
fin = fopen("input_wchar.txt", "w");
if (!fin) {
    perror("fopen");
    return 1;
}
Если fopen вернул NULL (ошибка открытия файла: нет прав, нет диска, нет каталога и т.п.),
perror("fopen") напечатает что‑то вроде fopen: No such file or directory или
fopen: Permission denied в зависимости от конкретной причины (значения errno).

Итого:
perror — удобный способ быстро вывести диагностическое сообщение об ошибке, 
связанной с последним неудачным системным вызовом или функцией стандартной 
библиотеки (fopen, read, write, malloc и т.д.).
Чтобы им пользоваться, достаточно #include <stdio.h>; 
errno задаётся сам внутри библиотечных вызовов.
*/
        return 1;
    }

    // Проходим по wide‑строке s до широкого нулевого символа L'\0'.
    // s[i] в условии цикла интерпретируется как "пока символ не нулевой".
    for (size_t i = 0; s[i]; i++) 
    {
        // Записываем один символ wchar_t в файл.
        // fwrite пишет "сырые" байты без каких‑либо преобразований.
        //   &s[i]          — адрес текущего wchar_t
        //   sizeof(wchar_t) — размер одного wide‑символа в байтах
        //   1              — количество элементов
        //   fin            — файловый поток
        fwrite(&s[i], sizeof(wchar_t), 1, fin);
    }

    // Закрываем файл, сбрасываем буферы на диск.
    fclose(fin);
    
    return 0;
}