/*
//------------------------------------------------------
// Пример кодировки UTF-8
//------------------------------------------------------
Чтобы декодировать UTF8, нужно посмотреть первые 
(самые старшие) 2 бита каждого байта.

➔ Если они «01» или «00», — это 8-битный символьный код,

➔ если они «11», — это первый байт многобайтовой последовательности.

➔ Если они равны «10», то это один байт внутри многобайтовой последовательности.
*/

#include <stdio.h>    // printf, puts и т.д.
#include <locale.h>   // setlocale, константы LC_*
#include <inttypes.h> // стандартные целочисленные типы: uint8_t, uint32_t и т.д.
#include <wchar.h>    // wchar_t, wprintf, функции для работы с wide-строками

int main(void)
{
    /*
      В этом примере мы вручную задаём байты UTF-8
      для строки "АБ" и смотрим на них с разных сторон.

      В UTF-8 каждый символ "А" (U+0410) кодируется двумя байтами: 0xD0 0x90
      а "Б" (U+0411) — 0xD0 0x91.

      Итого для "АБ" получаем байтовую последовательность:
         D0 90 D0 91
      и завершающий нулевой байт 0x00, чтобы это была корректная C-строка.
    */

    // Массив байтов (тип uint8_t) — представление строки "АБ" в UTF-8:
    //  0xd0, 0x90 — "А"
    //  0xd0, 0x91 — "Б"
    //  0x00       — терминатор строки '\0'
    uint8_t ch[]  = {0xd0, 0x90, 0xd0, 0x91, 0};   // "АБ" в UTF-8

    // Здесь мы просто берём те же 4 байта и интерпретируем их как одно
    // 32-битное целое число (для демонстрации того, как байты можно
    // "слепить" в слово). Никакой "магии Unicode" здесь нет — это
    // чисто битовое представление.
    uint32_t ch32[] = {0x91d090d0, 0};             // те же байты D0 90 D0 91 в одном слове

    /*
      Устанавливаем локаль. Пустая строка "" значит:
      "использовать локаль, указанную в переменных окружения (LANG, LC_* и т.д.)".

      Это важно, чтобы терминал и стандартные функции вывода корректно
      обрабатывали UTF-8. Если локаль останется "C", русские буквы могут
      отображаться некорректно или вообще не выводиться как надо.
    */
    char *res = setlocale(LC_ALL, "");
    printf("setlocale -> %s\n", res);

    /*
      Печатаем байты по отдельности в шестнадцатеричном виде.
      %x — формат для беззнакового int в hex.
      Каждый ch[i] — uint8_t, при передаче в printf он автоматически
      промотируется до int, а мы выводим его как шестнадцатеричное число.
    */
    printf("bytes: %x %x %x %x\n", ch[0], ch[1], ch[2], ch[3]); // ожидаем: d0 90 d0 91

    /*
      Теперь хотим вывести эти байты как строку UTF-8.

      Важно:
        - ch — это массив uint8_t, но printf с форматом %s ожидает char*.
        - Поэтому приводим (char *)ch, чтобы сказать printf:
            "считай это указателем на C-строку (последовательность байт до '\0')".

      Если:
        - исходный файл сохранён в UTF-8,
        - терминал настроен на UTF-8,
        - локаль установлена на что-то вроде ru_RU.UTF-8 или через "",
      то на экране вы увидите русские буквы "АБ".
    */
    printf("as UTF-8 string: %s\n", (char *)ch);   // "АБ", при корректной UTF-8 локали/терминале

    /*
      Печатаем 32-битное слово, в котором хранятся те же байты.
      Это просто демонстрация: как наш набор байт выглядит как одно число.

      Порядок байтов (endianness) здесь зависит от архитектуры,
      но для демонстрации мы берём константу 0x91d090d0, которая в памяти
      (на little-endian x86_64) будет лежать как байты D0 90 D0 91 —
      те самые байты UTF-8.
    */
    printf("32-bit word: %x\n", ch32[0]);          // 91d090d0

    return 0;
}