/*
//------------------------------------------------------
// Чтение  бинарного wchar_t‑файла и запись в ASCII‑текстовый.
//------------------------------------------------------
Задача: прочитать бинарный файл из wchar_t
, сконвертировать каждый символ в 1‑байтовый (ASCII) и записать в текстовый файл.

Комментарий по шагам:

fopen("input_wchar.txt", "rb") — открываем бинарный файл, созданный второй программой.
while (fread(&tmp, sizeof(wchar_t), 1, fin) == 1) читаем по одному символу
wchar_t из файла, цикл идёт, пока удаётся прочитать ровно 1 элемент (пока не конец 
файла).
arr_out[i++] = tmp; каждый wchar_t (широкий символ) записывается в 1‑байтовый массив 
как int8_t, по условию задачи «гарантируется, что все символы помещаются в 1 байт», 
значит: это будут только ASCII‑символы ('H', 'e', 'l', 'o', ...), верхние байты
wchar_t равны 0 и не мешают. int8_t arr_out[100] = {0}; массив заранее заполнен нулями,
мы записываем только первые i байт букв, а хвост остаётся нулями, поэтому в arr_out
получается корректная C‑строка (с '\0' после последнего символа).
fprintf(fout, "%s", arr_out); воспринимает arr_out как char* и пишет её 
в текстовый файл output_ascii.txt в виде обычной ASCII‑строки.
Это реализация задачи: «скопировать содержимое бинарного файла из wchar_t 
в текстовый ASCII‑файл».
*/

#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <inttypes.h>  // для int8_t

int main(void)
{
    FILE *fin;   // Указатель на входной (бинарный) файл с wchar_t
    FILE *fout;  // Указатель на выходной текстовый файл (ASCII)

    // В эту переменную будем по одному читать широкие символы из файла.
    wchar_t tmp;

    // Выходной буфер для ASCII-строки.
    // int8_t по сути эквивалентен знаковому char, но мы явно показываем,
    // что рассчитываем на 1 байт на символ.
    // Инициализация {0} заполняет массив нулями — сразу есть завершающий '\0'.
    int8_t arr_out[100] = {0};

    // Текущая позиция записи в arr_out.
    // Сколько символов уже скопировали.
    size_t i = 0;

    // Открываем входной файл, созданный предыдущей программой, в бинарном режиме.
    // "rb" важно использовать на системах, где текстовый и бинарный режим различаются
    // (Windows). На Linux разница меньше, но по смыслу это правильно.
    fin = fopen("input_wchar.txt", "rb");
    if (!fin) {
        // Если не удалось открыть файл — выводим системное сообщение об ошибке
        // и выходим с кодом 1.
        perror("fopen input_wchar.txt");
        return 1;
    }

    // Читаем файл по одному широкому символу wchar_t.
    // fread возвращает количество успешно прочитанных элементов.
    // Условие == 1 значит: прочитан ровно один wchar_t.
    //
    // Вторая часть условия защищает нас от переполнения буфера:
    // i < sizeof arr_out - 1  → оставляем место под завершающий '\0'.
    //
    // По условию задачи «гарантируется, что все символы помещаются в 1 байт»,
    // то есть они лежат в диапазоне ASCII, и мы можем просто взять младший байт
    // каждого wchar_t и сохранить его в одном байте выходного массива.
    while (fread(&tmp, sizeof(wchar_t), 1, fin) == 1 && i < sizeof arr_out - 1) 
    {
        arr_out[i++] = (int8_t)tmp;   // берём младший байт wide-символа
    }

    // Закрываем входной файл — данные уже скопированы в память.
    fclose(fin);

    // Открываем выходной текстовый файл для записи ASCII-строки.
    fout = fopen("output_ascii.txt", "w");
    if (!fout) {
        perror("fopen output_ascii.txt");
        return 1;
    }

    // arr_out сейчас содержит обычную C-строку:
    //   [символы][0][0][0]...
    // так как массив был обнулён, а мы записали только первые i байт.
    //
    // Приводим arr_out к (char*) для ясности, потому что %s ожидает char*.
    fprintf(fout, "%s", (char *)arr_out);

    // Закрываем выходной файл, сбрасывая буфер на диск.
    fclose(fout);

    return 0;   // Успешное завершение
}