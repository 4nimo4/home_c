/*
//------------------------------------------------------
// Строковые функции из string.h
//------------------------------------------------------
Держитесь подальше от strcpy, strcat, которые часто приводят к
неэффективности и уязвимостям. В этом примере продемонстрирована ошибка
buffer overflow для функции strcpy. Используйте strncpy и strncat.
*/

#include <stdio.h>
#include <string.h>

// ОШИБКА! Переполнение буфера (демонстрация)

int main() 
{
    // Вариант безопасного размера строки:
    // char str1[] = "Small string.";

    // Сейчас строка ДЛИННАЯ, чтобы показать проблему переполнения:
    char str1[] = "This is very big string.";

    // МАЛЕНЬКИЙ буфер — всего 6 символов (5 + '\0')
    char str2[6];

    // Опасный вариант (закомментирован):
    // strcpy(str2, str1);
    /*
       Если раскомментировать строку выше, произойдёт переполнение буфера:
       - strcpy скопирует ВСЮ строку str1 в str2, не проверяя размер str2
       - так как str1 длиннее 6 символов, запись выйдет за границы массива str2
       - это и есть buffer overflow: затирание чужой памяти.
    */

    // Безопасный вариант: ограничиваем количество копируемых символов
    strncpy(str2, str1, sizeof(str2) - 1);
    /*
       Здесь мы копируем не больше, чем sizeof(str2) - 1 символ:
       - sizeof(str2) == 6
       - 6 - 1 = 5, копируем только 5 символов
       - например, "This "
       НО: strncpy НЕ гарантирует, что добавит завершающий '\0',
       если исходная строка длиннее. Поэтому после strncpy обычно
       руками добавляют терминатор:
           str2[sizeof(str2) - 1] = '\0';
       В данной программе поведение может быть корректным, но лучше всегда
       явно завершать строку.
    */
    str2[sizeof(str2) - 1] = '\0';
    // Выводим исходную строку (длинную)
    puts(str1);

    // Выводим результат копирования в маленький буфер
    puts(str2);

    return 0;
}