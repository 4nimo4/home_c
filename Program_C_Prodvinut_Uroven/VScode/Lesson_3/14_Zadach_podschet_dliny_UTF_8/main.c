/*
//------------------------------------------------------
// Анализируем все байты
//------------------------------------------------------
Анализируем все байты кроме тех, которые являются внутренними байтами UTF8 символа. 
Такие байты удовлетворяют маске 0b10xxxxxx, их необходимо пропускать 
при подсчете длины.

В UTF‑8 все продолжения многобайтных символов имеют вид
10xxxxxx (0x80..0xBF), первый байт символа (1–4‑байтового) не имеет такой формы.
Маска 0b11000000 выделяет два старших бита если они 10 (0b10000000), то это 
продолжение (10xxxxxx), если что‑то другое (0xxxxxxx, 110xxxxx, 1110xxxx, 11110xxx), 
то это начало нового символа.
Условие if( (*s & 0b11000000) != 0b10000000 ) означает «если байт не начинается с
10, то это первый (и единственный) байт символа» → считаем его как один символ.
*/

#include <stdio.h>    // printf

// Функция для подсчёта длины UTF-8 строки в "символах", а не в байтах
size_t strlenutf8(char *s) 
{
    size_t length = 0;      // Счётчик символов (code points)
    while (*s) 
    {            // Идём по строке до нулевого байта '\0'
        /*
          В UTF-8:

            - Все продолжения многобайтных символов имеют вид:
                10xxxxxx  (диапазон 0x80..0xBF)

            - Любой первый байт символа (и однобайтного ASCII, и начала
              многобайтного UTF-8) НЕ имеет такой формы:
                0xxxxxxx  (ASCII, 1 байт)
                110xxxxx  (начало 2-байтовой последовательности)
                1110xxxx  (начало 3-байтовой последовательности)
                11110xxx  (начало 4-байтовой последовательности)

          Маска 0xC0 (1100 0000b) выделяет два старших бита.

          Если (*s & 0xC0) == 0x80, то байт вида 10xxxxxx → это
          ПРОДОЛЖАЮЩИЙся байт, а не начало нового символа,
          значит, его НЕ считаем как отдельный символ.

          Если НЕ равно 0x80 — это первый (и/или единственный) байт
          нового символа → увеличиваем счётчик.
        */
        if ( (*s & 0xC0) != 0x80 ) 
        {
            ++length;       // нашли начало нового символа
        }
        ++s;                // переходим к следующему байту
    }
    return length;
}

int main(void)
{
    // Строка UTF-8 с кириллицей: каждый русский символ занимает 2 байта
    char s[]  = "Привет";

    // Обычная ASCII-строка: каждый символ = 1 байт
    char s2[] = "Hello";

    // strlenutf8 считает именно количество символов (кодовых точек),
    // а не байтов, поэтому:
    //  - для "Hello" результат совпадает с strlen
    //  - для "Привет" число символов меньше, чем количество байтов
    printf("len s  = %zu\n", strlenutf8(s));   // количество букв в "Привет"
    printf("len s2 = %zu\n", strlenutf8(s2));  // количество букв в "Hello"

    return 0;
}