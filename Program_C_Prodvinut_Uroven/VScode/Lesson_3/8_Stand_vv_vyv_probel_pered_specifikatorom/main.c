/*
//------------------------------------------------------
// Стандартный ввод/вывод
//------------------------------------------------------
Знак пробела перед спецификатором — " %c". Удобно для системы
меню.
*/

#include <stdio.h>

// Глобальные строки здесь не используются, но просто объявлены
char s1[] = "Hello ";
char s2[] = "world!";

int main(void) 
{
    char c;   // Переменная для ввода одного символа

    printf("===Enter q to quit===\n");

    do
    {
        printf("Enter a symbol\n");

        // ВАЖНО: пробел перед %c — " %c"
        // scanf(" %c", &c);
        //
        // Пробел говорит scanf: "пропусти все пробельные символы"
        // (пробел, перевод строки '\n', табуляцию и т.п.)
        // Это удобно в меню, где после нажатия Enter остаётся '\n' в буфере.
        //
        // Без пробела scanf("%c", &c) сразу читает этот '\n', и
        // получается эффект "пропуска" ввода и перескока через запрос.

        scanf(" %c", &c);   // Корректное чтение одиночного символа для меню

        /*
        Пример работы с " %c":
        ===Enter q to quit===
        Enter a symbol
        4
        4
        Enter a symbol
        5
        5
        ...
        Enter a symbol
        q
        q
        */

        // Для сравнения: если использовать scanf("%c", &c);
        // то подряд будут считываться и '\n' после нажатия Enter,
        // что визуально выглядит, как будто программа "перескакивает" запрос ввода.

        printf("%c\n", c);  // Выводим введённый символ и перевод строки
    }
    while (c != 'q');       // Цикл повторяется, пока не введут букву 'q'

    return 0;
}
/*
//------------------------------------------------------
// scanf - обработка спецификаторов 
//------------------------------------------------------
Разберём, как scanf обрабатывает пробелы, табы и переводы строк в форматной строке, 
и чем отличается" %c" от "%c"," %d" от "%d" и т.д.

1. Общие правила про «пробельные» символы
К пробельным (whitespace) относятся:
пробел' ' табуляция'\t' перевод строки'\n' возврат каретки'\r'
вертикальная табуляция, форм‑фид и т.п.
scanf обрабатывает их по разному в зависимости от форматного спецификатора.

2. Большинство спецификаторов САМИ пропускают пробелы
Для таких спецификаторов, как: %d, %i, %u, %f, %lf, %s и др. scanf по стандарту:
Сначала пропускает все пробельные символы (пробелы, \n, \t, …),
Потом начинает читать нужные данные.
Пример:

int x;
scanf("%d", &x);
Если в буфере ввода (stdin) такие символы: \n\n   123\n то scanf("%d")
пропустит два перевода строки и три пробела, прочитает 123, остановится на
\n после 123. Поэтому для чисел нам не нужно писать " %d" — "%d" и так сам 
«съест» пробелы/энтеры перед числом.

3. Спецификатор %c ведёт себя иначе %c — читает ровно один байт из потока ввода:
НЕ пропуская никакие пробелы или \n перед этим, любой символ (включая пробел, таб,
\n) считается валидным.
char c;
scanf("%c", &c);
Если пользователь ввёл: 4↵ в потоке будет '4','\n'.

Первый scanf("%c", &c); прочитает '4'. Второй scanf("%c", &c); прочитает уже '\n'
(перевод строки). Вот откуда «проскальзывание» меню.

4. Что делает пробел в " %c" Формат " %c" — это не просто %c, а ' '   %c Пробел 
в форматной строке scanf — это шаблон пробельного символа:
«Пропусти все подряд идущие пробельные символы (пробелы, \n, \t, ...)».
То есть scanf(" %c", &c); делает две вещи:
Сначала пропускает все пробелы / переводы строки / табы, оставшиеся во входном потоке.
Потом читает следующий символ (уже не пробельный) в c.
Именно поэтому в меню scanf(" %c", &c); ведёт себя «правильно»: он игнорирует '\n'
после нажатия Enter и ждёт следующий реальный символ.

5. Сравнение " %c" и "%c" Представим такой код (пример из твоей программы):
do {
    printf("Enter a symbol\n");
    scanf(" %c", &c);
    printf("%c\n", c);
} while (c != 'q');
Пусть пользователь нажимает 4↵ 5↵ q↵
Вариант 1:
scanf(" %c", &c); Нажимает 4↵ → поток '4', '\n' пробел в формате " %c" пропускает 
ВСЕ пробельные (сначала нет, потом \n), %c читает '4'. Нажимает 5↵ → поток '5',
'\n' пробел пропускает \n, %c читает '5'. Нажимает q↵ → читается 'q', цикл заканчивается.
Выглядит идеально: каждое приглашение — один ввод символа.

Вариант 2:
scanf("%c", &c); Нажимает 4↵ → первый scanf("%c") читает '4'.
На следующей итерации цикла в потоке уже лежит '\n' от предыдущего Enter.
scanf("%c") тут же читает его, не дожидаясь нового ввода.
Поэтому запросы «Enter a symbol» начинают как будто «перескакиваться» через раз.

6. Пробелы с другими спецификаторами
6.1. %d и " %d"
int x;
scanf("%d", &x);   // и так пропускает пробелы и \n
scanf(" %d", &x);  // ведёт себя так же (пробел в формате дополнительно указывает
 тоже пропусти) Разницы почти нет, потому что %d
и так скипает пробельные символы до первой цифры или знака.

6.2. %s и " %s" %s (без длины — опасен, но про это отдельно) тоже:
пропускает пробелы/переводы строки до первого не‑пробельного символа;
читает до следующего пробельного. Поэтому:
char buf[100];
scanf("%s", buf);
scanf(" %s", buf);
в обычных случаях ведут себя одинаково.

7. Когда ещё полезен пробел в формате В текстовых меню, когда ты читаешь одиночные 
символы команд (q, n, y, 1, 2 и т.д.). Всегда, когда используешь %c и не хочешь получать
'\n' из предыдущего ввода.
Типичный паттерн:
char cmd;
printf("[q]uit, [n]ext: ");
scanf(" %c", &cmd);

8. Строки формата и обычные пробелы
Важно различать, пробелы в формате scanf("  %d  %c") — это инструкции: 
«пропусти любое количество пробельных в этом месте»;
непробельные символы (например,"ABC%d"), тогда scanf будет ожидать именно A, B, C
в потоке ввода.
Пример:

scanf("A %d B", &x); ожидает, что во вводе будет буква A, потом любые пробелы,
потом число, потом любые пробелы, потом буква B.
9. Резюме
%d, %f, %s сами пропускают пробелы/переводы строки перед значением. 
%c — нет, он читает любой следующий байт, в том числе '\n'.
Формат " %c" сначала пропускает все пробельные символы (включая \n),
потом читает реальный символ, идеально подходит для меню и одиночного ввода символа.
Пробелы в строке формата scanf — не «буквальные» пробелы, а команда 
«пропустить все пробельные символы здесь».


Покажу пошагово, что оказывается во входном буфере и что именно считывает каждый
scanf. Возьмём примеры с %c и " %c", потому что там разница наиболее заметна.

Будем считать, что пользователь вводит с клавиатуры символы и нажимает Enter.
Enter даёт в поток ввода символ '\n'.

1. Пример с scanf("%c", &c); — «перескакивающее» меню
Код:

#include <stdio.h>

int main(void)
{
    char c;

    printf("===Enter q to quit===\n");

    do {
        printf("Enter a symbol\n");
        scanf("%c", &c);
        printf("You entered: '%c'\n", c);
    } while (c != 'q');

    return 0;
}
Шаг 1 — первый ввод: пользователь печатает 4 и нажимает Enter Пользователь вводит
4↵ Во входном буфере по порядку'4'
,
'\n'

Выполнение:

scanf("%c", &c); читает первый байт →'4' в буфере остаётся '\n'
printf("You entered: '%c'\n", c); → выводит 4.
Следующая итерация цикла.
Шаг 2 — вторая итерация, пользователь пока ещё ничего нового не ввёл
Состояние ввода в буфере stdin всё ещё лежит «старый» '\n' (Enter от предыдущего раза).
Программа:

printf("Enter a symbol\n");
scanf("%c", &c);
scanf("%c", &c);
видит в буфере уже готовый '\n' и сразу его читает, не дожидаясь нового ввода.
в буфере больше ничего нет.
printf("You entered: '\n'\n"); — вывод пустой строки, выглядит как «ничего не ввёл».
Ты думаешь: «Я ещё ничего не набирал, а программа уже пошла дальше» — это и есть 
тот самый «перескок».

Шаг 3 — пользователь наконец вводит 5↵
Теперь буфер '5', '\n'. Снова цикл scanf("%c", &c); читает '5', в буфере остаётся'\n'.
В следующей итерации опять мгновенно схватывается '\n'.
Так и получается эффект один раз ввёл число, следующий запрос «перескакивает».

2. Пример с
scanf(" %c", &c); — корректное меню Тот же код, но scanf(" %c", &c);
То есть добавлен пробел в строке формата. Что значит " %c"
Пробел в формате → «пропусти все пробельные символы (' ', '\n', '\t', …)».
%c → прочитать следующий байт как символ.
Итого:
scanf(" %c", &c); делает:
пропускает все пробелы/переводы строк в буфере ввода;
читает следующий не-пробельный символ.
Шаг 1 — пользователь вводит 4↵ Буфер '4', '\n'.

scanf(" %c", &c); пробельная часть " " пока пробельных символов нет, сразу переходим к
%c; %c читает '4'; '\n' остаётся в буфере (важно!). Выводится 4.
Следующая итерация.
Шаг 2 — новая итерация, в буфере лежит '\n' от прошлого ввода scanf(" %c", &c);
сначала " " пропускает все пробельные символы. В буфере есть '\n' , его выбрасывают.
буфер становится пустым. теперь %c ждёт новый символ от пользователя.
Программа останавливается и ждёт ввода. Пользователь вводит 5↵ буфер: '5', '\n'.
%c читает '5'; '\n' остаётся на потом — его опять съест " " на следующей итерации.
И так дальше, до тех пор, пока пользователь не введёт 'q'.

Поэтому
scanf("%d", &x); и scanf(" %d", &x); почти всегда ведут себя одинаково.
Разница критична именно для %c (и частично для %[…] и некоторых других).

5. Итоговое правило для себя
Для одиночного символа в меню всегда используй: scanf(" %c", &c);
Для чисел (%d, %f, …) и строк (%s) пробел в формате обычно не нужен, они сами 
скипают пробелы '\n' перед данными.
*/