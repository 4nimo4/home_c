# Компилятор и флаги
CC     = gcc
CFLAGS = -Wall -Wextra -Wpedantic -std=c11 -Imylib1 # -Imylib1 добавляет каталог с lib1.h
# CFLAGS — флаги, которые передаются при компиляции 
# исходников в .o (опция -c).
# -Wall - Включить “все основные предупреждения” компилятора.
# -Imylib1 - Флаг -I (большая i) говорит компилятору «Добавь каталог
# mylib1 в список мест, где нужно искать заголовочные файлы #include "..."
# и  #include <...>».
# Важно, -I ничего не знает про имена файлов (lib1.h,stdio.h и т.д.), 
# он просто добавляет каталог.
# То есть -Imylib1 означает:«когда видишь #include "что_то.h",
#, помимо стандартных путей, загляни ещё в папку mylib1/ ».
# В этой папке может лежать что угодно: и .h, и.c, и.a, Флаг -I 
# к этому не привязан, он просто добавляет директорию поиска заголовков.
# Почему тогда находится именно lib1.h? Потому что в коде написано:#include "lib1.h"
# Компилятор действует так:Сначала ищет lib1.h в той же папке, где лежит .c файл.
# Если не нашёл — ищет в каталогах из флагов -I (mylib1).Потом в системных каталогах 
#(/usr/include и т.д.).Он НЕ ищет “специально каталог, в котором лежит lib1.h”. 
# Он просто ходит по списку директорий, и если в mylib1 есть файл с нужным именем
# lib1.h , то находит его.То, что в mylib1 лежит ещё lib1.c , компилятору не мешает 
# — при поиске заголовков он просто игнорирует не подходящие по имени файлы.

LDFLAGS = -L./mylib1           # искать библиотеки в каталоге mylib1
# LDFLAGS — флаги для линковки (создания итогового .exe,./, - бинарника из .o файлов).
# Флаг -L говорит линковщику «Добавь каталог ./mylib1 в список мест, где нужно искать 
# библиотеки при использовании -lимя ». Опять же, как и с -I, -L не знает, какие 
# конкретно файлы лежат в этом каталоге. Он просто добавляет папку к списку мест, 
# где ищут библиотеки.

LIBS   = -lmy1                 # подключить libmy1.a
# -l (маленькая L) говорит линковщику «Найди библиотеку с именем libmy1.a или
# libmy1.so в каталогах, указанных через -L (и стандартных), и подключи её».
# Правило такое -lXXX→ ищется файл libXXX.a (статическая) или libXXX.so (динамическая).
 
# Имя итоговой программы
TARGET = prog

# Цель по умолчанию — собрать программу
all: $(TARGET)

#-----------------------------
# 1. Сборка статической библиотеки libmy1.a
#-----------------------------

# Библиотека зависит от объектного файла lib1.o
mylib1/libmy1.a: mylib1/lib1.o
# Создаём статическую библиотеку из объектного файла
	ar rcs mylib1/libmy1.a mylib1/lib1.o
# rcs — стандартный набор флагов для ar:
# r — заменить/добавить файл в архив
# c — создать архив, если его нет
# s — добавить индекс (полезно для линковщика)

# Компиляция исходника библиотеки в объектный файл
mylib1/lib1.o: mylib1/lib1.c mylib1/lib1.h
	$(CC) $(CFLAGS) -c mylib1/lib1.c -o mylib1/lib1.o
#Подставляем значения: gcc -o main.o -L./mylib1 -lmy1
#-----------------------------
# 2. Сборка основной программы
#-----------------------------

# Сборка исполняемого файла из объекта main.o и библиотеки libmy1.a
$(TARGET): main.o mylib1/libmy1.a
	$(CC) -o $(TARGET) main.o $(LDFLAGS) $(LIBS)

# Компиляция main-файла (main.c) в объектный файл
main.o: main.c mylib1/lib1.h
	$(CC) $(CFLAGS) -c main.c -o main.o

#-----------------------------
# Очистка
#-----------------------------
clean:
	rm -f *.o $(TARGET) mylib1/*.o mylib1/libmy1.a

.PHONY: all clean

#--------------------------------------------------
# Примеры из лекции (Linux) — просто как комментарий
#--------------------------------------------------
# Ручная сборка статической библиотеки:
#   gcc -c lib1.c
#   ar -r libmy1.a lib1.o
#
# Линковка с библиотекой:
#   gcc -o prog1 main.c -L ./ -lmy1
#
#--------------------------------------------------
# Примеры для Windows (MinGW) — КОММЕНТАРИЙ
#--------------------------------------------------
#   gcc -c lib1.c
#   ar -r libmy1.a lib1.o
#
#   gcc -o prog1 main.c -L ./ \
#       c:\geekbrains.ru\Projects\C\MIPI_AC_Git\MIPI_AdvancedC\Lect3\35\libmy1.a
#
# или:
#   gcc -o prog1 main.c -L c:\geekbrains.ru\Projects\C\MIPI_AC_Git\MIPI_AdvancedC\Lect3\35 -lmy1