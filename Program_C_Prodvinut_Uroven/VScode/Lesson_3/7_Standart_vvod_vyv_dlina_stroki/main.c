/*
//------------------------------------------------------
// Стандартный ввод/вывод
//------------------------------------------------------
При использовании стандартной функции ввода scanf, необходимо помнить, что
спецификатор %s не контролирует размер введённых пользователем данных.
Слишком длинная строка может привести к buffer overflow.
В данном примере пользователь ввёл слишком длинную строку, которая записалась в s1 и
затерла строку s2.
*/

#include <stdio.h>

// Глобальные строки, лежащие в памяти подряд
char s1[] = "Hello ";
char s2[] = "world!";

int main(void) 
{
    // ВАРИАНТ 1 (ОПАСНО):
    // scanf("%s", s1);
    //
    // %s считывает последовательность НЕ-пробельных символов
    // и записывает их в s1, НИЧЕМ не ограничивая длину.
    // Если пользователь введёт строку длиннее, чем размер массива s1,
    // запись пойдёт за границы s1 и начнёт затирать следующее в памяти —
    // в данном случае это s2.

    // ВАРИАНТ 2 (БЕЗОПАСНЕЕ):
    // Ограничиваем количество считываемых символов.
    // "%6s" означает: прочитать не более 6 символов + '\0' будет добавлен сам.
    scanf("%6s", s1);

    printf("s1 = %s\n", s1);
    printf("s2 = %s\n", s2);

    /*
    Для scanf("%s", s1); (ОПАСНЫЙ ВАРИАНТ)

    Пусть размер массива s1, скажем, 7 байт ("Hello " + '\0'),
    а затем в памяти идёт s2 = "world!".
    При вводе:

      1) "rytm"
         s1 = rytm
         s2 = world!
         — всё помещается в s1, переполнения нет.

      2) "adfasd"
         s1 = adfasd
         s2 = world!
         — граница уже близко, но всё ещё может влезть (зависит от точного размера).

      3) "sdfgfgnhmjk,ljkl;uurt"
         s1 = sdfgfgnhmjk,ljkl;uurt
         s2 = hmjk,ljkl;uurt
         — строка слишком длинная:
           запись из scanf вышла за границы s1 и затёрла часть s2.
           Это и есть переполнение буфера (buffer overflow).

    Чтобы этого избежать, задаём ограничение длины:

      scanf("%6s", s1);

    Тогда при вводе:
      "asdfasdfasdgfasdfgf"

    будет:
      s1 = asdfas
      s2 = world!

    scanf прочитает только 6 символов в s1, остальное игнорируется (останется в буфере
    ввода или будет прочитано следующими операциями ввода).
    */

    return 0;
}