/*
  Читаем деклараторы
//----------------------------------------------------    
    Массив указателей
//---------------------------------------------------------------------
● Сайт для декодирования деклараторов https://cdecl.org/
● Декларатор содержит имя определяемого объекта, но
в некоторых местах может не содержать имя
определяемого объекта. Анонимные деклараторы
допускаются в операции приведения типа и при
описании формальных параметров в прототипах
функций. Например декларатор может иметь вид:
● char (*(*x[3])())[10]; - на самом деле это значит
объявить x как массив 3 указателей на функцию,
возвращающую указатель на массив из 10 char.
//---------------------------------------------------------
При интерпретации составных деклараторов может быть предло жено простое правило, которое
читается следующим образом: "изнут ри- наружу".
● Нужно начать с идентификатора и посмотреть вправо, есть ли квадратные или круглые скобки.
● Если они есть, то проинтерпретировать эту часть декларатора, затем посмотреть налево, если ли
звездочка.
● Если на любой стадии справа встретится закрывающая круглая скобка, то вначале необходимо
применить все эти правила внутри круглых скобок, а затем продолжить интерпретацию. на
последнем шаге интерпретируется спецификатор типа.
В следующем примере проиллюстрированы эти правила. char *(*(*var) ()) [10];
Последовательность шагов при интерпретации перенумерована.
● Сайт для декодирования деклараторов https://cdecl.org/
● https://studfile.net/preview/1108492/page:10/
● https://ejudge.ru/study/3sem/sem08.pdf
● https://russianblogs.com/article/711570141/ статья от китайцев )))
● http://unixwiz.net/techtips/reading-cdecl.html
//-----------------------------------------------------------------
При интерпретации составных деклараторов может быть предложено простое
правило, которое читается следующим образом: "изнутри- наружу".
char *(*(*var)( )) [10];
    ^ ^ ^ ^ ^  ^     ^
    7 6 4 2 1  3     5
1. Идентификатор var объявлен как
2. Указатель на
3. Функцию, возвращающую
4. Указатель на
5. Массив из 10 элементов, который состоит
6. Из указателей на
7. Величины типа char.
//-------------------------------------------------------------------
    Пример
//-----------------------------------------------------------
int a[3][4]; - массив из 3 элементов типа массива из 4
элементов int
char **b; - указатель на указатель на char
char *c[]; - массив из неопределённого количества элементов
типа указатель на тип char
int *d[10]; - массив из 10 элементов типа указатель на тип
int
int (*a)[10]; - указатель на массив из 10 элементов типа int
int (*a)[5]; - указатель на массив из 5 элементов типа int
int *f(); - функция, возвращающая указатель на int
int (*f)(); - f это указатель на функцию, возвращающую
значение int
int (*a)[5]; - указатель на массив из 5 элементов типа int
//----------------------------------------------------
*/

#include <stdio.h>


    /* сравнение двух целых V1 */
    int comparator (const int *a, const int *b) 
    {
        return *a - *b;
    }

    int main(void)
    {
   // ….
    qsort(a, SIZE, sizeof (int), (int(*) (const void*, const void *)) comparator);
    //….
    return 0;
    }
/*
    // сравнение двух целых V2 
    int comparator (const void *a, const void *b) 
    {
    return *(int *)a - *(int *)b;
    }
int main(void)
    {
    //….
    qsort(a, SIZE, sizeof (int), comparator);
    //….
     return 0;
    }
   
*/