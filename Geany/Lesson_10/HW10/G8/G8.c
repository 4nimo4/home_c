/*
 * G8.c
 * 
 * Числа в массив
 * 
 * В файле input.txt дана строка, не более 1000 символов, содержащая 
 * буквы, целые числа и иные символы. Требуется все числа, которые 
 * встречаются в строке, поместить в отдельный целочисленный массив. 
 * Например, если дана строка "data 48 call 9 read13 blank0a", 
 * то в массиве числа 48, 9, 13 и 0. 
 * Вывести массив по возрастанию в файл output.txt.


 * Формат входных данных
 * 
	Строка из английских букв, цифр и знаков препинания

	
	Формат результата
	
	Последовательность целых чисел отсортированная по возрастанию

 * ------------------------------------------------------
 * char name[50]; //Создаем массив для строки из 50 символов
	printf("Enter your name: ");	// Use fgets() instead of gets()
	if (fgets(name,50,stdin)!= NULL) //Читаем строку из потока stdin
		{							// Trim newline if present 
						//(Обрезать новую строку, если она присутствует)
			name[strlen(name)-1] = '\0'; // Присваиваем последнему символу в 
								//строке сивол окончания строки ('\0')
			printf("Your name is: %s", name);
		}
	else
		{
			printf("Error reading input");
		}
---------------------------------------------------------------
 */
#include <stdio.h>

#define N 1002 // Размер созаваемого массива

void Print_char(char arr[], int);	//Функция вывода на индикацию массива данных char
void Print_int(int arr[], int);	//Функция вывода на индикацию массива данных int
void sort_array(int, int a[]); // Функция сортровки массива по возрастанию

int main(void)
{
//----------------------------------------------------------------------------------
//Создаем переменные для работы с файлами
//----------------------------------------------------------------------------------
	FILE *f_in, *f_out; //Создали файловые переменные 
	char * input_fn = "input.txt"; //создали указатель для входящего файла 
	char * output_fn = "output.txt";//создали указатель для исходящего файла 
	int mass1[N] = {0}; //Создали массив элементов для хранения символов строки
	//char mass2[N] = {0}; //Создали массив элементов для хранения символов строки
	signed char c;//Переменная в которую будет считана строка обязательно signed! иначе зациклится
	int count1=0, u=0, b=0;
	//int count2=0; 
    f_in = fopen(input_fn, "r");//Открыли файл на чтение
    f_out = fopen(output_fn, "w");//Открыли файл на запись

//----------------------------------------------------------------------------------
//открываем файл "input.txt" на чтение
//----------------------------------------------------------------------------------	
    if(f_in == NULL) 
    {
        //Если файл не содержит данных, то ошибка чтения файла
        perror("Error occured while opening input file!");
        return 1; // Завершем прграмму с признаком ошибки
    }
//----------------------------------------------------------------------------------
//Начинаем чтение файла посимвольно и сразу пишем первое слово в первый массив,
//а вторе во второй массив
//----------------------------------------------------------------------------------   
    // Обязательно функция fgetc(fp)
    for(int t=0, a=0; ((c = fgetc(f_in)) != EOF) && (c != '\n'); ) //
    //Разбираем содержимое строки в файле
    //Посимвольно вычитываем строку, пока нам не встретится конец файла EOF,  
	//или признак переноса строки '\n'
		{
			t++;
			if(c >= '0' && c <= '9')
				{
					u = c - '0'; // Приведение типов к int
			//		printf("u = %d\n", u);
					if(a < 1) //самый первый проход, обрабатываем первую цифру новогог числа
						{
							a = t;
							b++;	//Здесь b = 1
							mass1[count1++] = u; //Положили u по адресу count1 и увеличили адрес count1++
			//				printf("if(a < 1) a = %d, t = %d, b = %d, u = %d, (count1-1) = %d, mass1[count1-1] = %d\n", a, t, b, u, (count1-1), mass1[count1-1]);
						}
					// Сюда попадаем, если нам встретится вторая и последующие цифры входящие в состав одного числа
					if((t - 1) > 0 && a == (t - 1)) // (t - 1) > 0 Этим условием страхуемся от выхода за пределы массива
						{							//приобработке первого элемента с нулевым индексом = count1 = 0
							b++;
							a++;
							mass1[count1++] = u;
				//			printf("if((t - 1) > 0 && a == (t - 1)) a = %d, t = %d, b = %d, u = %d, (count1-1) = %d, mass1[count1-1] = %d\n", a, t, b, u, (count1-1), mass1[count1-1]);
						}
			// Сюда попадаем, если цифры составляющие одно число закончились и все они последовательно сейчас находятся массиве	count1, а мы после них считывали другие нечисловые символы и нам опять на вход поступила цифра (сейчас она в переменной u), она может быть числом(один разряд), или входить в состав другого числа(несколько разрядов) 																
					if(a != t && a != (t - 1)) // Здесь приступаем  к сборке числа из цифр которы храняться в count1, количеству этих цифр соответствует переменная b
						{										
							 for(int k=10; (b-1) > 0; b--, count1--) 
								//В count_numbers содержится количество цифр, которые входят в состав одного числа, 
								{// в count_index_mass сейчас общее количество цифр считанных в массив arr[] + следующая позиция
							//		printf("\n");
									//printf("if(a != t && a != (t - 1)) a = %d, t = %d, count_numbers = %d, u = %d, (count_index_mass) = %d, arr[count_index_mass-2] = %d, arr[count_index_mass-1] = %d, arr[count_index_mass] = %d\n", a, t, count_numbers, u, (count_index_mass), arr[count_index_mass-2], arr[count_index_mass-1], arr[count_index_mass]);
							//		printf("\n");
							//		printf("mass1[count1-2] = %d\n", mass1[count1-2]);
									
									mass1[count1-2] *= k;
									
							//		printf("mass1[count1-2] = %d\n", mass1[count1-2]);
									
									k *= 10;
									mass1[count1-2] += mass1[count1-1];
									
							//		printf("mass1[count1-2] = %d\n", mass1[count1-2]);
							//		printf("\n");
									
								}				
								
					//		printf("for(1) a = %d, t = %d, b = %d, u = %d, (count1) = %d, mass1[count1-2] = %d, mass1[count1-1] = %d, mass1[count1] = %d\n", a, t, b, u, (count1), mass1[count1-2], mass1[count1-1], mass1[count1]);
					//		printf("\n");
							
							a = t;
							mass1[count1++] = u;
							
				//			printf("for(2) a = %d, t = %d, b = %d, u = %d, (count1) = %d, mass1[count1-2] = %d, mass1[count1-1] = %d, mass1[count1] = %d\n", a, t, b, u, (count1), mass1[count1-2], mass1[count1-1], mass1[count1]);
				//			printf("\n");							
						}
						
				}
						
		}
if(b > 1)
	{
		for(int k=10; (b-1) > 0; b--, count1--) 
								//В count_numbers содержится количество цифр, которые входят в состав одного числа, 
								{// в count_index_mass сейчас общее количество цифр считанных в массив arr[] + следующая позиция
								//	printf("\n");
									//printf("if(a != t && a != (t - 1)) a = %d, t = %d, count_numbers = %d, u = %d, (count_index_mass) = %d, arr[count_index_mass-2] = %d, arr[count_index_mass-1] = %d, arr[count_index_mass] = %d\n", a, t, count_numbers, u, (count_index_mass), arr[count_index_mass-2], arr[count_index_mass-1], arr[count_index_mass]);
						//			printf("\n");
						//			printf("mass1[count1-2] = %d\n", mass1[count1-2]);
									
									mass1[count1-2] *= k;
									
						//			printf("mass1[count1-2] = %d\n", mass1[count1-2]);
									
									k *= 10;
									mass1[count1-2] += mass1[count1-1];
									
						//			printf("mass1[count1-2] = %d\n", mass1[count1-2]);
						//			printf("\n");
									
								}		
	}
			//mass1[count1++] = c;//Заполняем массив до того пока не встретим символ пробела	

//определили, что нам встретился либо конец файла EOF или признак переноса '\n'
	mass1[count1] = '\0'; // записываем вместо него признак конца строки '\0'
   // Print_char(mass2, count2);  
 //   Print_int(mass1, count1);
    sort_array(count1, mass1);
//    Print_int(mass1, count1);
    //printf("count1=%d count2=%d count3=%d count4=%d\n", count1, count2, count3, count4);	
    fclose(f_in); // Закрываем файл input_fn	
//-----------------------------------------------------------------------------------
//	printf("\n");



	
//-----------------------------------------------------------------------------------
//открываем файл "output.txt" на запись
//----------------------------------------------------------------------------------	
    if(f_out == NULL)
    {
        //Если файл не содержит данных, то ошибка чтения файла
        perror("Error occured while opening output file!");
        return 1; // Завершем прграмму с признаком ошибки
    }
//-----------------------------------------------------------------------------------
//Записываем содержимое отсортированного масива mass3[count3] в файл "output.txt"
//----------------------------------------------------------------------------------    
//	printf("count1 = %d\n", count1);
	for(int i=0; i < count1; i++)
		{
			fprintf(f_out,"%d ", mass1[i]);
			//Print(mass2, count2);
			//Print_int(mass1, count1);
		}
	 //Записываем в файл строку
//	printf("str = %d  zagl = %d", count_str, count_zagl); 
		
	
    fclose(f_out); //Закрывваем файл
//----------------------------------------------------------------------------------	
	return 0;
}


//-------------------------------------------------------------------------
//Функция вывода на индикацию массива данных char
//-------------------------------------------------------------------------
void Print_char(char arr[], int n) // Можно так писать
//int Input(int* arr, int n)	// А можно и так писать
{
	for(int i=0; i<n; i++)
		{
			printf("%c ", arr[i]);
		//	scanf("%d", &arr+i); // Есть еще и такой формат записи
			// Он называется - Арифметика Указателя			
		}
	printf("\n");	
}
//-------------------------------------------------------------------------
//-------------------------------------------------------------------------
//Функция вывода на индикацию массива данных int
//-------------------------------------------------------------------------
void Print_int(int arr[], int n) // Можно так писать
//int Input(int* arr, int n)	// А можно и так писать
{
	for(int i=0; i<n; i++)
		{
			printf("%d ", arr[i]);
		//	scanf("%d", &arr+i); // Есть еще и такой формат записи
			// Он называется - Арифметика Указателя			
		}
	printf("\n");	
}
//-------------------------------------------------------------------------
//--------------------------------------------------------------
//Функция сортировки массива данных по возрастанию
//--------------------------------------------------------------
void sort_array(int size, int a[])
{
	int i, noSwap;// Переменная noSwap для проверки, 
	//вдруг массив уже отсортирован, значит не нужно вывоплять сортировку
	for(i=0; i<size; i++)
		{
			noSwap=1;
			for(int j=size-1; j>i; j--)
				{
					if(a[j-1] > a[j])
						{
							//SwapArr(a, j-1, j);
							int temp = a[j-1];
							a[j-1] = a[j];
							a[j] = temp;
							noSwap = 0;
						}
				}
			if(noSwap)	// Если noSwap != 0, то делаем break
				{
					break;	//Значит сортировать массив не нужно!!!
				}
		}	
}
//--------------------------------------------------------------
