/*
 * qsort2.c
 * 
 * 	Сортировка qsort
 * //------------------------------------------------------
 * 	Указатели на функцию
 * 
 * У каждой функции есть свой адрес, примерно так же как и у каждой
 * переменной:
 * 	0x100	f1()
 * 	0x150	f2()
 * 	0x300	f3()	
 * 
 * 	Указатель на функцию содержит адрес тела функции
 * 	Как описывается указательна функцию?
 * 
 * 	returnType (*functPtr) (paramType1, paramType2)
 * 		^			^			^			^
 * 		|			|			|			|
 * Тип возвращ	 Указатель 	 Тип параметра	Тип параметра
 * аемого знач	 на функцию	 функции			функции
 * ения функции
 * 
 * float myfun(int a, float b)	Указатель на функцию, воспринимающую 
 * 								переметры типов int и float
 * 	{							возвращяющую float
 * 		return a+b;
 * 	}
 * ....
 * float (*fptr) (int, float);
 * fptr = myfun;				//Вызов функции по указателю
 * ....
 * x = fptr(42, 3.14f);	
 * //------------------------------------------------------------
 *  
 * 	● Функция qsort() сортирует массив, на который указывает параметр
	base, используя quicksort — алгоритм сортировки широкого
	назначения, разработанный Т. Хоаром. Параметр num задает число
	элементов массива, параметр size задает размер в байтах каждого
	элемента.
	● Функция, на которую указывает параметр compare, сравнивает
	элементы массива с ключом. Формат функции compare следующий:
	● int func_name(const void *arg1, const void *arg2
	● Она должна возвращать следующие значения:
	● Если arg1 меньше, чем arg2, то возвращается отрицательное целое.	
	● Если arg1 равно arg2, то возвращается 0.
	● Если arg1 больше, чем arg2, то возвращается положительное целое.
	● Массив сортируется по возрастанию таким образом, что
	наименьший адрес соответствует наименьшему элементу.
	
	Указатели типа void* могут указывать на анные любого типа.
	
	Попробуем новый тип сортировки на предыдущей программе про датчик температуры
	
	Подготовка к курсовому проекту
 * 
 * Описать структурный тип для представления сбора информации с
	датчика температуры, необходимые поля: дата (день, месяц, год) и
	температура. Используя этот тип, описать функцию, принимающую на
	вход массив таких данных и упорядочивающую его по возрастанию
	температуры, по дате
 * 
 * 
 */


#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>
#include <stdlib.h>



#define SIZE 30

//----------------------------------------------------------------
//Ключевое слово struct, за ним название структуры sensor 
struct sensor //Заполним поля структуры
	{//Лучше начинать с самых больших полей, это связано с последующим выравниваем
		uint16_t year; //т.к год 2025, то используем тип uint_16 - самое большое поле
		uint8_t day;// день
		uint8_t month; //месяц		
		int8_t t;		//температура
	};//Между }; можем объявить переменную этого типа }template = {0,0,0,0}; 
	//а можем и не объявлять
//-----------------------------------------------------------------
typedef struct sensor sensor_t; //Переопределим тип для дальнейшего удобства
typedef (int(*) (const void*, const void *)) comparator_t;//такие замены для функции qsort !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//--------------------------------------------------------------------	
void AddRecord(sensor_t info[], int number, uint16_t year,uint8_t month, uint8_t day,int8_t t)
{
	info[number].year = year;
	info[number].month = month;
	info[number].day = day;
	info[number].t = t;
}
//-------------------------------------------------------------------
int AddInfo(sensor_t info[])
{
	int counter=0;
	AddRecord(info,counter++,2021,9,16,9);
	AddRecord(info,counter++,2022,9,2,-9);
	AddRecord(info,counter++,2021,1,7,8);
	AddRecord(info,counter++,2021,9,5,1);
 return counter;
}
//----------------------------------------------------------------
void print(sensor_t info[],int number)
{
	printf("===================================\n");
	for(int i=0;i<number;i++)
		{
			printf("%04d-%02d-%02d t=%3d\n", info[i].year, 
			info[i].month, info[i].day, info[i].t);
		}
}
//------------------------------------------------------------------
void cgangeIJ(sensor_t info[],int i, int j) //Функция смены позиций двух элементов массива
{
	sensor_t temp;
	temp=info[i];
	info[i]=info[j];
	info[j]=temp;
}
//--------------------------------------------------------------
/*упорядочивающую его по неубыванию температуры
 * Здесь все довольно просто
*/
void SortByT(sensor_t info[],int n)
{
	for(int i=0; i<n; ++i)
		{
			for(int j=i; j<n; ++j)
				{
					if(info[i].t >= info[j].t)
						{
							cgangeIJ(info,i,j);
						}
				}
		}
}
//--------------------------------------------------------------
/* По дате ситуация несколько сложнее, потому что дата имеет несколько полей,
 * год, месяц и день. есть два подхода.
 */	
//--------------------------------------------------------------
// 
//-------------------------------------------------------------
 unsigned int DateToInt(sensor_t info[])
	{
		return info->year << 16 | info->month << 8 | info->day;
	}

//другой подход
// 2. можно написать специальную функцию Compare
//---------------------------------
//Избавились от (int(*) (const void*, const void *)) в функции qsort
int Compare(sensor_t* a,sensor_t* b)
//int Compare(const void* va,const void* vb)//такие замены
{
	//Делаем явное приведение типов
	//sensor_t* a = (sensor_t*)va;	//такие замены
	//sensor_t* b = (sensor_t*)vb;	//такие замены
//------------------------------------
	if(a->year != b->year)
		{
			return a->year - b->year;
		}
	else if (a->month != b->month)
		{
			return a->month - b->month;
		}
	else
		{
			return a->day - b->day;
		}
}
//--------------------------------------------------------------
//1. можно написать так 
//упорядочивающую его по дате
void SortByDate(sensor_t info[],int n)
{
	for(int i=0; i<n; ++i)
		{
			for(int j=i; j<n; ++j)
				{
					//if(DateToInt(info+i)>=DateToInt(info+j)) //Для варианта 1
					if(Compare(info+i,&info[j])>0) //Для варианта 2
						{
							cgangeIJ(info,i,j);
						} 	
				}
		}
}

//---------------------------------------------------------------			
int main(void)
{
	sensor_t info[SIZE];
	int number=AddInfo(info);
	print(info,number);	// Выводим массив данных
	printf("\nSort by t\n"); //Неотсортированный массив по температуре
	SortByT(info,number);	//Сортируем массив по температуре
	print(info,number);	//Выводим отсортированный массив по температкре
	printf("\nSort by date\n");	//Неотсортированный массив по дате
	// Заменим функцию SortByDate функцией qsort
	//SortByDate(info,number); //Сортируем массив по дате
	//----------------------------------------------------------------------
	//qsort(info, number, sizeof (sensor_t), (int(*) (const void*, const void *)) Compare);
	//-----------------------------------------------------------------------
	//qsort(info, number, sizeof (sensor_t), Compare);//Избавились от (int(*) (const void*, const void *))
	//-----------------------------------------------------------------------
	qsort(info, number, sizeof (sensor_t), comparator_t Compare);
	//-----------------------------------------------------------------------
	print(info,number); //Выводим отсортированный массив по дате
	return 0;
}

