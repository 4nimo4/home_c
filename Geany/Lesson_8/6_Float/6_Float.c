/*
 * 6_Float.c
 * 
 * Представление чисел в памяти
 * //-------------------------------------------------------------
 * Целые числа
 * 
 * ● Целые числа без знака - хранятся в двоичном виде
	в прямом коде
	● Целые числа со знаком - хранятся в двоичном виде
	в дополнительном коде
	● Символы, коды символов - хранятся также как и
	беззнаковые целые числа, в двоичном коде в
	явном виде
//-----------------------------------------------------------------	
	Вещественные числа
	
	● Вещественные числа хранятся в памяти в
	следующем виде
	● S - знак мантиссы (0 - положительное число, 1 -
	отрицательное число)
	● E - порядок (выражает степень основания числа, на
	которое умножается мантисса)
	● M - мантисса (выражает значение числа без учёта
	порядка)
	
	Представление вещественных чисел
	
	Вещественные числа хранятся в нормализованном виде и
	денормализованном виде (маленькие по модулю). Рассмотрим пример
	нормализации десятичного числа 123.45. Такое число представляется в
	виде:
	123.45 = 1.2345 * 10^2
	Аналогично для двоичного числа - 1111.101 (15.625 * 10^1 ):
	1111.101 = 1.111101 * 2^3
	Размер выделенный под хранение вещественных чисел зависит от
	архитектуры ЭВМ. В языке Си определены типы
//---------------------------------------------------------------------	
	Пример1
	Рассмотрим на примере как будет хранится число 15.625 в типе float
	

		тип float 4 байта
		S - знак числа 1 бит
		P - порядок 8 бит
		M - мантисса 23 бита
		
//------------------------------------------------------------------		
		
		Пример2
		Для наглядности, используем функцию, которая отобразит наше число
		в двоичном виде.
		float f=15.625;
		print_float_bin(f);

//-------------------------------------------------------------------
		Если число слишком мало (по модулю), оно представляется в
	денормализованном виде. Поле E заполняется нулями, порядок
	принимается равным 1-bias , а мантисса должна в этом случае
	принадлежать полуинтервалу (0.0, 1.0). В поле M пишется
	последовательность битов, кодирующая дробную часть мантиссы
	(ведущий 0 отбрасывается).
	
	0 10000010 11110100000000000000000
	S 	 E 			M
//-------------------------------------------------------------------

	Этого можно достичь через Union - Объединения
 * 
 */



#include <stdio.h>

//Объявляем заголовки функций
void print_float_bin(float);	//Перевод вещественного числа в двоичный вид
								
int main() 
{
	float f=15.625;
	print_float_bin(f);
	return 0;
}

//--------------------------------------------------------------
//Перевод вещественного числа в двоичный вид
void print_float_bin(float num) 
{
//-----------------------------------------------------------------	
//	unsigned int fi = num;	// Если оставить - unsigned int fi = num;
	//то мы потеряем всю дробную часть - будет выведено 
	//0 00000000 00000000000000000001111 - 15 в десятичной или 0x0F в 16-ричной
//---------------------------------------------------------------
	// чтобы не потерять дробную часть, воспользуемся указателями
	unsigned int* fi = (unsigned int*)&num;// Указываем явное приведение типов
	for(int i=31;i>=0;i--) 
//Получим на выходе 0 10000010 11110100000000000000000
		{
		//Разряд лежит в старшем бите
//Если у нас 30-й или 22-ой разряд, то мы поставим пробельчики, чтобы отделить 
//мантиссу от порядка и знака
			if(i==30 || i==22)
				{
					putchar(' ');
				}
				
			if(*fi & (1<<i))	//А здесь делаем разъименование *fi
			//if(bit!=0)
				{
					putchar('1');
				}
			else
				{
					putchar('0');
				}

			//putchar('\n');
		}
}
//-------------------------------------------------------------------
