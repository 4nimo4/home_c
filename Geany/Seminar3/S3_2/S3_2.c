/*
 * S3_2.c
 * 
 * Арифметика указателей
 * 
 * 	Операции сравнения: ==, !, >=, <=, <, >
● 	Вычитание и добавление целочисленной константы
●	Вычитание одного указателя из другого
● 	Унарные операции: ++, --
●	Операции: -=, +=
 * 
 *	Указатели и массивы 
 * 
 * Указатели и массивы очень тесно связаны в языке Си
 * Имя массива - константный указатель на 0-й элемент массива
 * 
 * short a[100];
 * short *ps;
 * ps = &a[0]; ==  ps = a; //Обе записи равны!!
 * 
 *a[i] == *(a+i), если мы добавляем i=1 к адресу указателя или к адресу 
 элемента массива, то добавится не 1 байт, а разамер типа элемента 
 (если short, то 2 байта, если int, то 4 байта)

	Вычитание адреса:
	 a[1]-a[2] = (a[1]-a[2]) / sizeof(a[1])
 * 
 */


#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

int main()
{
//на сколько будут отличаться адреса элементов массива?
	int a[5]= {10,20,30,40,50};

	uint64_t b[5]= {10,20,30,40,50};
	//int *pa, n;
	//pa = a;
	//n = *pa+2; // a[0] + 2
	//printf("n = %d\n", n);
	printf("&a[0] = %p\n", &a[0]);
	printf("&a[1] = %p\n", &a[1]);
	printf("&a[1]-&a[0] = %ld\n", &a[1]-&a[0]); // = 1
//-----------------------------------------------	
	uint64_t a0 = (uint64_t)&a[0];
	uint64_t a1 = (uint64_t)&a[1];
	
	printf("&a[0] = %p\n", &a[0]);
	printf("&a[1] = %p\n", &a[1]);
	printf("&a[1]-&a[0] = %ld\n", a1-a0); // = 4
//----------------------------------------------	
	uint64_t b0 = (uint64_t)&b[0];
	uint64_t b1 = (uint64_t)&b[1];
	
	printf("&b[0] = %p\n", &b[0]);
	printf("&b[1] = %p\n", &b[1]);
	printf("&b[1]-&b[0] = %ld\n", b1-b0); // = 8
//-----------------------------------------------
	uint8_t *pa0 = (uint8_t*)&a[0]; //Приводим указатель к типу uint8_t = (uint8_t*)
	uint8_t *pa1 = (uint8_t*)&a[1];	//Приводим указатель к типу uint8_t = (uint8_t*)
	printf("&a[1]-&a[0] = %ld\n", pa1-pa0); // размер в байтах = 4
	return 0;
}

