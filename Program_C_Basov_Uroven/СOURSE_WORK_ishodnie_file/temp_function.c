#include <stdio.h>
#include "temp_function.h"

//--------------------------------------------------------------------
// temp_function.c
//
// Набор функций для работы с данными датчика температуры:
//  - загрузка данных из CSV-файла;
//  - вычисление статистики по месяцам и за год;
//  - вывод сводной таблицы в требуемом формате.
//--------------------------------------------------------------------

/*
//------------------------------------------------------------------
// Функции сортировки (по температуре и по дате)
// В ТЕКУЩЕЙ ВЕРСИИ ПРОГРАММЫ НЕ ИСПОЛЬЗУЮТСЯ,
// оставлены для возможного расширения функционала.
//------------------------------------------------------------------

//------------------------------------------------------------------
// Функция смены позиций двух элементов массива
//------------------------------------------------------------------
void cgangeIJ(sensor_t info[], int i, int j)
{
    sensor_t temp = info[i];
    info[i]       = info[j];
    info[j]       = temp;
}

//--------------------------------------------------------------
// Сортировка по температуре (по возрастанию) – для отладки
//--------------------------------------------------------------
void SortByT(sensor_t info[], int n)
{
    for (int i = 0; i < n; ++i)
        for (int j = i; j < n; ++j)
            if (info[i].t > info[j].t)
                cgangeIJ(info, i, j);
}

//--------------------------------------------------------------
// Преобразование даты в целое число (год, месяц, день)
//--------------------------------------------------------------
unsigned int DateToInt(sensor_t info[])
{
    return (info->year << 16) | (info->month << 8) | info->day;
}

//--------------------------------------------------------------
// Функция сравнения двух дат (для сортировки по дате)
//--------------------------------------------------------------
int Compare(const void *va, const void *vb)
{
    const sensor_t *a = (const sensor_t *)va;
    const sensor_t *b = (const sensor_t *)vb;

    if (a->year != b->year)
        return (int)a->year - (int)b->year;
    else if (a->month != b->month)
        return (int)a->month - (int)b->month;
    else
        return (int)a->day - (int)b->day;
}

//--------------------------------------------------------------
// Сортировка по дате (по возрастанию) – для отладки
//--------------------------------------------------------------
void SortByDate(sensor_t info[], int n)
{
    for (int i = 0; i < n; ++i)
        for (int j = i; j < n; ++j)
            if (Compare(&info[i], &info[j]) > 0)
                cgangeIJ(info, i, j);
}
*/
//Печатаем заголовок
void print_shap_zagolovka()
{
    printf("========================================================\n");
    printf("%4s %6s %7s %8s %8s %8s\n",
           "Line", "YEAR", "MONTH", "MinTemp", "MaxTemp", "AvgTemp");
    printf("========================================================\n");
}
//-----------------------------------------------------------------
// Загрузка CSV-файла в массив info[]
// Формат строки: YEAR;MONTH;DAY;HOUR;MIN;TEMP
// При ошибке формата: выводим номер строки и остаток строки,
// ошибочную строку НЕ учитываем в массиве при подсчёте статистики.
//-----------------------------------------------------------------
int load_temperature_csv(sensor_t info[], int max_n, const char *filename)
{
    FILE *open = fopen(filename, "r");
    if (open == NULL)
    {
        printf("Ошибка открытия файла %s\n", filename);
        return 0;
    }

    int Y, M, D, H, m, T;  // Переменные для считанных значений
    int n_scan;            // Количество успешно считанных полей
    int line  = 0;         // Номер текущей строки в файле
    int count = 0;         // Количество корректных записей, добавленных в массив

    // Читаем файл построчно до конца
    while ((n_scan = fscanf(open, "%d;%d;%d;%d;%d;%d",
                            &Y, &M, &D, &H, &m, &T)) > 0)
    {
        line++;

        if (n_scan < 6)
        {
            // Если считано меньше 6 полей – формат строки некорректен
            char s[256], c;
            fscanf(open, "%[^\n]%c", s, &c);  // дочитываем остаток строки
            printf("Ошибка данных в строке %d- %s\n", line, s);
            // Ошибочную строку НЕ добавляем в массив info[]
        }
        else
        {
            // Строка корректна, добавляем в массив если есть свободное место
            if (count < max_n)
            {
                info[count].year    = (uint16_t)Y;
                info[count].month   = (uint8_t)M;
                info[count].day     = (uint8_t)D;
                info[count].watch   = (uint8_t)H;
                info[count].minutes = (uint8_t)m;
                info[count].t       = (int8_t)T;
                count++;
            }
        }
    }

    fclose(open);
    printf("Из файла CSV загружено корректных записей: %d\n", count); // Информационное сообщение
    return count;
}

/*
//----------------------------------------------------------------
// Статистика за месяц (печатающие функции)
// В ТЕКУЩЕЙ ВЕРСИИ report.c НЕ ИСПОЛЬЗУЮТСЯ,
// оставлены как альтернативный интерфейс.
//----------------------------------------------------------------
void SortBy_Аverage_monthly__T(sensor_t info[], int n, int year, int month)
{
    int sum = 0, count = 0;

    for (int i = 0; i < n; i++)
        if (info[i].year == year && info[i].month == month)
        {
            sum += info[i].t;
            count++;
        }

    if (count > 0)
        printf("Среднемесячная температура %d-%02d = %.2f\n",
               year, month, (float)sum / count);
    else
        printf("Нет данных за %d-%02d\n", year, month);
}

//----------------------------------------------------------------
void SortBy_min_T_in_the_current_month(sensor_t info[], int n,
                                       int year, int month)
{
    int min_t = 127; // максимально возможное для int8_t
    int found = 0;

    for (int i = 0; i < n; i++)
        if (info[i].year == year && info[i].month == month)
        {
            if (!found || info[i].t < min_t)
            {
                min_t = info[i].t;
                found = 1;
            }
        }

    if (found)
        printf("Минимальная температура %d-%02d = %d\n",
               year, month, min_t);
    else
        printf("Нет данных за %d-%02d\n", year, month);
}

//----------------------------------------------------------------
void SortBy_max_T_in_the_current_month(sensor_t info[], int n,
                                       int year, int month)
{
    int max_t = -128; // минимально возможное для int8_t
    int found = 0;

    for (int i = 0; i < n; i++)
        if (info[i].year == year && info[i].month == month)
        {
            if (!found || info[i].t > max_t)
            {
                max_t = info[i].t;
                found = 1;
            }
        }

    if (found)
        printf("Максимальная температура %d-%02d = %d\n",
               year, month, max_t);
    else
        printf("Нет данных за %d-%02d\n", year, month);
}
*/

//---------------------------------------------------------------------------
// Функция вывода средней годовой температуры
//   info[] - массив считанных измерений
//   n      - количество элементов в массиве info[]
//   year   - год, по которому нужно посчитать статистику
//
// Проходит по всем записям, отбирает только нужный год,
// считает сумму температур и количество измерений, затем
// выводит среднюю температуру за указанный год.
//---------------------------------------------------------------------------
void SortBy_Average_year__T(sensor_t info[], int n, int year)
{
    int sum = 0;    // Сумма температур за указанный год
    int count = 0;  // Количество измерений за указанный год

    // Просматриваем все записи в массиве
    for (int i = 0; i < n; i++)
        // Отбираем только те записи, где год совпадает с нужным
        if (info[i].year == year)
        {
            sum += info[i].t;  // Накопление суммы температур
            count++;           // Увеличиваем счётчик измерений
        }

    // Если за этот год нашлись измерения
    if (count > 0)
        // Печатаем среднюю температуру: сумма / количество
        printf("Среднегодовая температура %d = %.2f\n",
               year, (float)sum / count);
    else
        // Если записей за указанный год нет
        printf("Нет данных за %d\n", year);
}

//---------------------------------------------------------------------------
// Функция вывода минимальной температуры за указанный год
//   info[] - массив считанных измерений
//   n      - количество элементов в массиве info[]
//   year   - год, по которому ищем минимальную температуру
//
// Проходит по всем записям, отбирает только нужный год и
// находит наименьшее значение температуры. В конце выводит
// минимальную температуру за год или сообщение об отсутствии данных.
//---------------------------------------------------------------------------
void SortBy_min_T_for_the_year(sensor_t info[], int n, int year)
{
    int min_t = 127;  // Текущее минимальное значение температуры (стартовое "очень большое" значение)
    int found = 0;    // Флаг: найдена ли хотя бы одна запись за указанный год

    // Просматриваем все записи
    for (int i = 0; i < n; i++)
        // Берём в расчёт только записи с нужным годом
        if (info[i].year == year)
        {
            // Если это первая подходящая запись или температура меньше текущего минимума
            if (!found || info[i].t < min_t)
            {
                min_t = info[i].t; // Запоминаем новое минимальное значение
                found = 1;         // Отмечаем, что данные за этот год найдены
            }
        }

    // Если были найдены данные за этот год
    if (found)
        printf("Минимальная температура за %d = %d\n",
               year, min_t);
    else
        // Если ни одной записи с указанным годом не найдено
        printf("Нет данных за %d\n", year);
}
//---------------------------------------------------------------------------
// Функция вывода максимальной температуры за указанный год
//   info[] - массив считанных измерений
//   n      - количество элементов в массиве info[]
//   year   - год, по которому ищем максимальную температуру
//
// Проходит по всем записям массива, выбирает только указанный год
// и среди них находит наибольшее значение температуры. В конце
// печатает максимум за год или сообщение об отсутствии данных.
//---------------------------------------------------------------------------
void SortBy_max_T_for_the_year(sensor_t info[], int n, int year)
{
    int max_t = -128; // Текущее максимальное значение температуры
                      // (стартовое "очень маленькое" значение)
    int found = 0;    // Флаг: найдена ли хотя бы одна запись за указанный год

    // Просматриваем все записи
    for (int i = 0; i < n; i++)
        // Берём в расчёт только записи с нужным годом
        if (info[i].year == year)
        {
            // Если это первая подходящая запись
            // ИЛИ температура больше текущего максимума
            if (!found || info[i].t > max_t)
            {
                max_t = info[i].t; // Запоминаем новое максимальное значение
                found = 1;         // Отмечаем, что данные за этот год найдены
            }
        }

    // Если были найдены данные за этот год
    if (found)
        printf("Максимальная температура за %d = %d\n",
               year, max_t);
    else
        // Если ни одной записи с указанным годом не найдено
        printf("Нет данных за %d\n", year);
}

//----------------------------------------------------------------
// "Тихая" статистика по месяцу: только вычисление, без печати.
// Используется для формирования строк сводной таблицы.
//   info[]   - массив измерений
//   n        - количество элементов в массиве info[]
//   year     - год, за который считаем статистику
//   month    - месяц, за который считаем статистику (1..12)
//   min_t    - указатель на переменную, куда будет записан минимум
//   max_t    - указатель на переменную, куда будет записан максимум
//   avg_t    - указатель на переменную, куда будет записано среднее
//
// Возвращает:
//   1 - если за указанный месяц найдены данные, и статистика посчитана
//   0 - если данных за указанный месяц нет (выходные параметры не трогаем)
//----------------------------------------------------------------
int get_month_stats(sensor_t info[], int n, int year, int month,
                    int *min_t, int *max_t, double *avg_t)
{
    int sum = 0;         // Сумма температур за указанный месяц
    int count = 0;       // Количество измерений за этот месяц
    int local_min =  127;  // Локальный минимум (стартовое "очень большое" значение)
    int local_max = -128;  // Локальный максимум (стартовое "очень маленькое" значение)

    // Просматриваем все записи
    for (int i = 0; i < n; i++)
    {
        // Берём только записи за нужный год и нужный месяц
        if (info[i].year == year && info[i].month == month)
        {
            int t = info[i].t;  // Текущая температура
            sum += t;           // Накопление суммы

            // Обновляем локальный минимум, если текущая температура меньше
            if (t < local_min) 
                    local_min = t;

            // Обновляем локальный максимум, если текущая температура больше
            if (t > local_max) 
                    local_max = t;

            count++;            // Увеличиваем счётчик измерений
        }
    }

    // Если за этот месяц не найдено ни одной записи — сообщаем об этом вызывающему коду
    if (count == 0)
        return 0;  // Нет данных за указанный месяц

    // Если данные есть, записываем результаты через указатели
    *min_t = local_min;               // Минимальная температура
    *max_t = local_max;               // Максимальная температура
    *avg_t = (double)sum / count;     // Средняя температура

    return 1; // Успешное вычисление статистики
}

//----------------------------------------------------------------
// Печать одной строки статистики по месяцу в формате таблицы.
// Формат соответствует заголовку, выравнивание по правому краю.
//
//   info[]   - массив измерений
//   n        - количество элементов в массиве info[]
//   year     - год, за который печатается статистика
//   month    - месяц, за который печатается статистика
//   line_no  - порядковый номер строки (для первого столбца таблицы)
//
// Функция сначала вычисляет статистику по месяцу (min, max, avg)
// с помощью get_month_stats(), а затем выводит одну строку таблицы.
//
// Возвращает:
//   1 - если данные за месяц есть и строка успешно напечатана
//   0 - если за месяц нет данных (строка не печатается)
//----------------------------------------------------------------
int print_month_stat_line(sensor_t info[], int n,
                          int year, int month, int line_no)
{
    int min_t, max_t;   // Минимальная и максимальная температура за месяц
    double avg_t;       // Средняя температура за месяц

    // Пытаемся получить статистику по заданному месяцу и году
    // Если данных нет, ничего не печатаем и возвращаем 0
    if (!get_month_stats(info, n, year, month, &min_t, &max_t, &avg_t))
        return 0;   // Для данного месяца нет корректных данных

    // Печатаем одну строку таблицы:
    // %4d  - номер строки (4 символа, по правому краю)
    // %6d  - год        (6 символов)
    // %7d  - месяц      (7 символов)
    // %8d  - минимальная температура (8 символов)
    // %8d  - максимальная температура (8 символов)
    // %8.2f- средняя температура с 2 знаками после запятой (8 символов)
    printf("%4d %6d %7d %8d %8d %8.2f\n",
           line_no, year, month, min_t, max_t, avg_t);

    return 1; // Строка успешно напечатана
}

//----------------------------------------------------------------
// Таблица по всем месяцам + итог по году.
// Выводит:
//  - шапку таблицы (заголовок с названиями столбцов);
//  - строки по тем месяцам, по которым есть данные;
//  - сводную статистику по всему году (средняя, мин, макс).
//
//   info[] - массив измерений
//   n      - количество элементов в массиве info[]
//   year   - год, за который формируется таблица
//----------------------------------------------------------------
void print_year_table(sensor_t info[], int n, int year)
{
    int line_no = 0;  // Счётчик выведенных строк (номер строки таблицы для месяцев)

    // Печатаем заголовок таблицы (шапку с названиями столбцов)
    print_shap_zagolovka();

    // Проходим по всем 12 месяцам (с января по декабрь)
    // Для каждого месяца пытаемся напечатать строку статистики.
    // Строка выводится только если за этот месяц есть данные.
    for (int month = 1; month <= 12; ++month)
    {
        // Пытаемся вывести строку для текущего месяца.
        // Если функция вернула 1 (строка напечатана),
        // увеличиваем номер строки.
        if (print_month_stat_line(info, n, year, month, line_no + 1))
            line_no++;
    }

    // Разделительная линия между таблицей по месяцам и итогами по году
    printf("========================================================\n");

    // Вывод сводной статистики по всему году:
    printf("Сводная статистика за год %d:\n", year);

    // Среднегодовая температура
    SortBy_Average_year__T(info, n, year);

    // Минимальная температура за год
    SortBy_min_T_for_the_year(info, n, year);

    // Максимальная температура за год
    SortBy_max_T_for_the_year(info, n, year);
}