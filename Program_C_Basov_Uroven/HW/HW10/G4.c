/*
 * G4.c
 * 
 * По одному разу
 * 
 * В файле input.txt даны два слова не более 100 символов каждое, 
 * разделенные одним пробелом. Найдите только те символы слов, которые 
 * встречаются в обоих словах только один раз. Напечатайте их через 
 * пробел в файл output.txt 
 * в лексикографическом порядке - т.е. по порядку начиная с a,b,c,d,e и т.д.

 * Формат входных данных
 * 
	Два слова из маленьких английских букв через пробел. Длинна каждого 
	слова не больше 100 символов.

	
	Формат результата
	
	Маленькие английские буквы через пробел.

 * ------------------------------------------------------
 * char name[50]; //Создаем массив для строки из 50 символов
	printf("Enter your name: ");	// Use fgets() instead of gets()
	if (fgets(name,50,stdin)!= NULL) //Читаем строку из потока stdin
		{							// Trim newline if present 
						//(Обрезать новую строку, если она присутствует)
			name[strlen(name)-1] = '\0'; // Присваиваем последнему символу в 
								//строке сивол окончания строки ('\0')
			printf("Your name is: %s", name);
		}
	else
		{
			printf("Error reading input");
		}
---------------------------------------------------------------
 */
#include <stdio.h>

#define N 102 // Размер созаваемого массива

void sort_array(int , char a[]); //объявляем прототип функции сортировки массива по возрастанию
void Print(char arr[], int);	//Функция вывода на индикацию массива данных


int main(void)
{
//----------------------------------------------------------------------------------
//Создаем переменные для работы с файлами
//----------------------------------------------------------------------------------
	FILE *f_in, *f_out; //Создали файловые переменные 
	char * input_fn = "input.txt"; //создали указатель для входящего файла 
	char * output_fn = "output.txt";//создали указатель для исходящего файла 
	char mass1[N] = {0}; //Создали массив элементов для хранения символов строки
	char mass2[N] = {0}; //Создали массив элементов для хранения символов строки
	char mass3[N] = {0}; //Создали массив для хранения символов которые повторяются в каждом словене не более одного раза 
	signed char b, c;//Переменная в которую будет считана строка обязательно signed! иначе зациклится
	int count1=0, count2=0, count3=0, count4=0;//Вводим перемнные для подсчтета коичества считанных сиволов в строке (count1, count2) и счетчик количеств совпадения одного и того же символа в каждом слове  
    f_in = fopen(input_fn, "r");//Открыли файл на чтение
    f_out = fopen(output_fn, "w");//Открыли файл на запись

//----------------------------------------------------------------------------------
//открываем файл "input.txt" на чтение
//----------------------------------------------------------------------------------	
    if(f_in == NULL) 
    {
        //Если файл не содержит данных, то ошибка чтения файла
        perror("Error occured while opening input file!");
        return 1; // Завершем прграмму с признаком ошибки
    }
//----------------------------------------------------------------------------------
//Начинаем чтение файла посимвольно и сразу пишем первое слово в первый массив,
//а вторе во второй массив
//----------------------------------------------------------------------------------   
    // Обязательно функция fgetc(fp)
    for(int t=0 ;((c = fgetc(f_in)) != EOF) && (c != '\n'); ) 
    //Разбираем содержимое строки в файле
    //Посимвольно вычитываем строку, пока нам не встретится конец файла EOF,  
	//или признак переноса строки '\n'
		{
			if(t == 1)
				{					
					mass2[count2++] = c;
				
				}
			if(t == 0)
				{
					if(c == 0x20) //если дошли до символа пробела
						{
							t = 1;//После этого будем заполнять второй масив			
						}
					else
						{
							mass1[count1++] = c;//Заполняем первый массив до того пока не встретим символ пробела
						}
				}

		//	printf("%c ", c);
		}

//определили, что нам встретился либо конец файла EOF или признак переноса '\n'
	mass1[count1] = '\0'; // записываем вместо него признак конца строки '\0'
    mass2[count2] = '\0'; // записываем вместо него признак конца строки '\0'
  //  Print(mass1, count1);// В первом массиве лежит первое слово
  //  Print(mass2, count2);// Во втором массиве лежит второе слово
    //printf("count1=%d count2=%d count3=%d count4=%d\n", count1, count2, count3, count4);	
//теперь в каждом массиве лежит свое слово
    fclose(f_in); // Закрываем файл input_fn	
//-----------------------------------------------------------------------------------
//	printf("\n");

//-----------------------------------------------------------------------------------
//Работа с массивами: находим символы повторяющиеся по одному разу в каждом слове
//Берем нулевой элемент первого массива mass1[i], и сравниваем его со всеми 
//элементами второго массива mass2[j]. Если есть совпаения, 
//повторяющиеся не более одного раза, то копируем данный символ в третий массив mass3[count3]
//-----------------------------------------------------------------------------------   
// Проверяем первый массив на совпадающие символы, если символ повторяется, то заменяем его
//симолом  '#'
//-----------------------------------------------------------------------------------  	
	for(int i=0, temp=0; i<count1-1; i++)
		{
	// !!!!!!!!!!! Здесь нужно проверить если, mass1[i] == '#' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		
			if(mass1[i] != '#')
				{
					c = mass1[i];//Копируем в переменную c элемент первого массива
					for(int j = i+1; j < count1; j++)
						{
							if(c == mass1[j])
								{
									mass1[j] = '#';//Заменили совпадающий с с символ на '#'
									temp++;
								}
						//printf("i=%d=%c j=%d=%c temp=%d\n", i, mass1[i], j, mass1[j], temp);
						//Print(mass1, j);					
						}
					//	printf("\n");
	//Дошли до конца массива, если были совпадения, то заменяем mass1[i] симолом '#'
					if(temp >0)
						{						
							mass1[i] = '#';//Пометили совпадающие элементы
							temp = 0;
						}
					//printf("mass1[i]=%c\n", mass1[i]);
				}
		}
//	Print(mass1, count1);
//	Print(mass2, count2);	
//-----------------------------------------------------------------------------------   
// Сравниваем первый массив со вторым
//-----------------------------------------------------------------------------------  	
	for(int i=0; i<count1; i++)
		{			
			c = mass1[i];//Копируем в переменную c элемент первого массива
			for (int j = 0; j < count2; j++)//Начинаем с сравниватьс каждым элементом второго массива
					{
						if(c != '#' && c == mass2[j])//Если они равны
							{
								b = c;//Сохраняем в переменной b значение с
								count4++; //увеличиваем счетчмк совпадений
								
							}
					//printf("i=%d j=%d count3=%d count4=%d\n", i, j, count3, count4);
					}
					
	//Прошли весь массив, теперь проверим, было ли всего одно совпадение элемента?
				if(count4 == 1)
					{
	//Если было одно совпадение, то копируем этот элемент массива в третий массив, увеличивая счетчик элементов третьего массива					
						mass3[count3] = b;
						count3++;
					//	Print(mass3, count3);
					//	printf("count3=%d count4=%d\n", count3, count4);
					}
				count4 = 0;//Сбросим счетчик повторений символа перед новым входом в цикл
		}
	//	printf("count1=%d count2=%d count3=%d count4=%d\n", count1, count2, count3, count4);
	//	Print(mass3, count3);
//-----------------------------------------------------------------------------------
//Теперь в в третьем массиве mass3[count3] у нас лежат или отсутствуют необходимые символы
//Проверим на наличие символов и если они есть произведем сортировку по возрастанию
//в соответствии с лексикографическим порядком.
//----------------------------------------------------------------------------------
	if(count3 > 0) // Если больше 0, то у нас в массиве есть символы
		{	
			sort_array(count3, mass3);
		}
//-----------------------------------------------------------------------------------
//открываем файл "output.txt" на запись
//----------------------------------------------------------------------------------	
    if(f_out == NULL)
    {
        //Если файл не содержит данных, то ошибка чтения файла
        perror("Error occured while opening output file!");
        return 1; // Завершем прграмму с признаком ошибки
    }
//-----------------------------------------------------------------------------------
//Записываем содержимое отсортированного масива mass3[count3] в файл "output.txt"
//----------------------------------------------------------------------------------    
 
	for(int i=0; i<count3; i++)
		{
			fprintf(f_out,"%c ", mass3[i]); //Записываем в файл строку
		//	printf("%c ", mass3[i]); 
		}
	
    fclose(f_out); //Закрывваем файл
//----------------------------------------------------------------------------------	
	return 0;
}

//---------------------------------------------------------------------------------
//Функция сортировки массива данных по возрастанию
//---------------------------------------------------------------------------------
void sort_array(int size, char a[])
{
	int i, noSwap;// Переменная noSwap для проверки, 
	//вдруг массив уже отсортирован, значит не нужно вывоплять сортировку
	for(i=0; i<size; i++)
		{
			noSwap=1;
			for(int j=size-1; j>i; j--)
				{
					if(a[j-1] > a[j])
						{
							//SwapArr(a, j-1, j);
							int temp = a[j-1];
							a[j-1] = a[j];
							a[j] = temp;
							noSwap = 0;
						}
				}
			if(noSwap)	// Если noSwap != 0, то делаем break
				{
					break;	//Значит сортировать массив не нужно!!!
				}
		}	
		
}
//-------------------------------------------------------------------------
//Функция вывода на индикацию массива данных
//-------------------------------------------------------------------------
void Print(char arr[], int n) // Можно так писать
//int Input(int* arr, int n)	// А можно и так писать
{
	for(int i=0; i<n; i++)
		{
			printf("%c ", arr[i]);
		//	scanf("%d", &arr+i); // Есть еще и такой формат записи
			// Он называется - Арифметика Указателя			
		}
	printf("\n");	
}
//-------------------------------------------------------------------------
