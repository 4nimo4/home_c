/*
 * 7_Float_pogreshnost.c
 * 
	Погрешность вещественных чисел	
//-------------------------------------------------------------------
 * 
 * Откуда взялась погрешность?
 * 
 * У нас число 0.1, оно в виде двоичной дроби не получается точным
 * Вот как оно на самом деле выглядит:
 * 0.100000001490116119384765625
 * Если его сложить 10 раз подряд, то в 8-м разряде появится 1 и она как раз
 * станет влиять на точность числа
	0 01111111 00000000000000000000000
	0 01111111 00000000000000000000001 <- эта единичка и есть!

	IEEE-754 Floating Point Converter
	IEEE-754 Это стандарт, в нем есть +бесконечность, есть -бесконечность
 */



#include <stdio.h>
#include <math.h>


//Объявляем заголовки функций
void print_float_bin(float);	//Перевод вещественного числа в двоичный вид
								
int main() 
{
	float one=1, one_error=0;
	int i;
	print_float_bin(0.1);
	// 10 раз прибавляем 0.1
	for(i=0;i<10;i++)
		{
			one_error+=0.1;
		}
//Вместо сравнения if ( one == one_error ) используем функцию fabs из
//библиотеки <math.h>
//	if ( one == one_error )
//С точностью 0.000001 будет YES - числа равны!!
//Если увеличим точность-добавим еще пару 0, то будет NO-числа не равны!!
	if(fabs(one-one_error) < 0.000001)
		{
			printf("Yes\n");
		}
				
		
	else
		{
			printf("No\n");
		}
//--------------------------------------------------------
//Если просто выведем с помощью printf, то проблеиы мы не видим!!!!!!!!!!
//	one = 1.000000
//	one_error = 1.000000	
	printf("one = %f\n", one);
	printf("one_error = %f\n",one_error);
//-------------------------------------------------------------
//А если мы включаем визуализатор, то....	
	print_float_bin(one);
	print_float_bin(one_error);
//one = 0 01111111 00000000000000000000000
//one_error = 0 01111111 00000000000000000000001 
//то мы видим, что в младьшем разряде из-за погрешности появилась
//еще одна 1, значит наши два числа не совпадают!!

//----------Появляется так называемое правило погрешности!!!----------------------
//Мы должны сравнивать вещественные числа с определенной точностью!!!
//Мы можем говорить, что два наших числа - они у нас равны 
//с определенной точностью

//-------------------------------------------------------------
	return 0;
}

//--------------------------------------------------------------
//Перевод вещественного числа в двоичный вид
void print_float_bin(float num) 
{
//-----------------------------------------------------------------	
//	unsigned int fi = num;	// Если оставить - unsigned int fi = num;
	//то мы потеряем всю дробную часть - будет выведено 
	//0 00000000 00000000000000000001111 - 15 в десятичной или 0x0F в 16-ричной
//---------------------------------------------------------------
	// чтобы не потерять дробную часть, воспользуемся указателями
	unsigned int* fi = (unsigned int*)&num;// Указываем явное приведение типов
	for(int i=31;i>=0;i--) 
//Получим на выходе 0 10000010 11110100000000000000000
		{
		//Разряд лежит в старшем бите
//Если у нас 30-й или 22-ой разряд, то мы поставим пробельчики, чтобы отделить 
//мантиссу от порядка и знака
			if(i==30 || i==22)
				{
					putchar(' ');
				}
				
			if(*fi & (1<<i))	//А здесь делаем разъименование *fi
			//if(bit!=0)
				{
					putchar('1');
				}
			else
				{
					putchar('0');
				}

		}
	putchar('\n');
}
//-------------------------------------------------------------------

