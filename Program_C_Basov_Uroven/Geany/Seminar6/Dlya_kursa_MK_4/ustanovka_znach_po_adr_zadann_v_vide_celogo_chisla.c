/*
//--------------------------------------------------------------------
                Адресная арифметика и
                      указатели
Под операционными системами такая штука не очень как бы работает,
как правило, напрямую мы адреса не читаем и не пишем, а с микроконтроллерами
вполне такое работает:
когда у нас есть абсолютное значение адреса и мы по нему что то читаем или что то пишем
//------------------------------------------------------------------------
        Задача
//------------------------------------------------------------------------
Написать функцию

void set_value(uint64_t addr, uint32_t val)

устанавливающую значение по заданному в виде
целого числа адресу.

*/
/*
#include <stdio.h>
#include <stdint.h>

int var[100];

void set_value(uint64_t addr, uint32_t val)
{
        *(uint32_t*) addr = val;
}

int main()
{       
                                        //здесь все равно какой то пересчет адреса проиходит,
                                          //здесь не абсолютное значение, но мы в число это 
                                          //преобразуем (size_t) и передаем
        int a,b;
        printf("Введите число и адрес байта (не более var[100]) через пробел\n");
        scanf("%d%d", &a,&b);
        set_value( (size_t) & var[b], a );//здесь пересчет через массив
                                          
        printf("%d\n", var[b]);
        set_value( (size_t) (var+b), a );//здесь пересчет через арифметику указателей
        printf("%d\n", var[b]);
        set_value( (size_t) var+b, a );//здесь тоже пересчет через арифметику указателей
        printf("%d\n", var[b]);
        //~ set_value( var+b, a );//ОШИБКА!!!
        printf("%d\n", var[b]);
        return 0;
}
*/
#include <stdio.h>      // Для функций ввода-вывода
#include <stdint.h>     // Для uint32_t, uint64_t

int var[100];           // Глобальный массив из 100 целых чисел

// Функция, которая записывает значение val по адресу addr (адрес задаётся как число uint64_t)
void set_value(uint64_t addr, uint32_t val)
{
    // Преобразуем addr к указателю на uint32_t и записываем по этому адресу значение val
    *(uint32_t*) addr = val;
}

int main()
{
    int a, b;   // a — значение для записи, b — индекс в массиве

    // Просим пользователя ввести число и индекс массива через пробел
    printf("Введите число и адрес байта (не более var[100]) через пробел\n");
    scanf("%d%d", &a, &b);

    // Первый способ: передаём адрес элемента массива через приведение к size_t
    set_value((size_t)&var[b], a); // &var[b] — адрес b-го элемента массива
    printf("%d\n", var[b]);        // Проверяем, что значение записалось

    // Второй способ: арифметика указателей, эквивалентно &var[b]
    set_value((size_t)(var + b), a); // var + b — указатель на b-й элемент
    printf("%d\n", var[b]);          // Проверяем, что значение записалось
//-----------------------------------------------------------------------------------------
    // Третий способ: неверное использование — прибавляем b к адресу массива как к числу
    //Вариант set_value((size_t)var + b, a); — потенциально опасен: смещение происходит в байтах, 
    //а не в элементах массива!
    set_value((size_t)var + b, a);   // var — адрес начала массива, +b — смещение на b байт (НЕ на элемент!)
    printf("%d\n", var[b]);          // Значение может не записаться корректно (зависит от b)

    //~ set_value(var + b, a); // ОШИБКА! — нельзя передавать указатель вместо числа, если функция ждёт uint64_t

    return 0;   // Завершаем программу
}