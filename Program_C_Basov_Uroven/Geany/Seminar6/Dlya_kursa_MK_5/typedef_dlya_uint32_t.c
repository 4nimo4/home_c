/*
//--------------------------------------------------------------------
                Адресная арифметика и
                      указатели
Под операционными системами такая штука не очень как бы работает,
как правило, напрямую мы адреса не читаем и не пишем, а с микроконтроллерами
вполне такое работает:
когда у нас есть абсолютное значение адреса и мы по нему что то читаем или что то пишем
//------------------------------------------------------------------------
        Задача
//------------------------------------------------------------------------
Написать typedef для 32-битного типа с названием
my_type таким образом, чтобы можно было обращаться к
байтам(поле с названием byte), полусловам(u16), словам
(u32) и числам с плавающей запятой (f).

*/
/*
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

typedef union {
    uint32_t u32;        // обращаемся как к целому числу
    uint16_t u16[2];     // массив из 2-х uint16_t
    uint8_t byte[4];     // массив из 4-х uint8_t
    float f;             // float
} my_type;

int main() {
    my_type var;
    float f;
    uint16_t u16;
    uint8_t u8;
    uint32_t u32;

    // Используйте правильные форматы для scanf
    scanf("%hhu %hu %u %f", &u8, &u16, &u32, &f);

    var.f = f;
    printf("%u\n", var.u32);
    var.u32 = 0;
    var.byte[2] = u8;
    printf("%u\n", var.u32);
    var.u32 = 0;
    var.u16[1] = u16;
    printf("%u\n", var.u32);
    var.u32 = u32;
    printf("%f\n", var.f);

    return 0;
}
*/
#include <stdio.h>      // Для функций ввода-вывода
#include <stdlib.h>     // Для стандартных функций (не используется, но часто включают)
#include <stdint.h>     // Для uint8_t, uint16_t, uint32_t

// Определяем тип my_type как union (объединение), чтобы обращаться к одним и тем же 4 байтам разными способами
typedef union {
    uint32_t u32;        // 32-битное целое число (доступ ко всем 4 байтам сразу)
    uint16_t u16[2];     // Массив из двух 16-битных чисел (доступ к младшему и старшему полуслову)
    uint8_t byte[4];     // Массив из четырёх байт (доступ к каждому байту отдельно)
    float f;             // 32-битное число с плавающей точкой (тот же набор бит, что и u32)
} my_type;

int main() {
    my_type var;         // Объявляем переменную типа my_type
    float f;             // Переменная для ввода float
    uint16_t u16;        // Переменная для ввода 16-битного числа
    uint8_t u8;          // Переменная для ввода 8-битного числа
    uint32_t u32;        // Переменная для ввода 32-битного числа

    // Считываем значения: 8-битное, 16-битное, 32-битное и float
    // %hhu — для uint8_t, %hu — для uint16_t, %u — для uint32_t, %f — для float
    scanf("%hhu %hu %u %f", &u8, &u16, &u32, &f);

    var.f = f;           // Записываем float в объединение (те же 4 байта)
    printf("%u\n", var.u32); // Выводим эти 4 байта как 32-битное целое число

    var.u32 = 0;         // Обнуляем все 4 байта
    var.byte[2] = u8;    // Записываем 8-битное значение в третий байт (индексация с нуля)
    printf("%u\n", var.u32); // Выводим все 4 байта как 32-битное целое число

    var.u32 = 0;         // Обнуляем все 4 байта
    var.u16[1] = u16;    // Записываем 16-битное значение во второе полуслово (старшие 2 байта)
    printf("%u\n", var.u32); // Выводим все 4 байта как 32-битное целое число

    var.u32 = u32;       // Записываем 32-битное значение во все 4 байта
    printf("%f\n", var.f);   // Выводим эти 4 байта как float

    return 0;            // Завершаем программу
}