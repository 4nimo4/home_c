/*
//--------------------------------------------------------------------
                Если не хватает стека для массива?
//--------------------------------------------------------------------
У нас достатолчно много элементов а они находятся у нас в стэке, 
когда массив создаем info[SIZE]
*/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#define SIZE 3000000000     //3000000000 максимальный размер если больше, то будет ошибка
                            //а если еще больше 300000000000000000 в данном случае программа падает  
                            //- памяти в стэке не хватает
//#define SIZE 300000         //в данном случае программа не падает - памяти в стэке хватает
                            //т.к. размер стека 1800000 1Мб 800000
struct sensor
{
uint8_t day;
uint8_t month;
uint16_t year;
uint8_t hour;
int8_t t;
};

int main(int argc, char **argv)
{
 //   struct sensor info[SIZE];
 //   printf("%zu\n", sizeof(info)); //в итоге стэка нам не хватает,
    //что в этом случае делать? - все очень просто - объявляем указатель
    // struct sensor* info1
//--------------------------------------------------------------------
/*  Если эти строки внизу закоментировать -у нас создался массив с стэке
    и после исполнения программы выходит ошибка:
  - Ошибка сегментирования (образ памяти сброшен на диск)!!!!!!!!!!!!!!!!!!!
  Это произошло потому, что столько памяти (SIZE 30000000) в стеке 
  размер стека после подачи команды:  printf("%zu\n", sizeof(info));
  равен 1800000 или - 1Мб 800000байт

   struct sensor* info1 = malloc(SIZE*sizeof(struct sensor));
    if(info1 == NULL)
        return -1;
    free(info1);
*/
//--------------------------------------------------------------------    
    struct sensor* info1 = malloc(SIZE*sizeof(struct sensor)); //объявляем указатель
        //запрашиваем память под объем 3000000000 
    printf("%zu\n", SIZE*sizeof(struct sensor)); //Посмотрим сколько памяти он смог выделить
        //он без ошибок смог выделить 18000000000 18Гб памяти
    if(info1 == NULL)   //проверяем что память успешно выделилась
        return -1;      //если память не выделилась - (например не хватило) выходим с ошибкой 1
    free(info1);    //освобождаем память в любом случае
    return 0;
}