/*
//--------------------------------------------------------------------
                Процесс сборки
                Побитовые операции
//--------------------------------------------------------------------
Процесс сборки
//--------------------------------------------------------------------------
По сборке (препроцессирование → компиляция → линковка) на
удивление вопросов особо нет.
Есть один уже на курсе Владимира (STM32),когда нужно к
своему проекту подключить библиотеку, собранную без
поддержки FPU (есть такой прикол у STM, но там так и надо.
//------------------------------------------------------------------------
        Задача
//------------------------------------------------------------------------
Написать пару функций, одна из которых будет
устанавливать все биты, а другая — снимать по маске.
Возможное решение: bits.c
Простейшая вещь, но довольно полезная (особенно в
контексте того, что именно так работает большинство
флешек).
//------------------------------------------------------------------------
        Типы флеш памяти
//------------------------------------------------------------------------
1. NOR
    Воснове этого типа фйлеш-памяти лежит ИЛИ-НЕ элемент (англю NOR)
    потому, что в транзисторе с плавающим затвором низкое напряжение на
    затворе обозначает 1
    Транзистор имеет два затвора: управляющий и плавающий. Последний 
    полностью изолирован и способен удерживать электроны до 10 лет.
    В ячейке имеются, также сток и исток.
2. NAND
    В основе NAND-типа лежит И-НЕ элемент(англ. NAND). Принцип работы
    такой же, от NOR-типа отличется только размещением ячеек и их контактами.
    В результате уже не требуется подводить индивидуальный контакт к каждой ячейке,
    так что размер и стоимость NAND-чипа может быть существенно меньше.
    Также происходит запись и стирание
*/
/*
#include <stdio.h>
#include <stdint.h>
//------------------------------------------------------------------------
// Функции установки и сброса битов
//------------------------------------------------------------------------
void set_all_bits (void *arg)   //установить все элементы в единицу
{
// Писать 0xFFFFFFFFFFFFFFFF тоже не очень, так как мы вообще говоря не знаем
//длину типа. ~0 гарантирует единичные биты. 
* (unsigned int*)arg = ~0;  //здесь сделано отрицание 0 нуля, чтобы в зависимости от
                            //ширины типа он подстроится под любой нужный тип,
                            //т.к. на контроллерах int может быть и 16bit и 32bit и 8bit
}
int reset_some_bits(void *dest, unsigned int val)   //функция сброса битов
{
*(unsigned int*)dest &= val;//приведение типов
return (*(unsigned int*)dest == val);
}
int set_some_bits(void *dest, unsigned int val) ///функция установки битов
{
*(unsigned int*)dest |= val;//приведение типов
return (*(unsigned int*)dest == val);
}
//-----------------------------------------------------------------------

int main()
{
    float var = 0;
    uint32_t a=4095;
    uint32_t b=2000;
    uint32_t c=4095;
    uint32_t d=0xffff;
    int status = 0;
    //~ scanf("%x%x%x%x", &a, &b, &c, &d); //a=4095, b=2000, c=4095, d=0xffff
    set_all_bits(&a);   //установили все биты
    printf("set_all_bits a: %#X\n" ,a);
    status = reset_some_bits(&a, 0x25); //сбросили по маске 0x25
    status = printf("reset_some_bits 0x25 %d %#X\n" ,status, a);
    set_all_bits(&a);
    printf("set_all_bits a: %#X\n" ,a);

    status = reset_some_bits(&var, b);
    printf("reset_some_bits %d %#X %f\n" ,status, a, var);
    status = reset_some_bits( &var, c );
    printf("reset_some_bits %d %#X %f\n" ,status, a, var);
    set_all_bits(&var);
    status = reset_some_bits(&var, d);
    printf("reset_some_bits %d %#X %f\n" ,status, a, var);
    return 0;
}
//-----------------------------------------------------------------------
Пояснения:
//-----------------------------------------------------------------------
Все функции работают с указателями типа
void*
, чтобы можно было передавать переменные любого типа (но реально корректно только для int/uint32_t).
set_all_bits
устанавливает все биты в 1.
reset_some_bits
сбрасывает все биты, кроме тех, что указаны в маске.
set_some_bits
устанавливает только те биты, что указаны в маске.
В
main
показаны примеры работы с этими функциями для переменных типа
uint32_t
и
float
(для float это не рекомендуется, но возможно для демонстрации побитовых операций).
//-----------------------------------------------------------------------
*/
#include <stdio.h>      // Для функций ввода-вывода
#include <stdint.h>     // Для uint32_t

//------------------------------------------------------------------------
// Функция установки всех битов в переменной (делает все биты равными 1)
//------------------------------------------------------------------------
void set_all_bits(void *arg)
{
    // Преобразуем указатель к unsigned int* и записываем ~0 (все биты 1)
    // ~0 — это побитовое отрицание 0, даёт все единицы для любого размера int
    *(unsigned int*)arg = ~0;
}

//------------------------------------------------------------------------
// Функция сброса (очистки) битов по маске: оставляет только те биты, что есть в val
//------------------------------------------------------------------------
int reset_some_bits(void *dest, unsigned int val)
{
    // Побитовое И: сбрасываем все биты, кроме тех, что есть в val
    *(unsigned int*)dest &= val;
    // Возвращаем 1, если результат равен val, иначе 0
    return (*(unsigned int*)dest == val);
}

//------------------------------------------------------------------------
// Функция установки битов по маске: устанавливает те биты, что есть в val
//------------------------------------------------------------------------
int set_some_bits(void *dest, unsigned int val)
{
    // Побитовое ИЛИ: устанавливаем биты, которые есть в val
    *(unsigned int*)dest |= val;
    // Возвращаем 1, если результат равен val, иначе 0
    return (*(unsigned int*)dest == val);
}

//-----------------------------------------------------------------------

int main()
{
    float var = 0;          // Переменная типа float (используется для демонстрации)
    uint32_t a = 4095;      // Пример переменных для работы с битами
    uint32_t b = 2000;
    uint32_t c = 4095;
    uint32_t d = 0xffff;
    int status = 0;         // Для хранения результата функций

    //~ scanf("%x%x%x%x", &a, &b, &c, &d); // Можно раскомментировать для ввода значений

    set_all_bits(&a);       // Устанавливаем все биты переменной a (a = 0xFFFFFFFF)
    printf("set_all_bits a: %#X\n", a);

    status = reset_some_bits(&a, 0x25); // Сбрасываем все биты, кроме тех, что в маске 0x25
    status = printf("reset_some_bits 0x25 %d %#X\n", status, a);

    set_all_bits(&a);       // Снова устанавливаем все биты переменной a
    printf("set_all_bits a: %#X\n", a);

    // Демонстрация работы с переменной типа float (не рекомендуется, но возможно)
    status = reset_some_bits(&var, b);
    printf("reset_some_bits %d %#X %f\n", status, a, var);

    status = reset_some_bits(&var, c);
    printf("reset_some_bits %d %#X %f\n", status, a, var);

    set_all_bits(&var);
    status = reset_some_bits(&var, d);
    printf("reset_some_bits %d %#X %f\n", status, a, var);

    return 0;
}