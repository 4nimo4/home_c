/*
//--------------------------------------------------------------------
                Адресная арифметика и
                      указатели
Под операционными системами такая штука не очень как бы работает,
как правило, напрямую мы адреса не читаем и не пишем, а с микроконтроллерами
вполне такое работает:
когда у нас есть абсолютное значение адреса и мы по нему что то читаем или что то пишем
//------------------------------------------------------------------------
        Задача
//------------------------------------------------------------------------
Сделать парсер файла формата XPM.
Функция с прототипом
int parse_xpm(char** xpm, uint16_t *result)
Есть текстовый файл — массив строк заданного формата
с xpm внутри (один символ на точку, два цвета),
необходимо найти строку, определяющую чёрный цвет и
проанализировать файл, записывая в массив форму
кривой — то есть её координату y для каждой координаты
x (считаем, что эта зависимость однозначна).
Возвращаемое
 значение
 функции
 —
 ширина
изображения. Например, xpm.c
//----------------------------------------------------------------
                    Решение
//----------------------------------------------------------------
// XPM 
static char *dummy[]={
"100 100 2 1",
"# c #000000",
". c #ffffff",
"######..............................................................................................",
"......######........................................................................................",
"............######..................................................................................",
"..................##................................................................................",
"...................#................................................................................",
"...................#................................................................................",
"...................#................................................................................",
"....................#...............................................................................",
"....................#...............................................................................",
"....................#...............................................................................",
".....................#..............................................................................",
"......................#.............................................................................",
"......................#.............................................................................",
".......................#............................................................................",
".......................##...........................................................................",
"........................#...........................................................................",
"........................##..........................................................................",
".........................##.........................................................................",
"..........................##........................................................................",
"...........................##.......................................................................",
"............................#.......................................................................",
".............................#......................................................................",
"..............................##....................................................................",
"...............................#....................................................................",
"................................#...................................................................",
".................................##.................................................................",
"..................................##................................................................",
"....................................###.............................................................",
".......................................#............................................................",
"........................................##..........................................................",
"..........................................##........................................................",
"............................................###.....................................................",
"...............................................###..................................................",
"..................................................#.................................................",
"...................................................#######..........................................",
"..........................................................###.......................................",
".............................................................####################...................",
".................................................................................##########.........",
"..........................................................................................##........",
"............................................................................................###.....",
"...............................................................................................#....",
"................................................................................................#...",
".................................................................................................#..",
".................................................................................................#..",
".................................................................................................#..",
".................................................................................................##.",
"..................................................................................................##",
*/

// В файле 1.xpm должен быть определён рисунок с именем dummy
// В нём — двухцветный рисунок, чёрная линия на любом (непрозрачном) фоне
#define NAME dummy           // Определяем макрос NAME как dummy (имя массива из XPM)
#include "1.xpm"             // Подключаем XPM-файл как массив строк
#include <stdio.h>           // Для ввода-вывода
#include <stdint.h>          // Для uint16_t

#define MAX_W (1000)         // Максимальная ширина изображения

uint16_t array[MAX_W];       // Массив для хранения результата (y-координат линии)

int parse_xpm(char** xpm, uint16_t *result)
{
    int width=0, height=0, colors=0, syms_per_pixel=0; // Переменные для параметров XPM
    char black;                // Символ, обозначающий чёрный цвет
    int color = 1;             // Переменная для хранения кода цвета (ищем 0 — чёрный)
    int line = 0;              // Индекс текущей строки XPM

    // Считываем первую строку XPM: ширина, высота, количество цветов, символов на пиксель
    sscanf (xpm[line++], "%d%d%d%d", &width, &height, &colors, &syms_per_pixel);

    // Проверяем, что XPM соответствует ожидаемому формату: 2 цвета, 1 символ на пиксель
    if(colors != 2 || syms_per_pixel != 1)
    {
        return 0; // Если не соответствует — выход
    }

    // Ищем строку, определяющую чёрный цвет (код цвета 0)
    while (color != 0 && line < colors+1)
    {
        sscanf(xpm[line++], "%c c #%x", &black, &color);
    }

    // Если чёрный цвет не найден — выход
    if (color != 0)
    {
        return 0;
    }

    int image_start = line; // Запоминаем, с какой строки начинаются строки изображения

    // Проходим по всем строкам изображения
    for (int img_line = 0; img_line < height; img_line++)
    {
        // Проходим по всем столбцам (x-координатам)
        for (int pos = 0; pos < width ; pos++)
        {
            // Если символ в позиции соответствует чёрному цвету
            if (NAME[image_start + img_line][pos] == black)
            {
                // Запоминаем y-координату (от нижнего края)
                result[pos] = height - img_line;
            }
        }
    }
    return width; // Возвращаем ширину изображения
}

int main (int argc, char ** argv)
{
    int width = parse_xpm(NAME, array); // Парсим XPM, получаем ширину

    // Выводим результат: для каждого x — y-координата линии
    for (int i = 0; i < width; i++)
    {
        printf("%d ", array[i]);
    }
    putchar('\n'); // Перевод строки
    return 0;
}
