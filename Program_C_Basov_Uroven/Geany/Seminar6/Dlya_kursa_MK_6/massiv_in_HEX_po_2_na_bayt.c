/*
//--------------------------------------------------------------------
                Адресная арифметика и
                      указатели
Под операционными системами такая штука не очень как бы работает,
как правило, напрямую мы адреса не читаем и не пишем, а с микроконтроллерами
вполне такое работает:
когда у нас есть абсолютное значение адреса и мы по нему что то читаем или что то пишем
//------------------------------------------------------------------------
        Задача
//------------------------------------------------------------------------
Написать функцию
print_array_similarly_to_intel_hex(void* addr, int len),
выводящую на экран массив в следующем текстовом
формате (все числа выводятся шестнадцатеричными
числами в верхнем регистре, по два символа на байт):

1. Первая строка: двоеточие, затем все байты адреса (705,706,707,708,709,70A), кроме двух
младших;
2. Каждая следующая строка содержит данные, разложенные по полям:
1. Двоеточие (`':'`)
2. Первое поле — два байта (младшие два байта тех данных,
которые выводятсяв данной строке — для первой строки данных это
будут просто два младших байта переменной `addr`(04,05,06,07,08,09,0A), для каждой
следующей строки прибавляем к предыдущему адресу число байтов
данных, записанных в предыдущей строке).
3. Второе поле — число 00
4. Третье поле — данные (не более 16 байтов, подряд)
5. Четвёртое поле — один байт, считающийся как сумма всех
предыдущих байтов в строке (с переполнением, разумеется).


*/
/*
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
            //Для самостоятельного разбора!
uint32_t array[100];
void print_array_similar_to_intel_hex(void* addr, int len)
{
    int i=0;
    uint8_t checksum = 0;
    printf(":%04X\n", (unsigned int)(((uint64_t)addr >> 16) & 0xFFFF));
    for( i = 0; i < len; ) // Здесь я не инкрементирую i, так как удобнее 
                    //делать проверку внутри тела, но после инкрементирования
    {
        if( i % 16 == 0) // т.к. пишем не более 16 байтов на строку по 
                         //условию, i%16 - признак начала строки
        {
            printf(":%04X00", (unsigned int)((uint64_t)addr & 0xFFFF));
            checksum = ((uint64_t)addr & 0xFF) + (((uint64_t)addr >> 8) & 0xFF);
        }
        printf("%02X", *(uint8_t*)addr);
        checksum += *(uint8_t*)addr;
        addr++;
        i++; /// А вот тут увеличиваем i и смотрим, не закончилась ли строка
        if( i % 16 == 0 || i == len) // т.к. пишем не более 16 байтов на строку по
                                     //условию, i%16 - признак конца строки, либо -
                                     //если завершили всю записб
        {
            printf( "%02X\n", checksum );
        }
    }
}

int main()
{
    array[0] = 0x12345678;
    array[1] = 0xABCDEF12;
    print_array_similar_to_intel_hex(array, 100);
    return 0;
}
*/
#include <stdio.h>      // Для printf
#include <stdint.h>     // Для uint32_t, uint8_t, uint64_t
#include <inttypes.h>   // Для форматов вывода (не используется, но можно для расширения)

uint32_t array[100];    // Массив для примера (100 элементов по 4 байта)

// Функция вывода массива в стиле Intel HEX
void print_array_similar_to_intel_hex(void* addr, int len)
{
    int i = 0;                  // Индекс по байтам
    uint8_t checksum = 0;       // Контрольная сумма для строки

    // Первая строка: выводим двоеточие и старшие байты адреса (кроме двух младших)
    printf(":%04X\n", (unsigned int)(((uint64_t)addr >> 16) & 0xFFFF));

    // Основной цикл по всем байтам массива
    for (i = 0; i < len; )
    {
        // Если это начало новой строки (каждые 16 байт)
        if (i % 16 == 0)
        {
            // Выводим двоеточие, два младших байта адреса и поле 00
            printf(":%04X00", (unsigned int)((uint64_t)addr & 0xFFFF));
            // Контрольная сумма начинается с суммы двух младших байтов адреса
            checksum = ((uint64_t)addr & 0xFF) + (((uint64_t)addr >> 8) & 0xFF);
        }

        // Выводим очередной байт данных в HEX (два символа, верхний регистр)
        printf("%02X", *(uint8_t*)addr);
        // Прибавляем байт к контрольной сумме
        checksum += *(uint8_t*)addr;
        // Переходим к следующему байту
        addr++;
        i++;

        // Если строка закончилась (16 байт) или это последний байт массива
        if (i % 16 == 0 || i == len)
        {
            // Выводим контрольную сумму (HEX, два символа) и перевод строки
            printf("%02X\n", checksum);
        }
    }
}

int main()
{
    array[0] = 0x12345678;      // Пример данных: первый элемент массива
    array[1] = 0xABCDEF12;      // Пример данных: второй элемент массива

    // Вызываем функцию для вывода массива в HEX-формате (100 байт)
    print_array_similar_to_intel_hex(array, 100);

    return 0;                   // Завершаем программу
}