/*
//-----------------------------------------------------------------
            Динамический массив
до этого обсуждали VLA массив - где мы считываем переменную и по ее размеру выделяем массив
, но при этом существует проблемма, что если у нас данные выходят за рамки массива, мы никак 
не можем увеличить размер массива - т.е. мы один раз память выделили и все.

Динамический массив — это массив, размер которого может изменяться во время
исполнения программы.



*/
//-----------------------------------------------------------------------------
// Пример организации стека через динамический массив
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
// 
typedef int datatype;

typedef struct stack
{
    datatype *item; //Здесь именно нужен указатель, а не массив иначе будет ошибка!!
    int size;
    int sp;
} stack;
//-----------------------------------------------------------------------------
//Инициализация стэка
//-----------------------------------------------------------------------------
void init_stack(stack *st)
{
    st->size=2; //Мы задаем неачальный размер 
    st->sp=0;
    st->item=malloc(st->size *sizeof(datatype)); //Выделили память мз кучи
}
//-----------------------------------------------------------------------------
//Кладем в стэк
//-----------------------------------------------------------------------------
void push (stack *st, datatype value)   //передаем указатель на стэк и value
{
    if(st->sp==st->size-1)  //Первое что надо проверить , есть ли у нас еще место в стэке
    {
        //Если дошли до границы стэке, там у нас больше местиа нету
        st->size=st->size*2;    //Значит мы size умножаем на 2 
        st->item=realloc(st->item, st->size*sizeof(datatype)); //передаем старый размер 
                                                            //и новый размер и увеличиваем выделяемую память
    }
    st->item[st->sp++]=value;   //добавляем элемент - кладем по указателю и указатель увеличиваем
}
//-----------------------------------------------------------------------------
//извлекаем из стека
//-----------------------------------------------------------------------------
void pop (stack *st, datatype *value)
{
    if(st->sp < 1) //Если мы пытаемся извлечь из стэка, а там осталось меньше одного элемента = 0
    //if (empty_stack(st))
    {
        printf("stack empty");  //то выводим stack пуст
        exit(1);                //и завершение программы с ошибкой 1
    }
*value=st->item[--(st->sp)]; //Если все ок, то мы сначала уменьшаем индекс стэка, 
                    //а потом берем по этому индексу, соответствующий item - элемент массива
    //т.е. мы не возвращаем datatype, а по соответствующему указателю записываем
}

int empty_stack(stack *st) //если стек пуст
{
    return (st->sp < 1);
}
int main()
{
    stack st;
    stack *pst = &st;
    int a,i;                //вводим переменне a - данные и i - индекс 
    
    init_stack(pst);    //Мы проинициализировали стэк и будем вводить туда данные, пока не введем 0
    while (1)
    {
        scanf("%d",&a);     //для работы со стеком по цифрам нужно вводить числа через пробелы или по одному.
        if (a == 0) break; // 0 — признак окончания ввода
        push(pst,a);
    }
    // Выводим в порядке ввода тольког те элементы которые положили в стэк, а не весь массив стэка
    printf("Выводим тольког те элементы которые положили в стэк, а не весь массив стэка\n");
    for( i= 0; i < st.sp; i++)       //Распечатаем наш стэк в обычном цикле
        printf("%d ",st.item[i]);   //st.item[i] - это обращение к конкретному элементу с индексом i
    printf("\n");

    // Выводим в порядке ввода
    printf("Выводим весь массив стэка\n");
    for( i= 0; i < st.size; i++)       //Распечатаем наш стэк в обычном цикле
        printf("%d ",st.item[i]);
    printf("\n");


    // Выводим в обратном порядке (стек) 
    printf("Выводим стэк в порядке извлечения\n");   
    while(!empty_stack(pst))    //Извлекаем наш стэк пока не равен !empty_stack
    {
        pop(pst,&a);
        printf("%d ",a);
    }
    printf("\n");
    return 0;       
}