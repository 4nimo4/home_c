/*
//-----------------------------------------------------------------
            Стек — LIFO - FIFO
//-----------------------------------------------------------------
        Однонаправленный список
//-----------------------------------------------------------------
Это такой типа данных, в котором каждое звено содержит ссылку на следующее.

struct list                     //Объявили структуру список list
{
    uint32_t id;                //Здесь могут быть некие поля - id
    struct list *next;          //Объявили стркутуру на указатель того же типа - *next
} list;                         //имя переменной list

При объявлении таких типов удобно использовать typedef

typedef struct list 
{
    uint32_t id;
    ...
    struct list *next;          //Внимание! Тип структуры не может иметь поля типа самой этой
                                //структуры - (struct list next), однако допускаются указатели 
                                //на тип самой структуры - (struct list *next).

} list_t;                       //вводим имя типа list_t чтобы не писать каждый раз struct list

//-----------------------------------------------------------------
            Стек - LIFO и очередь - FIFO
//-----------------------------------------------------------------
● Стек (англ. stack) – структура данных, предоставляющая
доступ к элементам в порядке, обратном порядку добавления.
Элемент, добавленный в стек последним, будет возвращен
первой же операцией извлечения.

Операции:
● push - добавить в стек
● pop - извлечь из стека

//-----------------------------------------------------------------
            Инициализация стека
//-----------------------------------------------------------------

*/
#include <stdio.h>
#include <stdlib.h>

typedef int datatype;

typedef struct list         //Объявили структуру список - struct list
{
    datatype value;
    struct list * next;     //Объявили стркутуру на указатель того же типа - *next
}stack;                     //С именем структуры - stack
//-----------------------------------------------------------------
//            Помещаем данные в стек
//-----------------------------------------------------------------
void push(stack **p,datatype data) //В функцию push мы передаем двойной указактель (**p)- потому, что
                                   //у нас будет сам заголовок меняться, а сам заголовок уже является 
                                   //указателем, а также передаем (datatype data) - это то что мы будем pushitь
                                   //в наш стек
{
    stack *ptmp;                    //Объявили переменнную-указатель типра stack
    ptmp=malloc(sizeof(stack));     //выделяем память из кучи для нашей переменной stack
    ptmp->value=data;               //Помещаем в выделенную память данные
    ptmp->next=*p;                  //Прицепились к следующему заголовку            
    *p=ptmp;                        //теперь заголовок *p сделали главным
    //таким образом мы можем добавлять данные в очередь последовательно как вагончики в состав поезда
}

//-----------------------------------------------------------------
//          Вспомогательная функция 1 вариант
//     Проверка на доступность - (свободен ли стек или уже заполнен)
//-----------------------------------------------------------------
/*
_Bool empty_stack(stack *p)     //Если p==0 , то стекуже весь закончился
{
    return p==NULL;
}
*/
//-----------------------------------------------------------------
//          Вспомогательная функция 2 вариант
//      С помощью макроса
//     Проверка на доступность - (свободен ли стек или уже заполнен)
//-----------------------------------------------------------------
#define empty_stack(p)   ((p) == NULL)  //Если p==0 , то стекуже весь закончился

//-----------------------------------------------------------------
//  Извлекаем данные из стека
//-----------------------------------------------------------------
datatype pop(stack **p)     //функция возвращает наш тип данных - datatype
                            //В нее мы передаем снова двойной заголовок, т.к. 
                            //мы будем передвигать голову стэка
{
    stack *ptmp = *p;      //сохраняем заголовок в переменную *ptmp   
    datatype c;             //объявили переменную datatype c
    if(empty_stack(*p))     //Проверяем, не пытаемся ли мы взять из пустого списка
    {
        exit (1); // Попытка взять из пустого стека - ошибка и аварийное завершение программы 
                    //с кодом 1
    }
    c=ptmp->value;      //вычитываем в переменную c наше значение
    *p=ptmp->next;      //Меняем - двигаенм заголовок списка
    free(ptmp);         //Освобождаенм выделенную память
return c;               //возвращаем наши данные
}

int main()
{
    stack *p=NULL;           //Объявим указатель на переменнуюж типа stack и присвоим ей значение NULL
                             //Это важно для корректной работы - присвоить NULL
    for(int i=1;i<=5; i++)
    {
        push(&p,i);
    }
    for(int i=1;i<=5; i++)    //Нормальная работа программы
    //for(int i=1;i<=6; i++)      //Создали ошибку, - пытаемся вывести на печать элеменнт, за пределпми массива
    {
        printf("%d\n",pop(&p)); // 5 4 3 2 1
    }

return 0;
}

