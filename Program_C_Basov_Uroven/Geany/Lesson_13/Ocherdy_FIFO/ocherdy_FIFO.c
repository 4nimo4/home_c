/*
//-----------------------------------------------------------------
            Очередь - FIFO
//-----------------------------------------------------------------
        Стек - LIFO и очередь - FIFO
//-----------------------------------------------------------------
В очереди элементы извлекаются в том же порядке, в котором
они были добавлены.

Операции:
● enqueue - добавить в очередь.
● dequeue - взять из очереди.

*/
//-----------------------------------------------------------------------------
// Пример реализации очереди при помощи однонаправленного списка
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

typedef int datatype;

typedef struct list 
{
    datatype value;
    struct list * next;
}queue;

_Bool empty_queue(queue *p) 
{
    return p==NULL;
}
//-----------------------------------------------------------------------------
//удаление элемента
//-----------------------------------------------------------------------------
datatype dequeue(queue **p) //удалять мы будем голову
{
    queue *ptmp=*p; //делаем переменную *ptmp
    datatype c;     //присваиваем голову datatype c
    if(empty_queue(*p)) //проверяем, что у нас не пустая очередь
    {
        // Попытка взять из пустой очереди
        fprintf(stderr,"Error. Queue is empty\n");
    exit(1);
    }
    c=ptmp->value;  //в c записываем ptmp->value
    *p=ptmp->next;  //а заголовок меняем на ptmp->next, старый заголовок на новый передвинули
    free(ptmp);     //а здесь освободили место
    return c;       //вернули c c value
}
//-----------------------------------------------------------------------------
//Добавить элемент в очередь
//-----------------------------------------------------------------------------
void enqueue(queue **pl,datatype data)    //Передаем двойной указатель на список и datatype data
{
    queue *ptmp = *pl; //определяем переменную-указатель типа *ptmp и записываем туда
                                    //указатель на заголовок списка *pl и делаем еще одну переменную *elem
                            //---------------------------------------------------------
    queue *elem = malloc(sizeof(queue)); //делаем еще одну переменную *elem в elem мы создаем узел 
                            //------------------------------------------------
    elem->value = data;                 //записали в него данные data
    elem->next = NULL;                  //отметили next = NULL т.е. указали что он будет последним
    if(*pl==NULL)            //если у нас список пуст,           
    {
        *pl = elem;       //то мы в качестве заголовка списка назначаем первей узел 
        return;
    } 
    while(ptmp->next != NULL)    //пока ptmp->next != NULL, 
                        //мы последовательно проходим по всем узлам пока не встретим NULL
        ptmp=ptmp->next;    //переходим к следующему элементу
    ptmp->next = elem;  //когда все же нам встретился NULL мы пристыковываем созданный узел, который 
                        //теперь в свою очередь будет указывать на NULL
}
//-----------------------------------------------------------------------------
//рекурсивное добавление элемента в очередь
//деревья, списки с помощью рекурсии такого типа достаточно хорошо работают
//-----------------------------------------------------------------------------
void enqueue_recurs(queue **pl, datatype data)
{
    if(*pl == NULL) //если *pl == NULL
    {
        (*pl) = malloc(sizeof(queue));    //выделили память
        (*pl)->value = data;                    //записали туда данные
        (*pl)->next = NULL;                     //в next записали NULL и вышли
        //return;                     //в данном случае return можно не писать, т.к. мы точно после выхода из if
                                      //в else точно не попадаем     
    }
    else    //в противном случае рекурсивно вызываем enqueue_recurs
            //будем ее вызывать до тех пор пока не дойдем до конца списка
    {
        enqueue_recurs(&((*pl)->next),data);
    }
}
//-----------------------------------------------------------------------------
//Стандартный вариант функции print
//-----------------------------------------------------------

void print_list(queue *pl) //передаем наш список
{
    //вариант с циклом for 
    for(queue *i = pl; i; i = i->next)
    {
        printf("%d ",i->value); //печатаем value
    }
    //вариант с циклом while
    
  //  while(pl)
   // {
    //    printf("%d ",pl->value); //печатаем value
  //      pl = pl->next;
   // }
    
  //  printf("\n");
}


int main()
{
    queue *pq=NULL;
   
//-----------------------------------------------------------------------------
//Добавить элемент в очередь
//-----------------------------------------------------------------------------
     for(int i = 1;i <= 5; i++) 
       enqueue_recurs(&pq,i);
//-----------------------------------------------------------------------------
//Вызовем print_list - напечатаем нашу очередь
//-----------------------------------------------------------------------------
    print_list(pq); 
//-----------------------------------------------------------------------------
//Удалить элемент из очереди
//-----------------------------------------------------------------------------       
    for(int i=1;i<=5; i++)
    {
        printf("%d\n",dequeue(&pq));
    }  
           
    return 0;
}