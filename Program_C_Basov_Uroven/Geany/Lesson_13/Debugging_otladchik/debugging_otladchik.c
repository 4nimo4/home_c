/*
//-----------------------------------------------------------------
            Debugging - Отладчик
//-----------------------------------------------------------------
Отладка с использованием отладчика
Преимущество такого рода отладки состоит в том, что:
не требуется никаких дополнительных усилий для начала отладки кода
просто запускаете отладчик и указываете его на исполняемый файл
вы находитесь в работающей программе
есть возможность исследовать ее в реальном времени

jtag интерфейс
*/
#include <stdio.h>

//-----------------------------------------------------------------------------
// 3. Использование отладчика.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Пример реализации очереди при помощи однонаправленного списка
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <stdint.h>

//-----------------------------------------------------------------------------
// Этот кусок из домашки - видео на -35.34 минуте
//-----------------------------------------------------------------------------
typedef struct sensor //Заполним поля структуры sensor
	{//Лучше начинать с самых больших полей, это связано с последующим выравниваем
		uint16_t year; //т.к год 2025, то используем тип uint_16 - самое большое поле
		uint8_t month; //месяц
		uint8_t day;// день
		uint8_t watch; //часы -----------------------------------------------------
		uint8_t minutes; //минуты ----------------------------------------------------		
		int8_t t;		//температура выбрали тип int т.к. от - до + 
	}datatype;//Задали имя пеменной sensor_t для структуры struct sensor и переобределили ее тип typedef
//-----------------------------------------------------------------------------


//typedef int datatype;

typedef struct list 
{
    datatype value;
    struct list * next;
}queue;

_Bool empty_queue(queue *p) 
{
    return p==NULL;
}
//-----------------------------------------------------------------------------
//удаление элемента
//-----------------------------------------------------------------------------
datatype dequeue(queue **p) //удалять мы будем голову
{
    queue *ptmp=*p; //делаем переменную *ptmp
    datatype c;     //присваиваем голову datatype c
    if(empty_queue(*p)) //проверяем, что у нас не пустая очередь
    {
        // Попытка взять из пустой очереди
        fprintf(stderr,"Error. Queue is empty\n");
    exit(1);
    }
    c=ptmp->value;  //в c записываем ptmp->value
    *p=ptmp->next;  //а заголовок меняем на ptmp->next, старый заголовок на новый передвинули
    free(ptmp);     //а здесь освободили место
    return c;       //вернули c c value
}
//-----------------------------------------------------------------------------
//Добавить элемент в очередь
//-----------------------------------------------------------------------------
void enqueue(queue **pl,datatype data)    //Передаем двойной указатель на список и datatype data
{
    queue *ptmp = *pl; //определяем переменную-указатель типа *ptmp и записываем туда
                                    //указатель на заголовок списка *pl и делаем еще одну переменную *elem
                            //---------------------------------------------------------
    queue *elem = malloc(sizeof(queue)); //делаем еще одну переменную *elem в elem мы создаем узел 
                            //------------------------------------------------
    elem->value = data;                 //записали в него данные data
    elem->next = NULL;                  //отметили next = NULL т.е. указали что он будет последним
    if(*pl==NULL)            //если у нас список пуст,           
    {
        *pl = elem;       //то мы в качестве заголовка списка назначаем первей узел 
        return;
    } 
    while(ptmp->next != NULL)    //пока ptmp->next != NULL, 
                        //мы последовательно проходим по всем узлам пока не встретим NULL
        ptmp=ptmp->next;    //переходим к следующему элементу
    ptmp->next = elem;  //когда все же нам встретился NULL мы пристыковываем созданный узел, который 
                        //теперь в свою очередь будет указывать на NULL
}
//-----------------------------------------------------------------------------
//рекурсивное добавление элемента в очередь
//деревья, списки с помощью рекурсии такого типа достаточно хорошо работают
//-----------------------------------------------------------------------------
void enqueue_recurs(queue **pl, datatype data)
{
    if(*pl == NULL) //если *pl == NULL
    {
        (*pl) = malloc(sizeof(queue));    //выделили память
        (*pl)->value = data;                    //записали туда данные
        (*pl)->next = NULL;                     //в next записали NULL и вышли
        //return;                     //в данном случае return можно не писать, т.к. мы точно после выхода из if
                                      //в else точно не попадаем     
    }
    else    //в противном случае рекурсивно вызываем enqueue_recurs
            //будем ее вызывать до тех пор пока не дойдем до конца списка
    {
        enqueue_recurs(&((*pl)->next),data);
    }
}


//-----------------------------------------------------------------------------
//Вариант функции print для домашки - typedef struct sensor
//---------------------------------------------------------------------------
//здесь структуру мы передаем не через указатель, а через стэк - это не очень хорошо
//----------------------------------------------------------------
// Из ДОМАШКИ     Функция вывода на индикацию элементов массива 
//------------------------------------------------------------------
void print( datatype info)
{
	printf("===================================\n");
	//for (int i = 0; i < number; i++)
	//{
		printf("%04d-%02d-%02d watch=%02d min=%02d t=%3d\n", info.year,
			   info.month, info.day, info.watch, info.minutes, info.t);
	//}
}
//------------------------------------------------------------------

void print_list(struct list *pl)
{

    //вариант с циклом for 
    for(struct list *i = pl; i; i = i->next)
    {
        print(i->value); //печатаем value
    }
    printf("\n");
}
//-----------------------------------------------------------------------

int main()
{
    queue *pq=NULL;
    //-----------------------------------------------------------------------------
    //Добавить элемент в очередь - Вариант функции print для домашки - typedef struct sensor
    //-----------------------------------------------------------------------------     
    datatype d = {2025,6,15,12,30,25};
    for(int i = 1;i <= 5; i++) 
       enqueue_recurs(&pq,d);
//-----------------------------------------------------------------------------
//Добавить элемент в очередь
//-----------------------------------------------------------------------------
//    for(int i = 1;i <= 5; i++) 
//       enqueue(&pq,i);
//-----------------------------------------------------------------------------
//Вызовем print_list - напечатаем нашу очередь
//-----------------------------------------------------------------------------
    print_list(pq); 
//-----------------------------------------------------------------------------
//Удалить элемент из очереди
//-----------------------------------------------------------------------------       
    for(int i=1;i<=5; i++)
    {
        //printf("%d\n",dequeue(&pq));
        //-----------------------------------------------------------------------------
        //Вариант функции print для домашки - typedef struct sensor
        //--------------------------------------------------------------------------- 
        print(dequeue(&pq));
        //---------------------------------------------------------------------------
    }  
           
    return 0;
}