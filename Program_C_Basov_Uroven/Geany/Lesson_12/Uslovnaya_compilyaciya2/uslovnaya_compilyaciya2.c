/*
    Защита от двойного включения библиотек
    
Другим важным случаем использования условной компиляции
является защита от двойного включения заголовочного .h файла в
.c файл реализации.
Заголовочные файлы содержат объявления переменных и
функций, которые могут привести к ошибкам в случае их
неоднократного включения в текст программы.

    #ifndef _STDIO_H
    #define _STDIO_H
    <... текст файла ...>
    #endif

    Условная компиляция

Также, условная компиляция может использоваться для комментирования
больших фрагментов кода. Комментарии в языке Си не могут вкладываться
друг в друга, поэтому невозможно закомментировать текст функции с
помощью /* и */
/*, если он уже содержит такие комментарии. Тогда нужно
использовать условную компиляцию:

    #if defined COMMENT_THIS
    <some code to comment>
    #endif

    Кроссплатформенность

Условная компиляция — для фрагментов программ, которые выглядят по-
разному в разных операционных системах.

    #if defined __APPLE__
    <code for mac os>
    #elif defined __linux__
    <code for Linux>
    #elif defined _WIN32
    <code for Windows>
#   endif 

    Что же выбрать, макрос или функцию?

Задачи можно решать и с помощью макроса и с помощью функций. Нет строгих правил
что лучше. Можно дать лишь несколько рекомендаций, которые позволят принять
правильное решение.
➔
 Если макрос вызывать 20 раз, то в программу вставляются 20 строк этого макроса.
➔
 Если функцию вызвать 20 раз, то в программе содержится единственный экземпляр ее
операторов, но программа совершает переход к фрагменту кода функции и обратно,
что в целом замедляет ее работу, т.е. Этот процесс может занимать больше времени
чем выполнение встраиваемого кода.
Для макроса не важны типы и размеры, он манипулирует со строками, что может
приводить к ошибкам.

    Когда стоит выбрать макрос?
    
Стоит выбрать макрос вместо функции если:
➔
 Если макрос можно описать одной строкой
➔
 Можно использовать макрос для реализации простых
функций
➔
 Если вы намерены использовать макрос вместо
функции для ускорения, стоит подумать, а даст ли это
желаемый эффект. Воспользуйтесь профилированием,
для определения скорости работы программы

*/
