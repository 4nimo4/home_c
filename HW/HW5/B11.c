/*
 * B10.c
 * 
	Перевернуть число
	ВВвести целое число и «перевернуть» его, так чтобы первая цифра стала последней и т.д.

	Формат входных данных
	Целое неотрицательное число
	
	Формат результата
	Целое не отрицательное число наоборот

 */


#include <stdio.h>
#include <limits.h>
#define N 10			// Размер массива выбираем = 10 ячейкам , т.к. unsigned int max= UINT_MAX = 4294967295 
						// для данного компа занимает не более 10 ячеек


int main()
{
	unsigned int a, n=0; 	// в а вводим число, в n храним количество цифр составляющих данное число
	unsigned int mass[N]; // объявляем массив размерностью N 

//	unsigned int max= UINT_MAX; 
//	printf("%u", max);

	scanf("%d", &a);
//--------------------------------------------------------------------------	
// Разбираем число на составные цифры
//------------------------------------------------------------------------------
	if (a == 0)
			{		
				printf("%d", a);
				
			}
	for (int i=0; a != 0; i++)		// Вводим переменную i для индексации элементов массива			
		{
			mass[i] = a%10;	 		// Выделяем правую цифру числа и сохраняем ее в [i] - том элементе массива 
									// Цифры в массиве храняться в обратном порядке слева направо в первой ячейке массива i=0 
									// хранится самая последняя цифра введенного числа и т.д.					
			a /=10;		 			// Отбрасываем правую цифру числа
			n++;					// Увеличиваем счетчик цифр входящих в число n= количеству введенных цифр	
			printf("%d", mass[i]);	
		}
		

//printf("\n");
//------------------------------------------------------------------------------------
// Т.К. цифры в массиве расположены в обратном порядке, необходимо расположить их 
// в порядке в котром они вводились для удобства отображения
//------------------------------------------------------------------------------		
//	for (int i=0; i<n/2; i++)			// для (n/2) - пояснение:
// n =  количеству заполненных ячеек массива, n/2 означает, что мы берем одну половину массива и меняем ее со второй половиной местами
// если n нечетное то центальная ячейка не перемещается и остается на своем месте
// Поэтому число итераций цикла в два раза меньше, чем в функции разбивки числа на сосавные цифры
//		 {

//			 int b = mass[n-i-1]; 		// Значение крайней правой ячейки массива с последней цифрой сохраняем в переменную b

//			 mass[n-i-1] = mass[i];		// Записываем значение крайней левой ячейки массива в крайнюю правую ячейку массива

//			 mass[i] = b;				// переносим значение крайней правой ячейки из переменной b в крайнюю левую 
//		 }

//-----------------------------------------------------------------------------
// Выводим элементы массива на экран
//------------------------------------------------------------------------------
//	 for (int i=0; i<n; i++)	
//		 {
//			 printf("%d", mass[i]);

//		 }
//printf("\n");
	

	return 0;
}


