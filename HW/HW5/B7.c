/*
 * B7.c
 * 
	Две одинаковые цифры
	Ввести целое число и определить, верно ли, что в его записи есть   две одинаковые цифры, НЕ обязательно стоящие рядом.

	Формат входных данных
	Одно целое число
	
	Формат результата
	Одно слово: YES или NO

 */


#include <stdio.h>
#include <limits.h>
#define N 10			// Размер массива выбираем = 10 ячейкам , т.к. unsigned int max= UINT_MAX = 4294967295 
						// для данного компа занимает не более 10 ячеек

int main()
{
	unsigned int a, n=0; 	// в а вводим число, в n храним количество цифр составляющих данное число
	unsigned int mass[N]; // объявляем массив размерностью N 
//	unsigned int max= UINT_MAX; 
//	printf("%u", max);

	
	scanf("%d", &a);
//--------------------------------------------------------------------------	
// Разбираем число на составные цифры
//------------------------------------------------------------------------------
	for (int i=0; a != 0; i++)		// Вводим переменную i для индексации элементов массива			
		{
			mass[i] = a%10;	 		// Выделяем правую цифру числа и сохраняем ее в [i] - том элементе массива 
									// Цифры в массиве храняться в обратном порядке слева направо в первой ячейке массива i=0 
									// хранится самая последняя цифра введенного числа и т.д.
		//~ printf("i=%d ", i);
			a /=10;		 			// Отбрасываем правую цифру числа
		//~ printf("a=%d ", a);
			n++;					// Увеличиваем счетчик цифр входящих в число n= количеству введенных цифр
		//~ printf("n=%d ", n);
		//~ printf("%d", mass[i]);
		}
//------------------------------------------------------------------------------		
	//~ printf("\n");
/*
//------------------------------------------------------------------------------------
// Т.К. цифры в массиве расположены в обратном порядке, необходимо расположить их 
// в порядке в котром они вводились для удобства отображения
//------------------------------------------------------------------------------		
	for (int i=0; i<n/2; i++)			// для (n/2) - пояснение:
// n =  количеству заполненных ячеек массива, n/2 означает, что мы берем одну половину массива и меняем ее со второй половиной местами
// если n нечетное то центальная ячейка не перемещается и остается на своем месте
// Поэтому число итераций цикла в два раза меньше, чем в функции разбивки числа на сосавные цифры
		 {
				//~ printf("i=%d ", i);
				//~ printf("n=%d ", n);
			 int b = mass[n-i-1]; 		// Значение крайней правой ячейки массива с последней цифрой сохраняем в переменную b
				//~ printf("b=%d ", b);
			 mass[n-i-1] = mass[i];		// Записываем значение крайней левой ячейки массива в крайнюю правую ячейку массива
				//~ printf("mass[n-i-1]=%d ", mass[n-i-1]);
			 mass[i] = b;				// переносим значение крайней правой ячейки из переменной b в крайнюю левую 
				//~ printf("mass[i2]=%d\n", mass[i]);	
		 }
*/

//-----------------------------------------------------------------------------
// Выводим элементы массива на экран
//------------------------------------------------------------------------------
	//~ for (int i=0; i<n; i++)	
		//~ {
			//~ printf("%d", mass[i]);

		//~ }
	//~ printf("\n");
//-----------------------------------------------------------------------------
// Сравниваем числа в массиве каждое с каждым
//------------------------------------------------------------------------------
	for (int i=0, k=n; i<n; i++, k--)				
		{
				//~ printf("\ni=%d ", i);
				//~ printf("n=%d\n", n);
			 int b = mass[n-i-1]; 		// Значение крайней правой ячейки массива с последней цифрой сохраняем в переменную b
				
			 for(int j=1 ;j<k;j++)
				{
					//~ printf("k=%d ", k);
					//~ printf("j=%d ", j);
					//~ printf("b=%d ", b);
					//~ printf("mass[k-1-j]=%d\n", mass[k-1-j]);
					
					if (b == mass[k-1-j]) // Сравниваем b по очереди с каждой ячейкой слева
						{
							printf("\nYES\n");
							return 0;
						}
						
				}
				
			//	k--;

	
		}
	printf("NO\n");		
	return 0;
}
